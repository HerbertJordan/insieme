\section{Frontend}
\label{sec:Insieme.Frontend}

The frontend of the compiler is responsible of parsing an input program written
in a specific input language and to produce an IR program which semantically
equivalent to the input code. Because the IR is generic, many different input
programming languages can be represented by it. However a frontend must be
specific to an input language.

In the current development stage of the Insieme compiler only one frontend
exists for C-like languages based on the LLVM/Clang compiler~\cite{clang}. This
frontend supports C and C++, and above that it can deal with C language
extensions which are for example utilized for OpenCL and OpenMP. Because the
language extensions are always defined on top of a valid C/C++ code, the frontend
parse the input code in 2 major steps. In the first step, the sequential part of
the code is treated and converted into IR data structures. During this process,
information of eventual code extensions is collected and stored internally to
the frontend. In the second step, language extensions encountered in the input
code are applied to the generated IR and the final IR program is produced.  

\subsection{Overview of the Insieme Frontend [Simone]}
\label{sec:Insieme.Frontend.Overview}

The frontend's job is to convert the AST generated by the LLVM/Clang compiler
into the corresponding IR DAG. Before this conversion can take place, the AST of
an input C/C++ code has to be generated. An overview of the conversion chain
implemented in Insieme is depicted in Figure~\ref{fig:Frontend.Architecture}.
The major difference between how any C compiler works and Insieme starts here.
While a generic C compiler parses, analyzes and compiles each translation unit
of the input program separately (often for performance reasons); Insieme needs
to have the knowledge of the entire input program before the conversion can be
started. For example, in order to be constructed, a \type{CallExpr} node of
the IR needs a reference to the corresponding \type{LambdaExpr} node which
contains the body of the invoked function.  Therefore the \texttt{CallExpr} node
cannot be created before the invoked function has been converted. Because a
function body in a C program often refers to a function definition in a
different translation unit, all the content of the translation units composing
the input program needs to be collected before the IR conversion process can
start.  This part will be discussed in more details in
Section~\ref{sec:Insieme.Frontend.TranslationUnits}.

\begin{figure}[tb]
	\centering
	\includegraphics[width=\textwidth]{compiler/frontend/architecture.pdf}
	\caption{Overview of the frontend architecture}
	\label{fig:Frontend.Architecture}
\end{figure}

Once all translation units AST are in memory an analysis step on the entire
program is performed to capture eventual global and static variables in the
input code.  Indeed, because of the structural nature of the INSPIRE language,
variables are not referred by their name but instead by the DAG node
representing that variable. This makes it difficult to handle the semantics of
C/C++ \emph{global} and \emph{static} variables. In order to create a valid, and
semantically equivalent, IR program, the frontend needs to remove every global
variable from the program and accordingly replace them with plain variables
taking care of maintaining the semantics of the code. The details and
implementation issues related to the analysis phases performed for this issue
are discussed in Section~\ref{sec:Insieme.Frontend.Global}. 

Conversion of the Clang AST into an IR DAG is done using the well established
``Visitor'' design pattern~\cite{visitor-pattern}. The main idea is, for each
node of the Clang AST, to provide a transformation function which describe how
the C language entity (e.g. a variable declaration, an expression) should be
represented in the INSPIRE intermediate representation.  Management code makes
sure the generated IR nodes are automatically/correctly composed into a DAG. The
conversion of AST nodes of the C/C++ language is separated (for readability
issues) into 4 modules. 
\begin{description}
\item [\type{TypeConverter}] takes care of converting C/C++ data types (e.g. int,
array, struct) into the
corresponding IR types;
\item [\type{StmtConverter}] takes care of converting C statements (e.g. for, if,
switch) into the corresponding IR statements;
\item [\type{ExprConverter}] converts C expressions into IR expressions;
\item [\type{CxxConverter}] Converts C++ specific entities (e.g. virtual method
calls) into an IR representation.
\end{description}
These four modules are managed by the \type{ConversionManager} which is described
in Section~\ref{sec:Insieme.Frontend.Convert}
While the conversion of most of the C AST nodes is straightforward and heavily
documented in the source code, one of the challenges in the frontend is the way
recursive types and functions are generated. Handling of such problem is treated
in Section~\ref{sec:Insieme.Recursion}.

One of the major features, and efforts, of the Insieme frontend is the handling
of user pragmas. Indeed, as part of the Insieme project, an engine for pragma
matching on top of the Clang compiler was developed. This framework allows for
user pragmas to be easily defined in EBNF form. The engine takes care of
matching those pragmas and store in a separate data structure, as node
annotations, the pragma information for later
consumption~\ref{sec:Insieme.Pragmas}. A use case is the implementation of the
entire OpenMP 3.0 standard on top of our framework~\ref{sec:Insieme.OpenMP}.

During the conversion the frontend stores in the IR nodes, using annotations,
several information which can be used by the middle- and back-end to gain more
knowledge of the input program. An example are OpenMP annotations which are used
to store the information contained in the OpenMP pragmas present in the input
code. In equivalent way, annotations are used to store OpenCL attributes whose
semantics is then handled in the OpenCL compiler~\ref{sec:Insieme.OpenCL}.

\input{frontend/01_tran_units.tex}

\input{frontend/02_globals.tex}

\input{frontend/03_pragmas.tex}

\input{frontend/04_conversion.tex}

\input{frontend/05_recursion.tex}

\subsection{CXX Extensions}
\label{sec:Insieme.Frontend.CXX}
\todo{Ioannis/Bernard}

\input{frontend/10_ocl}

\input{frontend/11_omp}

\subsection{Known Issues}

There are several known bugs/missing feature within the compiler frontend which
either can be fixed (by someone willing to spend time on them) or cannot be dealt 
with because of the IR. 

\subsubsection{Chain of Assignments}

In C, assignments can be chained in the following way:
\begin{srcCode}
a=b=c=10;
\end{srcCode}
This is currently not supported in the frontend since the code will be
erroneously converted into a composition of {\tt ref.assign} calls. Since the
return type of those functions is \type{unit}, instead of \type{a'} like in C,
this will result in a semantic error. 

The error can be easily solved by splitting the assignment into multiple
initialization statements. 

\subsubsection{Assignments within Expressions}

There is an overall problem with assignments within expressions. While the C
grammar allows assignment operations to be used as normal expressions where
their return value is the same type of the assigned variable, in IR this is not
possible since the return value of an assignment is {\tt unit}. 

\begin{srcCode}
int c = a=10 + (b=3);
\end{srcCode}

As for the previous issue with chained assignments, conversion will produce a
semantically incorrect program; fortunately the semantic checks are able to
capture such cases. 

This is a bug of the frontend which can be easily fixed by splitting the
expression into many statements. However, in order to do so we must be careful
of eventual short-circuiting within the expressions (especially for boolean
expressions) which may result in a lazy update of a variable which therefore
cannot be assigned a priori. 

A workaround is to change the input code manually so that assignments are
eliminated from expressions.

\subsubsection{Call though function pointer to function using global variables}

This is an issue which is preventing many codes from being converted into
INSPIRE. A minimal test case is the following:

\begin{srcCode}
int f() {
	static int a=0;
	return ++a;
}

int main( ) {
	int (*fptr)() = f;
	f();
}
\end{srcCode}

The function \srcCodeInl{f} is invoked through a function pointer. Since the
global variable collection done by the frontend follows the static call graph of the
input program, and the binding of \srcCodeInl{f} here is dynamic; the function will not
be visited and variable {\tt a} will not be inserted in the global struct.
Consequently the signature of the function \srcCodeInl{f} is not changed (no additional
argument is introduced to pass the global struct), and at the call site no
parameter is provided. 

In order to solve this problem a more elaborated analysis is required for global
variable collection which is not limited to the static call graph of the
program. This requires extensive analysis and changes throughout the input code
since the signature of the relative function pointer needs to be changed and
also any other function which is invoked through that pointer needs to have the
signature updated (even though no global variable is accessed within the
function body). This kind of support solves the problem when functions pointer
are used within functions for which we have a definition. If the function
accepting the function pointer is an external function then the program cannot
be converted into INSPIRE. 

\ldots
