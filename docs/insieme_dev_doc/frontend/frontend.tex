\section{Frontend}
\label{sec:Insieme.Frontend}

The frontend of the compiler is responsible of parsing an input program written
in a specific input language and to produce an IR program which semantically
equivalent to the input code. Because the IR is generic, many different input
programming languages can be represented by it. However a frontend must be
specific to an input language.

In the current development stage of the Insieme compiler only one frontend
exists for C-like languages based on the LLVM/Clang compiler~\cite{clang}. This
frontend supports C and C++, and above that it can deal with C language
extensions which are for example utilized for OpenCL and OpenMP. Because the
language extensions are always defined on top of a valid C/C++ code, the frontend
parse the input code in 2 major steps. In the first step, the sequential part of
the code is treated and converted into IR data structures. During this process,
information of eventual code extensions is collected and stored internally to
the frontend. In the second step, language extensions encountered in the input
code are applied to the generated IR and the final IR program is produced.  

\subsection{Overview of the Insieme Frontend [Simone]}
\label{sec:Insieme.Frontend.Overview}

The frontend's job is to convert the AST generated by the LLVM/Clang compiler
into the corresponding IR DAG. Before this conversion can take place, the AST of
an input C/C++ code has to be generated. An overview of the conversion chain
implemented in Insieme is depicted in Figure~\ref{fig:Frontend.Architecture}.
The major difference between how any C compiler works and Insieme starts here.
While a generic C compiler parses, analyzes and compiles each translation unit
of the input program separately (often for performance reasons); Insieme needs
to have the knowledge of the entire input program before the conversion can be
started. For example, in order to be constructed, a \type{CallExpr} node of
the IR needs a reference to the corresponding \type{LambdaExpr} node which
contains the body of the invoked function.  Therefore the \texttt{CallExpr} node
cannot be created before the invoked function has been converted. Because a
function body in a C program often refers to a function definition in a
different translation unit, all the content of the translation units composing
the input program needs to be collected before the IR conversion process can
start.  This part will be discussed in more details in
Section~\ref{sec:Insieme.Frontend.TranslationUnits}.

\begin{figure}[tb]
	\centering
	%\includegraphics[width=\textwidth]{compiler/core/class_hierarchy_of_return_stmt.pdf}
	\includegraphics[width=\textwidth]{compiler/frontend/architecture.pdf}
	\caption{Overview of the frontend architecture}
	\label{fig:Frontend.Architecture}
\end{figure}

Once all translation units AST are in memory an analysis step on the entire
program is performed to capture eventual global and static variables in the
input code.  Indeed, because of the structural nature of the INSPIRE language,
variables are not referred by their name but instead by the DAG node
representing that variable. This makes it difficult to handle the semantics of
C/C++ \emph{global} and \emph{static} variables. In order to create a valid, and
semantically equivalent, IR program, the frontend needs to remove every global
variable from the program and accordingly replace them with plain variables
taking care of maintaining the semantics of the code. The details and
implementation issues related to the analysis phases performed for this issue
are discussed in Section~\ref{sec:Insieme.Frontend.Global}. 

Conversion of the Clang AST into an IR DAG is done using the well established
``Visitor'' design pattern~\cite{visitor-pattern}. The main idea is, for each
node of the Clang AST, to provide a transformation function which describe how
the C language entity (e.g. a variable declaration, an expression) should be
represented in the INSPIRE intermediate representation.  Management code makes
sure the generated IR nodes are automatically/correctly composed into a DAG. The
conversion of AST nodes of the C/C++ language is separated (for readability
issues) into 4 modules. 
\begin{description}
\item [\type{TypeConverter}] takes care of converting C/C++ data types (e.g. int,
array, struct) into the
corresponding IR types;
\item [\type{StmtConverter}] takes care of converting C statements (e.g. for, if,
switch) into the corresponding IR statements;
\item [\type{ExprConverter}] converts C expressions into IR expressions;
\item [\type{CxxConverter}] Converts C++ specific entities (e.g. virtual method
calls) into an IR representation.
\end{description}
These four modules are managed by the \type{ConversionManager} which is described
in Section~\ref{sec:Insieme.Convert}
While the conversion of most of the C AST nodes is straightforward and heavily
documented in the source code, one of the challenges in the frontend is the way
recursive types and functions are generated. Handling of such problem is treated
in Section~\ref{sec:Insieme.Recursion}.

One of the major features, and efforts, of the Insieme frontend is the handling
of user pragmas. Indeed, as part of the Insieme project, an engine for pragma
matching on top of the Clang compiler was developed. This framework allows for
user pragmas to be easily defined in EBNF form. The engine takes care of
matching those pragmas and store in a separate data structure, as node
annotations, the pragma information for later
consumption~\ref{sec:Insieme.Pragmas}. A use case is the implementation of the
entire OpenMP 3.0 standard on top of our framework~\ref{sec:Insieme.OpenMP}.

During the conversion the frontend stores in the IR nodes, using annotations,
several information which can be used by the middle- and back-end to gain more
knowledge of the input program. An example are OpenMP annotations which are used
to store the information contained in the OpenMP pragmas present in the input
code. In equivalent way, annotations are used to store OpenCL attributes whose
semantics is then handled in the OpenCL compiler~\ref{sec:Insieme.OpenCL}.

\subsection{Handling of Translation Units [Simone]}
\label{sec:Insieme.Frontend.TranslationUnits}

INSPIRE represents input programs as a whole. This opposes to the way C programs
are usually written, by splitting the entire program into multiple files or
\emph{translation units}. In the trivial case when the entire program is
contained into a single source file, then the generation of the INSPIRE program
can be generated by examining that single file.

\subsubsection{{\tt LLVM/Clang} Compiler Wrapper}

The Insieme frontend is shaped around the {\tt LLVM/Clang} compiler which
provides the utilities to perform syntactic and semantic analysis on the input
code. Because of performance reasons, the {\tt LLVM/Clang} compiler parses
translation units separately.  An instance of the {\tt LLVM/Clang} compiler
takes care of converting a C/C++ input file into an AST which is internally
represented by an object of the class \type{clang::ASTContext} 
{\tt [\url{http://clang.llvm.org/doxygen/classclang_1_1ASTContext.html}] }. 
In order to simplify the instantiation of {\tt LLVM/Clang} compiler instances,
the Insieme frontend implements a wrapper, \type{ClangCompiler} defined in the
\file{frontend/compiler.h} header providing a simple way of retrieving a {\tt
LLVM/Clang} AST from an input file. The class uses the PIMPL design pattern to
hide implementation details as much as possible to the consumer of this class.
The code which deals with the instantiation of a Clang compiler instance and the
setup of compilation flags being forwarded to Clang is isolated in the
\file{frontend/compiler.cpp} file. In the implementation code of the
\type{ClangCompiler} class we make sure that system include paths are correctly
set both for C and C++ headers. Several other flags are forwarded from the
Insieme input flags. 

\subsubsection{Storing Translation Units}

The \type{ClangCompiler} contains the AST generated by the {\tt LLVM/CLang}
compiler. When the instance of this class is destroyed also the associated
\type{clang::ASTContext} is lost. Therefore it is important to keep alive
instances of the \type{ClangCompier} class until the conversion of the input
program to IR code is completed. Together with the AST of a translation Insieme
can also store additional data structures which refer to the translation unit
for later use. An example is the content of user pragmas within the input code.
Because {\tt LLVM/Clang} is not capable of store the information on user
pragmas, during the generation of AST we store all the pragmas into a separate
data structure \type{frontend::pragma::PragmaList} which contains the list of
pragmas in the current translation unit; where each pragma points to the AST
statement it was associated to. Once a translation unit is processed, all the
information are stored in the \type{frontend::TranslationUnit} class. 

\subsubsection{Frontend's Main Entry Point}

The task of keeping alive translation units is performed by the
\type{frontend::Program} class defined in \file{frontend/program.h}. Also this
class uses the PIMPL design pattern to hide its implementation details. The
interface of this is the main entry point of the Insieme frontend. The
constructor of the \type{Program} class accept a \type{core::NodeManager}, which
will be used during the conversion from C to IR.  The method
\decl{addTranslationUnit(const std::string& file)} has the purpose of loading
the AST of the {\tt file} into memory. When all translation units are loaded,
the \type{convert()} function triggers the conversion of the input program into
an IR DAG. 

An example of how to manually instantiate the frontend: 
\begin{srcCode}
using namespace insieme;

using core::NodeManager;
using frontend::Program;

NodeManager mgr;
Program p(mgr);
p.addTranslationUnits( {"file1.c", "file2.c"} );
// Use the settings provided by he input line arguments 
core::ProgramPtr ir = p.convert();
\end{srcCode}

This way of initializing the frontend requires command line options, which for
example contains the list of include folders and preprocessor definitions, to be
previously set (see \ref{Command.Line.Args}). Another way of invoking the
frontend overwriting the values set via command line options is
provided by the \type{frontend::ConversionJob} \emph{facade} defined in
\file{frontend/frontend.h}.

\begin{srcCode}
using namespace insieme;

using core::NodeManager;
using frontend::ConversionJob;

NodeManager mgr;
ConversionJob job(mgr, {"file1.c", "file2.c"}, {".", "/usr/include"});
// Enable OpenMP support
job.setOption(frontend::ConversionJob::OpenMP, true);
core::ProgramPtr ir = job.execute();
\end{srcCode}

When a new translation unit is add, the parser of the {\tt LLVM/Clang} compiler
is invoked on that file and AST is generated. This action is triggered by the
constructor of a \type{TranslationUnitImpl} object which is defined in
\file{frontend/program.cpp}. The constructor of this class takes care of
registering pragma handler (see Section~\ref{sec:Insieme:Pragmas}) and starting
the parser which perform syntactic and semantic checks on the input code. If the
translation unit contains no errors, the \type{clang::ASTContext} object is
returned. 

The next operation performed on the AST associated to the translation unit is
\emph{indexing}. Indeed, because during the IR generation we need to be able to
retrieve, by name, symbols which may have been defined in a different
translation units we need to generate an index, or symbol table, which allows us
to easily find definitions given a name. Fortunately, the {\tt LLVM/Clang}
compiler provide an indexing utility \type{clang::idx::Index}.

Once every translation unit is loaded, and the index is populated the last
action before the conversion starts is to locate the main entry point of the
input program. Insieme (at this development stage) can only correctly deal with
input codes having an entry point. For example, Insieme cannot be used to
compiler a library code. The reason is mostly connected with the design
of the IR which enforces restrictions on the way global and static variables are
used. We cover this aspect in detail in the next
Section~\ref{sec:Insieme:Frontend:Global}. In order to locate the entry point of
the input code we generate the whole call-graph of and then locate the entry
point. This is done using the \type{clang::CallGrpah} utility provided by the
{\tt LLVM/Clang} compiler. If the input program has not entry point, the
frontend launch an exception and quite the compilation process. If the main
entry point is present, then the C/C++ to IR conversion is started. 

\subsection{Handling Global Variables [Simone]}
\label{sec:Insieme.Frontend.Global}
\todo{week24}

\subsection{Conversion Manager [Simone]}
\label{sec:Insieme.Convert}
\todo{week25}

\subsection{Recursive Type and Functions [Simone]}
\label{sec:Insieme.Recursion}
\todo{week26}

\subsection{Matching of User Pragmas [Simone]}
\label{sec:Insieme.Pragmas}
\todo{week27}

\input{frontend/ocl}

\input{frontend/omp}

