\section{Frontend}
\label{sec:Insieme.Frontend}

The frontend of the compiler is responsible of parsing an input program written
in a specific input language and to produce an IR program which semantically
equivalent to the input code. Because the IR is generic, many different input
programming languages can be represented by it. However a frontend must be
specific to an input language.

In the current development stage of the Insieme compiler only one frontend
exists for C-like languages based on the LLVM/Clang compiler~\cite{clang}. This
frontend supports C and C++, and above that it can deal with C language
extensions which are for example utilized for OpenCL and OpenMP. Because the
language extensions are always defined on top of a valid C/C++ code, the frontend
parse the input code in 2 major steps. In the first step, the sequential part of
the code is treated and converted into IR data structures. During this process,
information of eventual code extensions is collected and stored internally to
the frontend. In the second step, language extensions encountered in the input
code are applied to the generated IR and the final IR program is produced.  

\subsection{Overview of the Insieme Frontend}
\label{sec:Insieme.Frontend.Overview}

The frontend's job is to convert the AST generated by the LLVM/Clang compiler
into the corresponding IR DAG. Before this conversion can take place, the AST of
an input C/C++ code has to be generated. An overview of the conversion chain
implemented in Insieme is depicted in Figure~\ref{fig:Frontend.Architecture}.
The major difference between how any C compiler works and Insieme starts here.
While a generic C compiler parses, analyzes and compiles each translation unit
of the input program separately (often for performance reasons); Insieme needs
to have the knowledge of the entire input program before the conversion can be
started. For example, in order to be constructed, a \texttt{CallExpr} node of
the IR needs a reference to the corresponding \texttt{LambdaExpr} node which
contains the body of the invoked function.  Therefore the \texttt{CallExpr} node
cannot be created before the invoked function has been converted. Because a
function body in a C program often refers to a function definition in a
different translation unit, all the content of the translation units composing
the input program needs to be collected before the IR conversion process can
start.  This part will be discussed in more details in
Section~\ref{sec:Insieme.Frontend.TranslationUnits}.

\begin{figure}[tb]
	\centering
	%\includegraphics[width=\textwidth]{compiler/core/class_hierarchy_of_return_stmt.pdf}
	\includegraphics[width=\textwidth]{compiler/frontend/architecture.pdf}
	\caption{Overview of the frontend architecture}
	\label{fig:Frontend.Architecture}
\end{figure}

Once all translation units AST are in memory an analysis step on the entire
program is performed to capture eventual global and static variables in the
input code.  Indeed, because of the structural nature of the INSPIRE language,
variables are not referred by their name but instead by the DAG node
representing that variable. This makes it difficult to handle the semantics of
C/C++ \emph{global} and \emph{static} variables. In order to create a valid, and
semantically equivalent, IR program, the frontend needs to remove every global
variable from the program and accordingly replace them with plain variables
taking care of maintaining the semantics of the code. The details and
implementation issues related to the analysis phases performed for this issue
are discussed in Section~\ref{sec:Insieme.Frontend.Global}. 

Conversion of the Clang AST into an IR DAG is done using the well established
``Visitor'' design pattern~\cite{visitor-pattern}. The main idea is, for each
node of the Clang AST, to provide a transformation function which describe how
the C language entity (e.g. a variable declaration, an expression) should be
represented in the INSPIRE intermediate representation.  Management code makes
sure the generated IR nodes are automatically/correctly composed into a DAG. The
conversion of AST nodes of the C/C++ language is separated (for readability
issues) into 4 modules. 
\begin{description}
\item [{\tt TypeConverter}] takes care of converting C/C++ data types (e.g. int,
array, struct) into the
corresponding IR types;
\item [{\tt StmtConverter}] takes care of converting C statements (e.g. for, if,
switch) into the corresponding IR statements;
\item [{\tt ExprConverter}] converts C expressions into IR expressions;
\item [{\tt CxxConverter}] Converts C++ specific entities (e.g. virtual method
calls) into an IR representation.
\end{description}
These four modules are managed by the {\tt ConversionManager} which is described
in Section~\ref{sec:Insieme.Convert}
While the conversion of most of the C AST nodes is straightforward and heavily
documented in the source code, one of the challenges in the frontend is the way
recursive types and functions are generated. Handling of such problem is treated
in Section~\ref{sec:Insieme.Recursion}.

One of the major features, and efforts, of the Insieme frontend is the handling
of user pragmas. Indeed, as part of the Insieme project, an engine for pragma
matching on top of the Clang compiler was developed. This framework allows for
user pragmas to be defined in EBNF form. The engine takes care of matching those
pragmas and store in a separate data structure, as node annotations, the pragma
information for later consumption~\ref{sec:Insieme.Pragmas}. A use case is the
implementation of the entire OpenMP 3.0 standard on top of our
framework~\ref{sec:Insieme.OpenMP}. 

\subsection{Handling of Translation Units}
\label{sec:Insieme.Frontend.TranslationUnits}
\todo{week24}

\subsection{Handling of Global Variables}
\label{sec:Insieme.Frontend.Global}
\todo{week24}

\subsection{Conversion Manager}
\label{sec:Insieme.Convert}
\todo{week25}

\subsection{Recursive Type and Functions}
\label{sec:Insieme.Recursion}
\todo{week26}

\subsection{Matching of User Pragmas}
\label{sec:Insieme.Pragmas}
\todo{week27}

%\input{frontend/ocl}

\input{frontend/omp}

