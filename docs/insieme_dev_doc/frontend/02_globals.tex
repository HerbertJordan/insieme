\subsection{Global/Static Variables [Simone]}
\label{sec:Insieme.Frontend.Global}

One of the main effort of the frontend is to convert the nominal semantics C/C++
input code into structural form which is required by the INSPIRE representation.
Indeed, in C and C++ symbols are addressed by the name and not the symbol
definition itself. This allow to declare a variable, or class, in the header
file and place the corresponding definition in any of the translation units.
However while there can be multiple declaration of a symbol, there must be only
one definition (a.k.a. one-definition-rule). 

In INSPIRE things works differently as the language is based on a structural
form where objects are identified by their structure and not their name. This
produce several implication for example with recursive types and function calls
which we will cover later in Section~\ref{sec:Insieme.Frontend.Recursion}. The
structural nature of Insieme also imposes limitations on several feature of the
C language. One of them is global and static variables. Related work on why it
is important to avoid global variables in parallel programs can be found in
\cite{Zheng:2011:AHG:2117686.2118457}. 

\subsubsection{Lack of Global Variables in INSPIRE}
The main reason for not having native support for global variables in Insieme is
the fact that INSPIRE was designed to support parallel analysis and code
transformations. Indeed, having global and static variables forces the
middle-end of the compiler to deal with such concepts thereby adding more
complexity to the analysis and transformation modules.

\subsubsection{Global Variables Erasure Algorithm}
 Fortunately, the practice of using global variables is highly discouraged and
 there is always a way to rewrite a program in order to remove any use of global
 variables.  An example of how a C code which make use of global variables can
 be rewritten is the following:

\begin{srcCode}
int g = 1;
int f() {
	static int s = 2;
	return s+=g;
}
int main() {
	g=2; printf("[%d,", f());
	g=4; printf("%d]", f());
}
\end{srcCode}

The code contains a global variable {\tt g} and a static variable {\tt s}
defined in the {\tt f()} function. The output of this code is {\tt [4,8]}. 

A semantically equivalent code which makes no use of global/static variable is the
following:

\begin{srcCode}
typedef struct { int g; int s; } global_t;

int f(global_t* const __i_glob) {
	return __i_glob->s += __i_glob->g;
}
int main() {
	global_t __i_glob = {1, 2};

	__i_glob.g=2; printf("[%d,", f(&__i_glob));
	__i_glob.g=4; printf("%d]", f(&__i_glob));
}
\end{srcCode}

While the code may look awful, the required transformation steps which are
necessary to generate such code are sound and simple to understand. We split the
global variable erasure procedure into two phases, (\emph{i}) an analysis phase
which gather informations, and a (\emph{ii}) transformation phase which performs
the erasure.
\begin{description}
\item [Analysis]
	\begin{itemize}
	\item The first step is the collection of all global/static variables utilized
	within the input code. This can be done by following the call-graph of the program
	so that variables belonging to section of the code which is not entered are simply
	discarded. 
	
	\item Together with the list of global/static variables, we also keep a list of
	functions which either declare a static variable or uses one of the global
	variables. Once a function is marked as depending on global variables,
	the functions on the call-stack are marked as well.

	\item For each variable we keep its initialization value. Notice that the
	C/C++ standard enforces that the initialization value of a global, or static
	variable, must be a constant expression therefore it is not possible write {\tt
	static int v = c;}. This make sure initialization values gathered at compile
	time are valid.
	\end{itemize}

\item[Transform] 
	\begin{itemize}
	\item Allocate a data structure whose members are the collected global
	variables {\tt \_\_i\_glob} as first instruction of the main.

	\item The initial value of the single variables is the initialization value
	gathered during the analysis phase. 

	\item The signature of every function which was detected to be using global
	variables (either directly or indirectly) is rewritten by adding a new input
	argument which represent a reference to the global structure containing the
	global variables.

	\item At the same way, every call-site involving functions accepting the
	global structure must be modified.	
	\end{itemize}
\end{description}


\subsubsection{``Extern'' Qualifier}

Additional considerations must be made for the {\tt extern} qualifier. The C
standard says:
\begin{quotation}
\small
The extern keyword means "declare without defining". In other words, it is a way
to explicitly declare a variable, or to force a declaration without a
definition. It is also possible to explicitly define a variable, i.e. to force a
definition. It is done by assigning an initialization value to a variable. If
neither the extern keyword nor an initialization value are present, the
statement can be either a declaration or a definition. It is up to the compiler
to analyse the modules of the program and decide. 
\end{quotation}

Because of its semantics, the {\tt extern} keyword may not be properly handled.
The Insieme compiler is able to deal with 2 use cases of the {\tt extern}
keyword:
\begin{itemize}
\item In all translation units a variable is always declared with an {\tt
extern} qualifier. In this circumstances, the Insieme compiler assumes that the
variable is declared in an external library and therefore instead of allocating
the variable in the global structs, it allocates a reference to the existing
definition (an example are usages of the {\tt stderr} variable defined in the
libc). We let the backend compiler check for proper linkage. 

\item The variable is declared with the {\tt extern} qualifier in several
translation units but one of them define the variable. In that case the variable
is treated as any other global variables.
\end{itemize}

\subsubsection{Handling of Global Variables in Insieme}

The two phases of the global erasure algorithm are implemented in the Insieme
frontend. The analysis phase is performed by the
\type{frontend::analysis::GlobalVarCollector} class, defined in
\file{frontend/analysis/global\_variables.h}. The class implements the visitor
pattern and it performs a recursive visit of the {\tt LLVM/Clang} AST following
the call graph of the program starting from the main function. Three data
structure are filled up during this pass: \begin{description}

\item [GlobalVarSet:] Set of global variables used in the program; This is a
pointer to a \type{clang::VarDecl} AST node which contains information on the
type of the variable and eventual initialization value. In the case a variable
is declared multiple times, we only store the pointer to the variable definition
which contains the actual initialization value for that variable. 
\item [VarTUMap:] A map connecting variables declarations to the translation unit
where the variable was defined;
\item [UsingGlobalFuncMap:] Set of functions which (directly or indirectly)
access global variables;
\end{description}

The visitor object is executed on the Clang AST. The visitor only visits few
selected nodes looking for variable usage and declarations. When a variable is
utilized the visitor checks whether the variable has been defined with a global
storage or not. If yes, the variable is inserted into the \type{GlobalVarSet}.
Variable declarations are also examined by looking if the variable is being
declared with a {\tt static} modifier. In that case the variable is inserted
into the set. 

Another node which is visited during the recursing visit of the {\tt LLVM/Clang}
AST is the \type{clang::CallExpr} as we need to keep track of the call-stack we
use a stack to keep track of the current invocation context. In order to avoid
recursion we make sure to not visit the same function twice. Once a global
variable usage of a static declaration is found in a function all the functions
in the call stack are inserted into the \type{UsingGlobalFuncMap}. This map will
be used during the conversion process to adjust function signature for those
functions who need to forward the global data structure. 

Once the visit is completed the result of the analysis can be obtained via the
\srcCodeInl{GlobalVarSet GlobalVarCollector::getGlobals() const} and
\srcCodeInl{UseGlobalFuncMap GlobalVarCollector::getUsingGlobals() const}. The
\type{GlobalVarCollector}
class also takes care of generating the INSPIRE global data structures used to
hold the value of global variables. This is retuned as a pair containing a type
object and the initial value which represent the initial state of the global
variables. The methods \srcCodeInl{GlobalStructPair
GlobalVarCollector::createGlobalStruct()} takes care of this operation. It is
worth noting that the method is not declared {\tt const} as internally a C to IR
conversion is performed. As we will see later, because of performance reasons,
caching is utilized during the conversion process therefore the
\type{ConversionManager} is state-full and that's the reason why the
\srcCodeInl{createGlobalStruct} function is not pure. 

\subsubsection{Replacing Global Variable Access}

During the conversion from C/C++ to INSPIRE process the information gathered in
the previous step are utilized in order to replace every access to global/static
variables with an access to members of the global structure allocated in the
main function. We will cover this aspect in details when we present the
\type{ConversionManager} in Section~\ref{sec:Insieme.Frontend.Convert}. 

However the process can be summarized as follows. Every time a variable is
utilized in the code, therefore every time we visit a node of type
\type{clang::DeclRefExpr} the frontend checks whether the declaration of that
variable is in the set of global variables. If yes, the variable access is
replaced with a member access to the global structure. A second scenario is when
the \type{ConversionManager} converts a definition of a static variable. In that
case the conversion procedure yields an empty IR node as the static variable is
now defined within the global structure. \todo{ref}

The last operation the frontend has to perform is the adaptation of function
signatures, and call expressions to receive the structure containing the global
values. \todo{ref}

