// --- Generated Inspire Code ---
#include <alloca.h>
#include <stddef.h>
#include <stdlib.h>
#include <runtime.h>
#define bool int
#define true 1
#define false 0
#define null 0
// --- Entry Point ---

// start code fragment :: Prototype for external function: clock ... type: (()->int<8>) //
long clock();

// start code fragment :: Prototype for external function: atoi ... type: (()->int<4>) //
int atoi();

// start code fragment :: Prototype for external function: printf ... type: ((ref<array<char,1>>,var_list)->int<4>) //
int printf(char*, ...);

// start code fragment :: Prototype for external function: memset ... type: ((ref<array<'a,1>>,int<4>,uint<8>)->ref<array<'a,1>>) //
void* memset(void*, int, unsigned long);

// start code fragment :: Prototype for external function: sin ... type: ((real<8>)->real<8>) //
double sin(double);

// start code fragment :: Definition of init_func //
double init_func(int x, int y) {
	{
		return (((double)(40))*sin(((double)(((16*((2*x)-1))*y)))));;
	}
}


// start code fragment :: Prototype for external function: pow ... type: ((real<8>,real<8>)->real<8>) //
double pow(double, double);

// start code fragment :: struct for job __insieme_expr_0 //
struct __insieme_expr_0 { 
	unsigned structSize;
	unsigned min, max;
	void (*fun)(isbr_JobArgs*);
	// ---- additional captured variables -----
	float** var_52;
	float** var_53;
	int* var_54;
	float** var_55;
	double* var_56;
};

// start code fragment :: Definitions for function type: __insieme_funType_type_1 //
// Abstract prototype for lambdas of type __insieme_funType_type_1
struct __insieme_funType_type_1 { 
    void(*fun)(void*);
};

// Type safe function for invoking lambdas of type __insieme_funType_type_1
void call__insieme_funType_type_1(struct __insieme_funType_type_1* lambda) {  lambda->fun(lambda); }

// start code fragment :: Definitions for function type: __insieme_funType_type_3 //
// Abstract prototype for lambdas of type __insieme_funType_type_3
struct __insieme_funType_type_3 { 
    void(*fun)(void*);
    float** p0;
    float** p1;
    int* p2;
    float** p3;
    double* p4;
};

// start code fragment :: capture-struct for pfor-body __insieme_expr_4 //
struct capture__insieme_expr_4 {
	float** var_39;
	float** var_40;
	double* var_38;
	float** var_41;
	int* var_42;
};

// start code fragment :: function for pfor-body __insieme_expr_4 //
void __insieme_expr_4(const isbr_PForRange range) {
	// ----- captured variables -----
	float** var_57 = ((struct capture__insieme_expr_4*)(range.context))->var_39;
	float** var_58 = ((struct capture__insieme_expr_4*)(range.context))->var_40;
	double* var_59 = ((struct capture__insieme_expr_4*)(range.context))->var_38;
	float** var_60 = ((struct capture__insieme_expr_4*)(range.context))->var_41;
	int* var_61 = ((struct capture__insieme_expr_4*)(range.context))->var_42;
	
	// ----- process iterations -----
	for(int __it = range.start; __it<range.end; __it+=range.step) {
		{
			for(int j = 1; j < ((*var_61)-1); j += 1) {
				((((*var_58)[((unsigned int)(((__it*(*var_61))+(j))))])) = ((float)(((((double)(1))/((double)(4)))*(((double)(((((((*var_60)[((unsigned int)((((__it-1)*(*var_61))+(j))))]))+(((*var_60)[((unsigned int)((((__it*(*var_61))+(j))+1)))])))+(((*var_60)[((unsigned int)((((__it*(*var_61))+(j))-1)))])))+(((*var_60)[((unsigned int)((((__it+1)*(*var_61))+(j))))])))))-((*var_59)*((double)((((*var_57)[((unsigned int)(((__it*(*var_61))+(j))))]))))))))));
			};
		};
	}
	
}

// start code fragment :: Definition of __insieme_supp_2 //
void __insieme_supp_2(void* _capture) {
	// --------- Captured Stuff - Begin -------------
	float** var_41 = ((struct __insieme_funType_type_3*)_capture)->p0;
	float** var_39 = ((struct __insieme_funType_type_3*)_capture)->p1;
	int* var_42 = ((struct __insieme_funType_type_3*)_capture)->p2;
	float** var_40 = ((struct __insieme_funType_type_3*)_capture)->p3;
	double* var_38 = ((struct __insieme_funType_type_3*)_capture)->p4;
	// --------- Captured Stuff -  End  -------------
	{
		{
			isbr_pfor(isbr_getThreadGroup(0),(isbr_PForRange){1, ((*var_42)-1), 1, &((struct capture__insieme_expr_4){var_39, var_40, var_38, var_41, var_42})},&__insieme_expr_4);
			isbr_barrier(isbr_getThreadGroup(0));
		};
	}
}


// start code fragment :: function for job __insieme_expr_0 //
void fun__insieme_expr_0(isbr_JobArgs* args) {
	// ----------- Unpacking local scope variables ----------
	// ---------- Unpacking auto-captured variables ---------
	float** var_52 = ((struct __insieme_expr_0*)args)->var_52;
	float** var_53 = ((struct __insieme_expr_0*)args)->var_53;
	int* var_54 = ((struct __insieme_expr_0*)args)->var_54;
	float** var_55 = ((struct __insieme_expr_0*)args)->var_55;
	double* var_56 = ((struct __insieme_expr_0*)args)->var_56;
	// ------------------ Processing Guards -----------------
	// ------------------ Default processing -----------------
	__insieme_supp_2(((struct __insieme_funType_type_1*)(&((struct __insieme_funType_type_3){0,var_52,var_53,var_54,var_55,var_56}))));
}

// start code fragment :: Prototype for external function: memcpy ... type: ((ref<array<'a,1>>,ref<array<'a,1>>,uint<8>)->ref<array<'a,1>>) //
void* memcpy(void*, void*, unsigned long);

// start code fragment :: Prototype for external function: sqrt ... type: ((real<8>)->real<8>) //
double sqrt(double);

// start code fragment :: Definition of main //
int main(int argc, char** argv) {
	{
		long start_t = 0;
		long end_t = 0;
		double setup_time = 0.0;
		double elapsed_time = 0.0;
		((start_t) = clock());
		int N = 650;
		if((argc>1)) {
			((N) = atoi(((argv[((unsigned int)(1))]))));
		};
		int numIter = 100;
		if((argc>2)) {
			((numIter) = atoi(((argv[((unsigned int)(1))]))));
		};
		float* u;
		float* tmp;
		float* f;
		float* res;
		((u) = ((malloc(sizeof(float)*((((unsigned long)(((N)*(N))))*sizeof(float))/sizeof(float))))));
		((tmp) = ((malloc(sizeof(float)*((((unsigned long)(((N)*(N))))*sizeof(float))/sizeof(float))))));
		((f) = ((malloc(sizeof(float)*((((unsigned long)(((N)*(N))))*sizeof(float))/sizeof(float))))));
		((res) = ((malloc(sizeof(float)*((((unsigned long)(((N)*(N))))*sizeof(float))/sizeof(float))))));
		if((!(((((bool)(u))&&<?>Unhandled Type of Call Target</?>)&&<?>Unhandled Type of Call Target</?>)&&<?>Unhandled Type of Call Target</?>))) {
			printf("Error allocating arrays\n", 0);
		};
		memset(u, 0, (((unsigned long)(((N)*(N))))*sizeof(float)));
		memset(f, 0, (((unsigned long)(((N)*(N))))*sizeof(float)));
		for(int i = 0; i < (N); i += 1) for(int j = 0; j < (N); j += 1) {
			(((f[((unsigned int)((((i)*(N))+(j))))])) = ((float)(init_func((i), (j)))));
		};
		double comm_time = ((double)(0));
		double comp_time = ((double)(0));
		double timer = ((double)(0));
		double resv = 0.0;
		double factor = pow((((double)(1))/((double)((N)))), ((double)(2)));
		((end_t) = clock());
		((setup_time) = (((double)(((end_t)-(start_t))))/((double)(1000000l))));
		((start_t) = clock());
		for(int it = 0; it < (numIter); it += 1) {
			isbr_merge(isbr_parallel(memcpy(malloc(sizeof(struct __insieme_expr_0)),&((struct __insieme_expr_0){sizeof(struct __insieme_expr_0),1,isbr_getMaxThreads(),&fun__insieme_expr_0,&u,&f,&N,&tmp,&factor}),sizeof(struct __insieme_expr_0))));
			memcpy(u, tmp, (((unsigned long)(((N)*(N))))*sizeof(float)));
			for(int i = 1; i < ((N)-1); i += 1) {
				for(int j = 1; j < ((N)-1); j += 1) {
					(((res[((unsigned int)((((i)*(N))+(j))))])) = (((((((f[((unsigned int)((((i)*(N))+(j))))]))-(((float)(4))*((u[((unsigned int)((((i)*(N))+(j))))]))))+((u[((unsigned int)(((((i)-1)*(N))+(j))))])))+((u[((unsigned int)(((((i)+1)*(N))+(j))))])))+((u[((unsigned int)(((((i)*(N))+(j))-1)))])))+((u[((unsigned int)(((((i)*(N))+(j))+1)))]))));
				};
			};
			double norm = ((double)(0));
			for(int i = 1; i < ((N)-1); i += 1) {
				for(int j = 1; j < ((N)-1); j += 1) {
					((norm) = ((norm)+pow(((double)(((res[((unsigned int)((((i)*(N))+(j))))])))), ((double)(2)))));
				};
			};
			((resv) = (sqrt((norm))/((double)(((N)-1)))));
		};
		((end_t) = clock());
		((elapsed_time) = (((double)(((end_t)-(start_t))))/((double)(1000000l))));
		( free(u));
		( free(tmp));
		( free(f));
		( free(res));
		printf("Job Done! - residuo: %lf\n", (resv));
	}
}

