// --- Generated Inspire Code ---
#include <alloca.h>
#include <stddef.h>
#include <stdlib.h>
#include <runtime.h>
#define bool int
#define true 1
#define false 0
#define null 0
// --- Entry Point ---

// start code fragment :: Prototype for external function: clock //
long clock();

// start code fragment :: Prototype for external function: memset //
void* memset(void*, int, unsigned long);

// start code fragment :: Prototype for external function: sin //
double sin(double);

// start code fragment :: Definition of init_func //
double init_func(int x, int y) {
	{
		return (((double)(40))*sin(((double)(((16*((2*x)-1))*y)))));;
	}
}


// start code fragment :: Prototype for external function: pow //
double pow(double, double);

// start code fragment :: struct for job __insieme_expr_0 //
struct __insieme_expr_0 { 
	unsigned structSize;
	unsigned min, max;
	void (*fun)(isbr_JobArgs*);
	// ---- additional captured variables -----
	float(* var_43)[650][650];	 // Variable: v43
	double* var_44;	 // Variable: v44
	float(* var_45)[650][650];	 // Variable: v45
	float(* var_46)[650][650];	 // Variable: v46
};

// start code fragment :: Definitions for function type: __insieme_funType_type_1 //
// Abstract prototype for lambdas of type __insieme_funType_type_1
struct __insieme_funType_type_1 { 
    void(*fun)(void*);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_1
void call__insieme_funType_type_1(struct __insieme_funType_type_1* lambda) { return lambda->fun(lambda); }

// start code fragment :: Definitions for function type: __insieme_funType_type_2 //
// Abstract prototype for lambdas of type __insieme_funType_type_2
struct __insieme_funType_type_2 { 
    void(*fun)(void*);
    const size_t size;
    float(* p0)[650][650];
    double* p1;
    float(* p2)[650][650];
    float(* p3)[650][650];
};

// start code fragment :: capture-struct for pfor-body __insieme_expr_4 //
struct capture__insieme_expr_4 {
	float(* var_32)[650][650];
	float(* var_33)[650][650];
	double* var_31;
	float(* var_34)[650][650];
};

// start code fragment :: Definitions for function type: __insieme_funType_type_5 //
// Abstract prototype for lambdas of type __insieme_funType_type_5
struct __insieme_funType_type_5 { 
    void(*fun)(void*, int);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_5
void call__insieme_funType_type_5(struct __insieme_funType_type_5* lambda, int p1) { return lambda->fun(lambda, p1); }

// start code fragment :: Definitions for function type: __insieme_funType_type_6 //
// Abstract prototype for lambdas of type __insieme_funType_type_6
struct __insieme_funType_type_6 { 
    void(*fun)(void*, int);
    const size_t size;
    float(* p0)[650][650];
    float(* p1)[650][650];
    double* p2;
    float(* p3)[650][650];
};

// start code fragment :: Definition of __insieme_supp_7 //
void __insieme_supp_7(void* _capture, int var_41) {
	// --------- Captured Stuff - Begin -------------
	float(* var_40)[650][650] = ((struct __insieme_funType_type_6*)_capture)->p0;
	float(* var_39)[650][650] = ((struct __insieme_funType_type_6*)_capture)->p1;
	double* var_38 = ((struct __insieme_funType_type_6*)_capture)->p2;
	float(* var_37)[650][650] = ((struct __insieme_funType_type_6*)_capture)->p3;
	// --------- Captured Stuff -  End  -------------
	{
		for(int j = 1; j < (650-1); j += 1) {
			((((*var_39)[((unsigned int)(var_41))][((unsigned int)((j)))])) = ((float)(((((double)(1))/((double)(4)))*(((double)(((((((*var_37)[((unsigned int)((var_41-1)))][((unsigned int)((j)))]))+(((*var_37)[((unsigned int)(var_41))][((unsigned int)(((j)+1)))])))+(((*var_37)[((unsigned int)(var_41))][((unsigned int)(((j)-1)))])))+(((*var_37)[((unsigned int)((var_41+1)))][((unsigned int)((j)))])))))-((*var_38)*((double)((((*var_40)[((unsigned int)(var_41))][((unsigned int)((j)))]))))))))));
		};
	}
}


// start code fragment :: function for pfor-body __insieme_expr_4 //
void __insieme_expr_4(const isbr_PForRange range) {
	// ----- captured variables -----
	float(* var_32)[650][650] = ((struct capture__insieme_expr_4*)(range.context))->var_32;
	float(* var_33)[650][650] = ((struct capture__insieme_expr_4*)(range.context))->var_33;
	double* var_31 = ((struct capture__insieme_expr_4*)(range.context))->var_31;
	float(* var_34)[650][650] = ((struct capture__insieme_expr_4*)(range.context))->var_34;
	
	// ----- process iterations -----
	for(int __it = range.start; __it<range.end; __it+=range.step) {
		call__insieme_funType_type_5(((struct __insieme_funType_type_5*)(&((struct __insieme_funType_type_6){&__insieme_supp_7, 0, var_32, var_33, var_31, var_34}))), __it);
	}
	
}

// start code fragment :: Definition of __insieme_supp_3 //
void __insieme_supp_3(void* _capture) {
	// --------- Captured Stuff - Begin -------------
	float(* var_34)[650][650] = ((struct __insieme_funType_type_2*)_capture)->p0;
	double* var_31 = ((struct __insieme_funType_type_2*)_capture)->p1;
	float(* var_33)[650][650] = ((struct __insieme_funType_type_2*)_capture)->p2;
	float(* var_32)[650][650] = ((struct __insieme_funType_type_2*)_capture)->p3;
	// --------- Captured Stuff -  End  -------------
	{
		{
			isbr_pfor(isbr_getThreadGroup(0),(isbr_PForRange){1, (650-1), 1, &((struct capture__insieme_expr_4){var_32, var_33, var_31, var_34})},&__insieme_expr_4);
			isbr_barrier(isbr_getThreadGroup(0));
		};
	}
}


// start code fragment :: function for job __insieme_expr_0 //
void fun__insieme_expr_0(isbr_JobArgs* args) {
	// ----------- Unpacking local scope variables ----------
	// ---------- Unpacking auto-captured variables ---------
	float(* var_43)[650][650] = ((struct __insieme_expr_0*)args)->var_43;
	double* var_44 = ((struct __insieme_expr_0*)args)->var_44;
	float(* var_45)[650][650] = ((struct __insieme_expr_0*)args)->var_45;
	float(* var_46)[650][650] = ((struct __insieme_expr_0*)args)->var_46;
	// ------------------ Processing Guards -----------------
	// ------------------ Default processing -----------------
	call__insieme_funType_type_1(((struct __insieme_funType_type_1*)(&((struct __insieme_funType_type_2){&__insieme_supp_3, 0, var_43, var_44, var_45, var_46}))));
}

// start code fragment :: Prototype for external function: memcpy //
void* memcpy(void*, void*, unsigned long);

// start code fragment :: Prototype for external function: sqrt //
double sqrt(double);

// start code fragment :: Prototype for external function: printf //
int printf(char*, ...);

// start code fragment :: Definition of main //
int main(int argc, char** argv) {
	{
		long start_t = 0;
		long end_t = 0;
		double setup_time = 0.0;
		double elapsed_time = 0.0;
		((start_t) = clock());
		float u[650][650];
		float tmp[650][650];
		float f[650][650];
		float res[650][650];
		memset((u), 0, (((unsigned long)((650*650)))*sizeof(float)));
		memset((f), 0, (((unsigned long)((650*650)))*sizeof(float)));
		for(int i = 0; i < 650; i += 1) for(int j = 0; j < 650; j += 1) {
			((((f)[((unsigned int)((i)))][((unsigned int)((j)))])) = ((float)(init_func((i), (j)))));
		};
		double comm_time = ((double)(0));
		double comp_time = ((double)(0));
		double timer = ((double)(0));
		double resv = 0.0;
		double factor = pow((((double)(1))/((double)(650))), ((double)(2)));
		((end_t) = clock());
		((setup_time) = (((double)(((end_t)-(start_t))))/((double)(1000000l))));
		((start_t) = clock());
		for(int it = 0; it < 10; it += 1) {
			isbr_merge(isbr_parallel(memcpy(malloc(sizeof(struct __insieme_expr_0)),&((struct __insieme_expr_0){sizeof(struct __insieme_expr_0),1,1<<20,&fun__insieme_expr_0,&u,&factor,&tmp,&f}),sizeof(struct __insieme_expr_0))));
			memcpy((u), (tmp), (((unsigned long)((650*650)))*sizeof(float)));
			for(int i = 1; i < (650-1); i += 1) {
				for(int j = 1; j < (650-1); j += 1) {
					((((res)[((unsigned int)((i)))][((unsigned int)((j)))])) = ((((((((f)[((unsigned int)((i)))][((unsigned int)((j)))]))-(((float)(4))*(((u)[((unsigned int)((i)))][((unsigned int)((j)))]))))+(((u)[((unsigned int)(((i)-1)))][((unsigned int)((j)))])))+(((u)[((unsigned int)(((i)+1)))][((unsigned int)((j)))])))+(((u)[((unsigned int)((i)))][((unsigned int)(((j)-1)))])))+(((u)[((unsigned int)((i)))][((unsigned int)(((j)+1)))]))));
				};
			};
			double norm = ((double)(0));
			for(int i = 1; i < (650-1); i += 1) {
				for(int j = 1; j < (650-1); j += 1) {
					((norm) = ((norm)+pow(((double)((((res)[((unsigned int)((i)))][((unsigned int)((j)))])))), ((double)(2)))));
				};
			};
			((resv) = (sqrt((norm))/((double)((650-1)))));
		};
		((end_t) = clock());
		((elapsed_time) = (((double)(((end_t)-(start_t))))/((double)(1000000l))));
		printf("Job Done! - residuo: %lf\n", (resv));
	}
}

