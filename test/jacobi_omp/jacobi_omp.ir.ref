// -------------- Pretty Print Inspire --------------
// Inspire Program 
//  Entry Point: 
fun(int<4> v1, ref<array<array<char,1>,1>> v2){
        decl ref<int<8>> v3 =  var(0);
        decl ref<int<8>> v4 =  var(0);
        decl ref<real<8>> v5 =  var(0.0);
        decl ref<real<8>> v6 =  var(0.0);
        v3 := clock();
        decl ref<int<4>> v7 =  var(650);
        if(v1>1) {
            v7 := atoi(array.ref.elem.1D(v2, 1));
        } else { };
        decl ref<int<4>> v8 =  var(100);
        if(v1>2) {
            v8 := atoi(array.ref.elem.1D(v2, 1));
        } else { };
        decl ref<array<real<4>,1>> v9 =  var(undefined(type<array<real<4>,1>>));
        decl ref<array<real<4>,1>> v10 =  var(undefined(type<array<real<4>,1>>));
        decl ref<array<real<4>,1>> v11 =  var(undefined(type<array<real<4>,1>>));
        decl ref<array<real<4>,1>> v12 =  var(undefined(type<array<real<4>,1>>));
        v9 :=  new(array.create.1D(type<real<4>>, v7*v7*sizeof(type<real<4>>)/sizeof(type<real<4>>)));
        v10 :=  new(array.create.1D(type<real<4>>, v7*v7*sizeof(type<real<4>>)/sizeof(type<real<4>>)));
        v11 :=  new(array.create.1D(type<real<4>>, v7*v7*sizeof(type<real<4>>)/sizeof(type<real<4>>)));
        v12 :=  new(array.create.1D(type<real<4>>, v7*v7*sizeof(type<real<4>>)/sizeof(type<real<4>>)));
        if(!!is.null(v9)&&bind(){fun(ref<array<real<4>,1>> v13)return !is.null(v13)(v10)}&&bind(){fun(ref<array<real<4>,1>> v15)return !is.null(v15)(v11)}&&bind(){fun(ref<array<real<4>,1>> v17)return !is.null(v17)(v12)}) {
            printf(string.as.char.pointer("Error allocating arrays\n"), varlist.pack(()));
        } else { };
        memset(ref.to.anyref(v9), 0, v7*v7*sizeof(type<real<4>>));
        memset(ref.to.anyref(v11), 0, v7*v7*sizeof(type<real<4>>));
        for(decl ref<int<4>> v19 =  var(0) .. v7 : 1) 
            for(decl ref<int<4>> v20 =  var(0) .. v7 : 1) 
                array.ref.elem.1D(v11, v19*v7+v20) := fun(int<4> v21, int<4> v22){
                    return 40*sin(16*2*v21-1*v22);
                }(v19, v20)
            
        ;
        decl ref<real<8>> v24 =  var(0);
        decl ref<real<8>> v25 =  var(0);
        decl ref<real<8>> v26 =  var(0);
        decl ref<real<8>> v27 =  var(0.0);
        decl ref<real<8>> v28 =  var(pow(1/v7, 2));
        v4 := clock();
        v5 := v4-v3/1000000l;
        v3 := clock();
        for(decl ref<int<4>> v36 =  var(0) .. v8 : 1) {
            {
                for(decl ref<int<4>> v30 =  var(1) .. v7-1 : 1) {
                    for(decl ref<int<4>> v29 =  var(1) .. v7-1 : 1) {
                        array.ref.elem.1D(v10, v30*v7+v29) := 1/4*array.ref.elem.1D(v9, v30-1*v7+v29)+array.ref.elem.1D(v9, v30*v7+v29+1)+array.ref.elem.1D(v9, v30*v7+v29-1)+array.ref.elem.1D(v9, v30+1*v7+v29)-v28*array.ref.elem.1D(v11, v30*v7+v29);
                    };
                };
            };
            memcpy(ref.to.anyref(v9), ref.to.anyref(v10), v7*v7*sizeof(type<real<4>>));
            for(decl ref<int<4>> v32 =  var(1) .. v7-1 : 1) {
                for(decl ref<int<4>> v31 =  var(1) .. v7-1 : 1) 
                    array.ref.elem.1D(v12, v32*v7+v31) := array.ref.elem.1D(v11, v32*v7+v31)-4*array.ref.elem.1D(v9, v32*v7+v31)+array.ref.elem.1D(v9, v32-1*v7+v31)+array.ref.elem.1D(v9, v32+1*v7+v31)+array.ref.elem.1D(v9, v32*v7+v31-1)+array.ref.elem.1D(v9, v32*v7+v31+1)
                ;
            };
            decl ref<real<8>> v33 =  var(0);
            for(decl ref<int<4>> v35 =  var(1) .. v7-1 : 1) {
                for(decl ref<int<4>> v34 =  var(1) .. v7-1 : 1) {
                    v33 := v33+pow(array.ref.elem.1D(v12, v35*v7+v34), 2);
                };
            };
            v27 := sqrt(v33)/v7-1;
        };
        v4 := clock();
        v6 := v4-v3/1000000l;
         del(v9);
         del(v10);
         del(v11);
         del(v12);
        printf(string.as.char.pointer("Job Done! - residuo: %lf\n"), varlist.pack((v27)));
    }




// --------- Pretty Print Inspire - Detail ----------
// Inspire Program 
//  Entry Point: 
fun(int<4> v1, ref<array<array<char,1>,1>> v2){
        decl ref<int<8>> v3 = ( var(0));
        decl ref<int<8>> v4 = ( var(0));
        decl ref<real<8>> v5 = ( var(0.0));
        decl ref<real<8>> v6 = ( var(0.0));
        (v3 := clock());
        decl ref<int<4>> v7 = ( var(650));
        if((v1>1)) {
            (v7 := atoi(array.ref.elem.1D(v2, CAST<uint<4>>(1))));
        } else { };
        decl ref<int<4>> v8 = ( var(100));
        if((v1>2)) {
            (v8 := atoi(array.ref.elem.1D(v2, CAST<uint<4>>(1))));
        } else { };
        decl ref<array<real<4>,1>> v9 = ( var(undefined(type<array<real<4>,1>>)));
        decl ref<array<real<4>,1>> v10 = ( var(undefined(type<array<real<4>,1>>)));
        decl ref<array<real<4>,1>> v11 = ( var(undefined(type<array<real<4>,1>>)));
        decl ref<array<real<4>,1>> v12 = ( var(undefined(type<array<real<4>,1>>)));
        (v9 := ( *( new(array.create.1D(type<real<4>>, ((CAST<uint<8>>((( *v7)*( *v7)))*sizeof(type<real<4>>))/sizeof(type<real<4>>)))))));
        (v10 := ( *( new(array.create.1D(type<real<4>>, ((CAST<uint<8>>((( *v7)*( *v7)))*sizeof(type<real<4>>))/sizeof(type<real<4>>)))))));
        (v11 := ( *( new(array.create.1D(type<real<4>>, ((CAST<uint<8>>((( *v7)*( *v7)))*sizeof(type<real<4>>))/sizeof(type<real<4>>)))))));
        (v12 := ( *( new(array.create.1D(type<real<4>>, ((CAST<uint<8>>((( *v7)*( *v7)))*sizeof(type<real<4>>))/sizeof(type<real<4>>)))))));
        if((!((((!is.null(( *v9)))&&bind(){fun(ref<array<real<4>,1>> v13)return (!is.null(( *v13)))(v10)})&&bind(){fun(ref<array<real<4>,1>> v15)return (!is.null(( *v15)))(v11)})&&bind(){fun(ref<array<real<4>,1>> v17)return (!is.null(( *v17)))(v12)}))) {
            printf(string.as.char.pointer("Error allocating arrays\n"), varlist.pack(()));
        } else { };
        memset(ref.to.anyref(v9), 0, (CAST<uint<8>>((( *v7)*( *v7)))*sizeof(type<real<4>>)));
        memset(ref.to.anyref(v11), 0, (CAST<uint<8>>((( *v7)*( *v7)))*sizeof(type<real<4>>)));
        for(decl ref<int<4>> v19 = ( var(0)) .. ( *v7) : 1) 
            for(decl ref<int<4>> v20 = ( var(0)) .. ( *v7) : 1) 
                (array.ref.elem.1D(v11, CAST<uint<4>>(((( *v19)*( *v7))+( *v20)))) := CAST<real<4>>(fun(int<4> v21, int<4> v22){
                    return (CAST<real<8>>(40)*sin(CAST<real<8>>(((16*((2*v21)-1))*v22))));
                }(( *v19), ( *v20))))
            
        ;
        decl ref<real<8>> v24 = ( var(CAST<real<8>>(0)));
        decl ref<real<8>> v25 = ( var(CAST<real<8>>(0)));
        decl ref<real<8>> v26 = ( var(CAST<real<8>>(0)));
        decl ref<real<8>> v27 = ( var(0.0));
        decl ref<real<8>> v28 = ( var(pow((CAST<real<8>>(1)/CAST<real<8>>(( *v7))), CAST<real<8>>(2))));
        (v4 := clock());
        (v5 := (CAST<real<8>>((( *v4)-( *v3)))/CAST<real<8>>(1000000l)));
        (v3 := clock());
        for(decl ref<int<4>> v36 = ( var(0)) .. ( *v8) : 1) {
            <m id=2>{
                <m id=1>for(decl ref<int<4>> v30 = ( var(1)) .. (( *v7)-1) : 1) {
                    for(decl ref<int<4>> v29 = ( var(1)) .. (( *v7)-1) : 1) {
                        (array.ref.elem.1D(v10, CAST<uint<4>>(((( *v30)*( *v7))+( *v29)))) := CAST<real<4>>(((CAST<real<8>>(1)/CAST<real<8>>(4))*(CAST<real<8>>((((( *array.ref.elem.1D(v9, CAST<uint<4>>((((( *v30)-1)*( *v7))+( *v29)))))+( *array.ref.elem.1D(v9, CAST<uint<4>>((((( *v30)*( *v7))+( *v29))+1)))))+( *array.ref.elem.1D(v9, CAST<uint<4>>((((( *v30)*( *v7))+( *v29))-1)))))+( *array.ref.elem.1D(v9, CAST<uint<4>>((((( *v30)+1)*( *v7))+( *v29)))))))-(( *v28)*CAST<real<8>>(( *array.ref.elem.1D(v11, CAST<uint<4>>(((( *v30)*( *v7))+( *v29)))))))))));
                    };
                }</m>;
            }</m>;
            memcpy(ref.to.anyref(v9), ref.to.anyref(v10), (CAST<uint<8>>((( *v7)*( *v7)))*sizeof(type<real<4>>)));
            for(decl ref<int<4>> v32 = ( var(1)) .. (( *v7)-1) : 1) {
                for(decl ref<int<4>> v31 = ( var(1)) .. (( *v7)-1) : 1) 
                    (array.ref.elem.1D(v12, CAST<uint<4>>(((( *v32)*( *v7))+( *v31)))) := (((((( *array.ref.elem.1D(v11, CAST<uint<4>>(((( *v32)*( *v7))+( *v31)))))-(CAST<real<4>>(4)*( *array.ref.elem.1D(v9, CAST<uint<4>>(((( *v32)*( *v7))+( *v31)))))))+( *array.ref.elem.1D(v9, CAST<uint<4>>((((( *v32)-1)*( *v7))+( *v31))))))+( *array.ref.elem.1D(v9, CAST<uint<4>>((((( *v32)+1)*( *v7))+( *v31))))))+( *array.ref.elem.1D(v9, CAST<uint<4>>((((( *v32)*( *v7))+( *v31))-1)))))+( *array.ref.elem.1D(v9, CAST<uint<4>>((((( *v32)*( *v7))+( *v31))+1))))))
                ;
            };
            decl ref<real<8>> v33 = ( var(CAST<real<8>>(0)));
            for(decl ref<int<4>> v35 = ( var(1)) .. (( *v7)-1) : 1) {
                for(decl ref<int<4>> v34 = ( var(1)) .. (( *v7)-1) : 1) {
                    (v33 := (( *v33)+pow(CAST<real<8>>(( *array.ref.elem.1D(v12, CAST<uint<4>>(((( *v35)*( *v7))+( *v34)))))), CAST<real<8>>(2))));
                };
            };
            (v27 := (sqrt(( *v33))/CAST<real<8>>((( *v7)-1))));
        };
        (v4 := clock());
        (v6 := (CAST<real<8>>((( *v4)-( *v3)))/CAST<real<8>>(1000000l)));
        ( del(v9));
        ( del(v10));
        ( del(v11));
        ( del(v12));
        printf(string.as.char.pointer("Job Done! - residuo: %lf\n"), varlist.pack((( *v27))));
    }

