// -------------- Pretty Print Inspire --------------
// Inspire Program 
//  Entry Point: 
fun(int<4> v1, array<ref<array<ref<char>,1>>,1> v2){
        decl ref<int<8>> v3 =  var(0);
        decl ref<int<8>> v4 =  var(0);
        decl ref<real<8>> v5 =  var(0.0);
        decl ref<real<8>> v6 =  var(0.0);
        v3 := clock();
        decl ref<int<4>> v7 =  var(650);
        if(v1>1) {
            v7 := atoi(v2[1]);
        } else { };
        decl ref<int<4>> v8 =  var(100);
        if(v1>2) {
            v8 := atoi(v2[1]);
        } else { };
        decl ref<array<ref<real<4>>,1>> v9 =  var(undefined(array<ref<real<4>>,1>));
        decl ref<array<ref<real<4>>,1>> v10 =  var(undefined(array<ref<real<4>>,1>));
        decl ref<array<ref<real<4>>,1>> v11 =  var(undefined(array<ref<real<4>>,1>));
        decl ref<array<ref<real<4>>,1>> v12 =  var(undefined(array<ref<real<4>>,1>));
        v9 := array.create.1D( var(undefined(real<4>)), v7*v7*sizeof(real<4>)/sizeof(real<4>));
        v10 := array.create.1D( var(undefined(real<4>)), v7*v7*sizeof(real<4>)/sizeof(real<4>));
        v11 := array.create.1D( var(undefined(real<4>)), v7*v7*sizeof(real<4>)/sizeof(real<4>));
        v12 := array.create.1D( var(undefined(real<4>)), v7*v7*sizeof(real<4>)/sizeof(real<4>));
        if(!v9&&[v10]fun[ref<array<ref<real<4>>,1>> v38]()return v38&&[v11]fun[ref<array<ref<real<4>>,1>> v40]()return v40&&[v12]fun[ref<array<ref<real<4>>,1>> v42]()return v42) {
            printf("Error allocating arrays\n", varlist.pack(()));
        } else { };
        memset(v9, 0, v7*v7*sizeof(real<4>));
        memset(v11, 0, v7*v7*sizeof(real<4>));
        for(decl ref<int<4>> v19 =  var(0) .. v7 : 1) 
            for(decl ref<int<4>> v20 =  var(0) .. v7 : 1) 
                v11[v19*v7+v20] := fun(int<4> v21, int<4> v22){
                    return 40*sin(16*2*v21-1*v22);
                }(v19, v20)
            
        ;
        decl ref<real<8>> v24 =  var(0);
        decl ref<real<8>> v25 =  var(0);
        decl ref<real<8>> v26 =  var(0);
        decl ref<real<8>> v27 =  var(0.0);
        decl ref<real<8>> v28 =  var(pow(1/v7, 2));
        v4 := clock();
        v5 := v4-v3/1000000l;
        v3 := clock();
        for(decl ref<int<4>> v36 =  var(0) .. v8 : 1) {
            merge(parallel(job([1-inf]){
                default: [v7, v9, v10, v11, v28]fun[ref<int<4>> v49, ref<array<ref<real<4>>,1>> v48, ref<array<ref<real<4>>,1>> v47, ref<array<ref<real<4>>,1>> v46, ref<real<8>> v45](){
                    {
                        pfor(getThreadGroup(0), 1, v49-1, 1, [v46, v47, v45, v48, v49]fun[ref<array<ref<real<4>>,1>> v56, ref<array<ref<real<4>>,1>> v55, ref<real<8>> v57, ref<array<ref<real<4>>,1>> v54, ref<int<4>> v53](int<4> v52){
                            for(decl ref<int<4>> v29 =  var(1) .. v53-1 : 1) {
                                v55[v52*v53+v29] := 1/4*v54[v52-1*v53+v29]+v54[v52*v53+v29+1]+v54[v52*v53+v29-1]+v54[v52+1*v53+v29]-v57*v56[v52*v53+v29];
                            };
                        });
                        barrier(getThreadGroup(0));
                    };
                }
            }));
            memcpy(v9, v10, v7*v7*sizeof(real<4>));
            for(decl ref<int<4>> v32 =  var(1) .. v7-1 : 1) {
                for(decl ref<int<4>> v31 =  var(1) .. v7-1 : 1) 
                    v12[v32*v7+v31] := v11[v32*v7+v31]-4*v9[v32*v7+v31]+v9[v32-1*v7+v31]+v9[v32+1*v7+v31]+v9[v32*v7+v31-1]+v9[v32*v7+v31+1]
                ;
            };
            decl ref<real<8>> v33 =  var(0);
            for(decl ref<int<4>> v35 =  var(1) .. v7-1 : 1) {
                for(decl ref<int<4>> v34 =  var(1) .. v7-1 : 1) {
                    v33 := v33+pow(v12[v35*v7+v34], 2);
                };
            };
            v27 := sqrt(v33)/v7-1;
        };
        v4 := clock();
        v6 := v4-v3/1000000l;
         del(v9);
         del(v10);
         del(v11);
         del(v12);
        printf("Job Done! - residuo: %lf\n", varlist.pack((v27)));
    }




// --------- Pretty Print Inspire - Detail ----------
// Inspire Program 
//  Entry Point: 
fun(int<4> v1, array<ref<array<ref<char>,1>>,1> v2){
        decl ref<int<8>> v3 = ( var(0));
        decl ref<int<8>> v4 = ( var(0));
        decl ref<real<8>> v5 = ( var(0.0));
        decl ref<real<8>> v6 = ( var(0.0));
        (v3 := clock());
        decl ref<int<4>> v7 = ( var(650));
        if((v1>1)) {
            (v7 := atoi(( *(v2[CAST<uint<4>>(1)]))));
        } else { };
        decl ref<int<4>> v8 = ( var(100));
        if((v1>2)) {
            (v8 := atoi(( *(v2[CAST<uint<4>>(1)]))));
        } else { };
        decl ref<array<ref<real<4>>,1>> v9 = ( var(undefined(array<ref<real<4>>,1>)));
        decl ref<array<ref<real<4>>,1>> v10 = ( var(undefined(array<ref<real<4>>,1>)));
        decl ref<array<ref<real<4>>,1>> v11 = ( var(undefined(array<ref<real<4>>,1>)));
        decl ref<array<ref<real<4>>,1>> v12 = ( var(undefined(array<ref<real<4>>,1>)));
        (v9 := array.create.1D(( var(undefined(real<4>))), ((CAST<uint<8>>((( *v7)*( *v7)))*sizeof(real<4>))/sizeof(real<4>))));
        (v10 := array.create.1D(( var(undefined(real<4>))), ((CAST<uint<8>>((( *v7)*( *v7)))*sizeof(real<4>))/sizeof(real<4>))));
        (v11 := array.create.1D(( var(undefined(real<4>))), ((CAST<uint<8>>((( *v7)*( *v7)))*sizeof(real<4>))/sizeof(real<4>))));
        (v12 := array.create.1D(( var(undefined(real<4>))), ((CAST<uint<8>>((( *v7)*( *v7)))*sizeof(real<4>))/sizeof(real<4>))));
        if((!(((CAST<bool>(v9)&&[v10]fun[ref<array<ref<real<4>>,1>> v38]()return CAST<bool>(( *v38)))&&[v11]fun[ref<array<ref<real<4>>,1>> v40]()return CAST<bool>(( *v40)))&&[v12]fun[ref<array<ref<real<4>>,1>> v42]()return CAST<bool>(( *v42))))) {
            printf("Error allocating arrays\n", varlist.pack(()));
        } else { };
        memset(( *v9), 0, (CAST<uint<8>>((( *v7)*( *v7)))*sizeof(real<4>)));
        memset(( *v11), 0, (CAST<uint<8>>((( *v7)*( *v7)))*sizeof(real<4>)));
        for(decl ref<int<4>> v19 = ( var(0)) .. ( *v7) : 1) 
            for(decl ref<int<4>> v20 = ( var(0)) .. ( *v7) : 1) 
                ((( *v11)[CAST<uint<4>>(((( *v19)*( *v7))+( *v20)))]) := CAST<real<4>>(fun(int<4> v21, int<4> v22){
                    return (CAST<real<8>>(40)*sin(CAST<real<8>>(((16*((2*v21)-1))*v22))));
                }(( *v19), ( *v20))))
            
        ;
        decl ref<real<8>> v24 = ( var(CAST<real<8>>(0)));
        decl ref<real<8>> v25 = ( var(CAST<real<8>>(0)));
        decl ref<real<8>> v26 = ( var(CAST<real<8>>(0)));
        decl ref<real<8>> v27 = ( var(0.0));
        decl ref<real<8>> v28 = ( var(pow((CAST<real<8>>(1)/CAST<real<8>>(( *v7))), CAST<real<8>>(2))));
        (v4 := clock());
        (v5 := (CAST<real<8>>((( *v4)-( *v3)))/CAST<real<8>>(1000000l)));
        (v3 := clock());
        for(decl ref<int<4>> v36 = ( var(0)) .. ( *v8) : 1) {
            merge(parallel(job(([1-inf])){
                default: [v7, v9, v10, v11, v28]fun[ref<int<4>> v49, ref<array<ref<real<4>>,1>> v48, ref<array<ref<real<4>>,1>> v47, ref<array<ref<real<4>>,1>> v46, ref<real<8>> v45](){
                    {
                        pfor(getThreadGroup(0), 1, (( *v49)-1), 1, [v46, v47, v45, v48, v49]fun[ref<array<ref<real<4>>,1>> v56, ref<array<ref<real<4>>,1>> v55, ref<real<8>> v57, ref<array<ref<real<4>>,1>> v54, ref<int<4>> v53](int<4> v52){
                            for(decl ref<int<4>> v29 = ( var(1)) .. (( *v53)-1) : 1) {
                                ((( *v55)[CAST<uint<4>>(((v52*( *v53))+( *v29)))]) := CAST<real<4>>(((CAST<real<8>>(1)/CAST<real<8>>(4))*(CAST<real<8>>((((( *(( *v54)[CAST<uint<4>>((((v52-1)*( *v53))+( *v29)))]))+( *(( *v54)[CAST<uint<4>>((((v52*( *v53))+( *v29))+1))])))+( *(( *v54)[CAST<uint<4>>((((v52*( *v53))+( *v29))-1))])))+( *(( *v54)[CAST<uint<4>>((((v52+1)*( *v53))+( *v29)))]))))-(( *v57)*CAST<real<8>>(( *(( *v56)[CAST<uint<4>>(((v52*( *v53))+( *v29)))]))))))));
                            };
                        });
                        barrier(getThreadGroup(0));
                    };
                }
            }));
            memcpy(( *v9), ( *v10), (CAST<uint<8>>((( *v7)*( *v7)))*sizeof(real<4>)));
            for(decl ref<int<4>> v32 = ( var(1)) .. (( *v7)-1) : 1) {
                for(decl ref<int<4>> v31 = ( var(1)) .. (( *v7)-1) : 1) 
                    ((( *v12)[CAST<uint<4>>(((( *v32)*( *v7))+( *v31)))]) := (((((( *(( *v11)[CAST<uint<4>>(((( *v32)*( *v7))+( *v31)))]))-(CAST<real<4>>(4)*( *(( *v9)[CAST<uint<4>>(((( *v32)*( *v7))+( *v31)))]))))+( *(( *v9)[CAST<uint<4>>((((( *v32)-1)*( *v7))+( *v31)))])))+( *(( *v9)[CAST<uint<4>>((((( *v32)+1)*( *v7))+( *v31)))])))+( *(( *v9)[CAST<uint<4>>((((( *v32)*( *v7))+( *v31))-1))])))+( *(( *v9)[CAST<uint<4>>((((( *v32)*( *v7))+( *v31))+1))]))))
                ;
            };
            decl ref<real<8>> v33 = ( var(CAST<real<8>>(0)));
            for(decl ref<int<4>> v35 = ( var(1)) .. (( *v7)-1) : 1) {
                for(decl ref<int<4>> v34 = ( var(1)) .. (( *v7)-1) : 1) {
                    (v33 := (( *v33)+pow(CAST<real<8>>(( *(( *v12)[CAST<uint<4>>(((( *v35)*( *v7))+( *v34)))]))), CAST<real<8>>(2))));
                };
            };
            (v27 := (sqrt(( *v33))/CAST<real<8>>((( *v7)-1))));
        };
        (v4 := clock());
        (v6 := (CAST<real<8>>((( *v4)-( *v3)))/CAST<real<8>>(1000000l)));
        ( del(v9));
        ( del(v10));
        ( del(v11));
        ( del(v12));
        printf("Job Done! - residuo: %lf\n", varlist.pack((( *v27))));
    }

