// -------------- Pretty Print Inspire --------------
// Inspire Program 
//  Entry Point: 
fun(int<4> v1, ref<array<array<char,1>,1>> v2){
        decl ref<int<8>> v3 =  var(0);
        decl ref<int<8>> v4 =  var(0);
        decl ref<real<8>> v5 =  var(0.0);
        decl ref<real<8>> v6 =  var(0.0);
        v3 := clock();
        decl ref<int<4>> v7 =  var(650);
        if(v1>1) {
            v7 := atoi(array.ref.elem.1D(v2, 1));
        } else { };
        decl ref<int<4>> v8 =  var(100);
        if(v1>2) {
            v8 := atoi(array.ref.elem.1D(v2, 1));
        } else { };
        decl ref<array<real<4>,1>> v9 =  var(undefined(array<real<4>,1>));
        decl ref<array<real<4>,1>> v10 =  var(undefined(array<real<4>,1>));
        decl ref<array<real<4>,1>> v11 =  var(undefined(array<real<4>,1>));
        decl ref<array<real<4>,1>> v12 =  var(undefined(array<real<4>,1>));
        v9 :=  new(array.create.1D(undefined(real<4>), v7*v7*sizeof(real<4>)/sizeof(real<4>)));
        v10 :=  new(array.create.1D(undefined(real<4>), v7*v7*sizeof(real<4>)/sizeof(real<4>)));
        v11 :=  new(array.create.1D(undefined(real<4>), v7*v7*sizeof(real<4>)/sizeof(real<4>)));
        v12 :=  new(array.create.1D(undefined(real<4>), v7*v7*sizeof(real<4>)/sizeof(real<4>)));
        if(!v9&&[v10]fun[ref<array<real<4>,1>> v13]()return v13&&[v11]fun[ref<array<real<4>,1>> v15]()return v15&&[v12]fun[ref<array<real<4>,1>> v17]()return v17) {
            printf(string.as.char.pointer("Error allocating arrays\n"), varlist.pack(()));
        } else { };
        memset(v9, 0, v7*v7*sizeof(real<4>));
        memset(v11, 0, v7*v7*sizeof(real<4>));
        for(decl ref<int<4>> v19 =  var(0) .. v7 : 1) 
            for(decl ref<int<4>> v20 =  var(0) .. v7 : 1) 
                array.ref.elem.1D(v11, v19*v7+v20) := fun(int<4> v21, int<4> v22){
                    return 40*sin(16*2*v21-1*v22);
                }(v19, v20)
            
        ;
        decl ref<real<8>> v24 =  var(0);
        decl ref<real<8>> v25 =  var(0);
        decl ref<real<8>> v26 =  var(0);
        decl ref<real<8>> v27 =  var(0.0);
        decl ref<real<8>> v28 =  var(pow(1/v7, 2));
        v4 := clock();
        v5 := v4-v3/1000000l;
        v3 := clock();
        for(decl ref<int<4>> v36 =  var(0) .. v8 : 1) {
            merge(parallel(job([1-inf]){
                default: [v7, v11, v10, v28, v9]fun[ref<int<4>> v42, ref<array<real<4>,1>> v39, ref<array<real<4>,1>> v40, ref<real<8>> v38, ref<array<real<4>,1>> v41](){
                    {
                        pfor(getThreadGroup(0), 1, v42-1, 1, [v39, v38, v40, v42, v41]fun[ref<array<real<4>,1>> v49, ref<real<8>> v50, ref<array<real<4>,1>> v48, ref<int<4>> v46, ref<array<real<4>,1>> v47](int<4> v45){
                            for(decl ref<int<4>> v29 =  var(1) .. v46-1 : 1) {
                                array.ref.elem.1D(v48, v45*v46+v29) := 1/4*array.ref.elem.1D(v47, v45-1*v46+v29)+array.ref.elem.1D(v47, v45*v46+v29+1)+array.ref.elem.1D(v47, v45*v46+v29-1)+array.ref.elem.1D(v47, v45+1*v46+v29)-v50*array.ref.elem.1D(v49, v45*v46+v29);
                            };
                        });
                        barrier(getThreadGroup(0));
                    };
                }
            }));
            memcpy(v9, v10, v7*v7*sizeof(real<4>));
            for(decl ref<int<4>> v32 =  var(1) .. v7-1 : 1) {
                for(decl ref<int<4>> v31 =  var(1) .. v7-1 : 1) 
                    array.ref.elem.1D(v12, v32*v7+v31) := array.ref.elem.1D(v11, v32*v7+v31)-4*array.ref.elem.1D(v9, v32*v7+v31)+array.ref.elem.1D(v9, v32-1*v7+v31)+array.ref.elem.1D(v9, v32+1*v7+v31)+array.ref.elem.1D(v9, v32*v7+v31-1)+array.ref.elem.1D(v9, v32*v7+v31+1)
                ;
            };
            decl ref<real<8>> v33 =  var(0);
            for(decl ref<int<4>> v35 =  var(1) .. v7-1 : 1) {
                for(decl ref<int<4>> v34 =  var(1) .. v7-1 : 1) {
                    v33 := v33+pow(array.ref.elem.1D(v12, v35*v7+v34), 2);
                };
            };
            v27 := sqrt(v33)/v7-1;
        };
        v4 := clock();
        v6 := v4-v3/1000000l;
         del(v9);
         del(v10);
         del(v11);
         del(v12);
        printf(string.as.char.pointer("Job Done! - residuo: %lf\n"), varlist.pack((v27)));
    }




// --------- Pretty Print Inspire - Detail ----------
// Inspire Program 
//  Entry Point: 
fun(int<4> v1, ref<array<array<char,1>,1>> v2){
        decl ref<int<8>> v3 = ( var(0));
        decl ref<int<8>> v4 = ( var(0));
        decl ref<real<8>> v5 = ( var(0.0));
        decl ref<real<8>> v6 = ( var(0.0));
        (v3 := clock());
        decl ref<int<4>> v7 = ( var(650));
        if((v1>1)) {
            (v7 := atoi(( *array.ref.elem.1D(v2, CAST<uint<4>>(1)))));
        } else { };
        decl ref<int<4>> v8 = ( var(100));
        if((v1>2)) {
            (v8 := atoi(( *array.ref.elem.1D(v2, CAST<uint<4>>(1)))));
        } else { };
        decl ref<array<real<4>,1>> v9 = ( var(undefined(array<real<4>,1>)));
        decl ref<array<real<4>,1>> v10 = ( var(undefined(array<real<4>,1>)));
        decl ref<array<real<4>,1>> v11 = ( var(undefined(array<real<4>,1>)));
        decl ref<array<real<4>,1>> v12 = ( var(undefined(array<real<4>,1>)));
        (v9 := ( *( new(array.create.1D(undefined(real<4>), ((CAST<uint<8>>((( *v7)*( *v7)))*sizeof(real<4>))/sizeof(real<4>)))))));
        (v10 := ( *( new(array.create.1D(undefined(real<4>), ((CAST<uint<8>>((( *v7)*( *v7)))*sizeof(real<4>))/sizeof(real<4>)))))));
        (v11 := ( *( new(array.create.1D(undefined(real<4>), ((CAST<uint<8>>((( *v7)*( *v7)))*sizeof(real<4>))/sizeof(real<4>)))))));
        (v12 := ( *( new(array.create.1D(undefined(real<4>), ((CAST<uint<8>>((( *v7)*( *v7)))*sizeof(real<4>))/sizeof(real<4>)))))));
        if((!(((CAST<bool>(v9)&&[v10]fun[ref<array<real<4>,1>> v13]()return CAST<bool>(( *v13)))&&[v11]fun[ref<array<real<4>,1>> v15]()return CAST<bool>(( *v15)))&&[v12]fun[ref<array<real<4>,1>> v17]()return CAST<bool>(( *v17))))) {
            printf(string.as.char.pointer("Error allocating arrays\n"), varlist.pack(()));
        } else { };
        memset(v9, 0, (CAST<uint<8>>((( *v7)*( *v7)))*sizeof(real<4>)));
        memset(v11, 0, (CAST<uint<8>>((( *v7)*( *v7)))*sizeof(real<4>)));
        for(decl ref<int<4>> v19 = ( var(0)) .. ( *v7) : 1) 
            for(decl ref<int<4>> v20 = ( var(0)) .. ( *v7) : 1) 
                (array.ref.elem.1D(v11, CAST<uint<4>>(((( *v19)*( *v7))+( *v20)))) := CAST<real<4>>(fun(int<4> v21, int<4> v22){
                    return (CAST<real<8>>(40)*sin(CAST<real<8>>(((16*((2*v21)-1))*v22))));
                }(( *v19), ( *v20))))
            
        ;
        decl ref<real<8>> v24 = ( var(CAST<real<8>>(0)));
        decl ref<real<8>> v25 = ( var(CAST<real<8>>(0)));
        decl ref<real<8>> v26 = ( var(CAST<real<8>>(0)));
        decl ref<real<8>> v27 = ( var(0.0));
        decl ref<real<8>> v28 = ( var(pow((CAST<real<8>>(1)/CAST<real<8>>(( *v7))), CAST<real<8>>(2))));
        (v4 := clock());
        (v5 := (CAST<real<8>>((( *v4)-( *v3)))/CAST<real<8>>(1000000l)));
        (v3 := clock());
        for(decl ref<int<4>> v36 = ( var(0)) .. ( *v8) : 1) {
            merge(parallel(job(([1-inf])){
                default: [v7, v11, v10, v28, v9]fun[ref<int<4>> v42, ref<array<real<4>,1>> v39, ref<array<real<4>,1>> v40, ref<real<8>> v38, ref<array<real<4>,1>> v41](){
                    {
                        pfor(getThreadGroup(0), 1, (( *v42)-1), 1, [v39, v38, v40, v42, v41]fun[ref<array<real<4>,1>> v49, ref<real<8>> v50, ref<array<real<4>,1>> v48, ref<int<4>> v46, ref<array<real<4>,1>> v47](int<4> v45){
                            for(decl ref<int<4>> v29 = ( var(1)) .. (( *v46)-1) : 1) {
                                (array.ref.elem.1D(v48, CAST<uint<4>>(((v45*( *v46))+( *v29)))) := CAST<real<4>>(((CAST<real<8>>(1)/CAST<real<8>>(4))*(CAST<real<8>>((((( *array.ref.elem.1D(v47, CAST<uint<4>>((((v45-1)*( *v46))+( *v29)))))+( *array.ref.elem.1D(v47, CAST<uint<4>>((((v45*( *v46))+( *v29))+1)))))+( *array.ref.elem.1D(v47, CAST<uint<4>>((((v45*( *v46))+( *v29))-1)))))+( *array.ref.elem.1D(v47, CAST<uint<4>>((((v45+1)*( *v46))+( *v29)))))))-(( *v50)*CAST<real<8>>(( *array.ref.elem.1D(v49, CAST<uint<4>>(((v45*( *v46))+( *v29)))))))))));
                            };
                        });
                        barrier(getThreadGroup(0));
                    };
                }
            }));
            memcpy(v9, v10, (CAST<uint<8>>((( *v7)*( *v7)))*sizeof(real<4>)));
            for(decl ref<int<4>> v32 = ( var(1)) .. (( *v7)-1) : 1) {
                for(decl ref<int<4>> v31 = ( var(1)) .. (( *v7)-1) : 1) 
                    (array.ref.elem.1D(v12, CAST<uint<4>>(((( *v32)*( *v7))+( *v31)))) := (((((( *array.ref.elem.1D(v11, CAST<uint<4>>(((( *v32)*( *v7))+( *v31)))))-(CAST<real<4>>(4)*( *array.ref.elem.1D(v9, CAST<uint<4>>(((( *v32)*( *v7))+( *v31)))))))+( *array.ref.elem.1D(v9, CAST<uint<4>>((((( *v32)-1)*( *v7))+( *v31))))))+( *array.ref.elem.1D(v9, CAST<uint<4>>((((( *v32)+1)*( *v7))+( *v31))))))+( *array.ref.elem.1D(v9, CAST<uint<4>>((((( *v32)*( *v7))+( *v31))-1)))))+( *array.ref.elem.1D(v9, CAST<uint<4>>((((( *v32)*( *v7))+( *v31))+1))))))
                ;
            };
            decl ref<real<8>> v33 = ( var(CAST<real<8>>(0)));
            for(decl ref<int<4>> v35 = ( var(1)) .. (( *v7)-1) : 1) {
                for(decl ref<int<4>> v34 = ( var(1)) .. (( *v7)-1) : 1) {
                    (v33 := (( *v33)+pow(CAST<real<8>>(( *array.ref.elem.1D(v12, CAST<uint<4>>(((( *v35)*( *v7))+( *v34)))))), CAST<real<8>>(2))));
                };
            };
            (v27 := (sqrt(( *v33))/CAST<real<8>>((( *v7)-1))));
        };
        (v4 := clock());
        (v6 := (CAST<real<8>>((( *v4)-( *v3)))/CAST<real<8>>(1000000l)));
        ( del(v9));
        ( del(v10));
        ( del(v11));
        ( del(v12));
        printf(string.as.char.pointer("Job Done! - residuo: %lf\n"), varlist.pack((( *v27))));
    }

