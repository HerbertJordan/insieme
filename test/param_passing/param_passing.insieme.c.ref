// --- Generated Inspire Code ---
#include <alloca.h>
#include <stddef.h>
#include <stdlib.h>
#include <runtime.h>
#define bool int
#define true 1
#define false 0
#define null 0

// start code fragment :: array type definition of __insieme_type_1 <=> array<char,1> //
typedef struct ___insieme_type_1 { 
    char* data;
} __insieme_type_1;

// start code fragment :: array type definition of __insieme_type_0 <=> array<array<char,1>,1> //
typedef struct ___insieme_type_0 { 
    __insieme_type_1* data;
} __insieme_type_0;

// start code fragment :: type_declaration___insieme_globals //
struct __insieme_globals { 
    int i;
};

// start code fragment :: global data //
struct __insieme_globals __GLOBAL__;

// start code fragment :: type_declaration_data //
struct data { 
    int x;
    int y;
};

// start code fragment :: Definition of f1 ... type: ((int<4>)->int<4>) //
int f1(int x) { return x; }
static int f1_wrap(void* _closure, int x) { return f1(x); }

// start code fragment :: array type definition of __insieme_type_4 <=> array<int<4>,1> //
typedef struct ___insieme_type_4 { 
    int* data;
} __insieme_type_4;

// start code fragment :: Definition of f2 ... type: ((ref<array<int<4>,1>>)->int<4>) //
int f2(__insieme_type_4* x) { return (((*x).data[0])); }
static int f2_wrap(void* _closure, __insieme_type_4* x) { return f2(x); }

// start code fragment :: Definition of __insieme_supp_6 ... type: ((ref<array<int<4>,1>>)->int<4>) //
int __insieme_supp_6(__insieme_type_4* x) { return ((*(&((__GLOBAL__).i)))++); }
static int __insieme_supp_6_wrap(void* _closure, __insieme_type_4* x) { return __insieme_supp_6(x); }

// start code fragment :: Definition of f4 ... type: ((struct<x:int<4>,y:int<4>>)->int<4>) //
int f4(struct data data) { return (data.x); }
static int f4_wrap(void* _closure, struct data data) { return f4(data); }

// start code fragment :: array type definition of __insieme_type_7 <=> array<struct<x:int<4>,y:int<4>>,1> //
typedef struct ___insieme_type_7 { 
    struct data* data;
} __insieme_type_7;

// start code fragment :: Definition of f5 ... type: ((ref<array<struct<x:int<4>,y:int<4>>,1>>)->int<4>) //
int f5(__insieme_type_7* data) { return (*(&((((*data).data[0])).x))); }
static int f5_wrap(void* _closure, __insieme_type_7* data) { return f5(data); }

// start code fragment :: main function //
int main(int __argc, char** __argv) {
	
	// encapsulating arguments within Insieme Types ...
	int argc = __argc;
	__insieme_type_0 argv = (__insieme_type_0){alloca(sizeof(__insieme_type_1) * argc)};
	for(int i=0; i<argc; ++i) {
		argv.data[i] = (__insieme_type_1){__argv[i]};
	}
	
	// ---- begin of actual code body ----
	{
		;
		((*(&((__GLOBAL__).i))) = 0);
		int a = 10;
		struct data data = ((struct data){1,
			1
		});
		f1((a));
		f2((&((__insieme_type_4){&a})));
		__insieme_supp_6((&((__insieme_type_4){&a})));
		f4((data));
		f5((&((__insieme_type_7){&data})));
		return (a);
	}
	// ----  end of actual code body  ----
	
}

