// --- Generated Inspire Code ---
#include <alloca.h>
#include <stddef.h>
#include <runtime.h>
#define bool int
#define true 1
#define false 0
#define null 0

// start code fragment :: vector_type_declaration of __insieme_type_1 <=> vector<real<8>,2001000> //
typedef struct ___insieme_type_1 { 
    double data[2001000];
} __insieme_type_1;

// A constructor initializing a vector of the type __insieme_type_1 uniformly
static inline __insieme_type_1 __insieme_type_1_init_uniform(double value) {
	__insieme_type_1 res;
	for (int i=0; i<2001000;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_2 <=> vector<real<8>,6003> //
typedef struct ___insieme_type_2 { 
    double data[6003];
} __insieme_type_2;

// A constructor initializing a vector of the type __insieme_type_2 uniformly
static inline __insieme_type_2 __insieme_type_2_init_uniform(double value) {
	__insieme_type_2 res;
	for (int i=0; i<6003;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_3 <=> vector<int<4>,6003> //
typedef struct ___insieme_type_3 { 
    int data[6003];
} __insieme_type_3;

// A constructor initializing a vector of the type __insieme_type_3 uniformly
static inline __insieme_type_3 __insieme_type_3_init_uniform(int value) {
	__insieme_type_3 res;
	for (int i=0; i<6003;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_4 <=> vector<real<8>,2001> //
typedef struct ___insieme_type_4 { 
    double data[2001];
} __insieme_type_4;

// A constructor initializing a vector of the type __insieme_type_4 uniformly
static inline __insieme_type_4 __insieme_type_4_init_uniform(double value) {
	__insieme_type_4 res;
	for (int i=0; i<2001;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: type_declaration___insieme_globals //
struct __insieme_globals { 
    __insieme_type_1 rate;
    __insieme_type_2 prob;
    __insieme_type_3 succ;
    __insieme_type_4 pv;
    __insieme_type_4 pv_1;
    double nomval;
    double dt;
};

// start code fragment :: global data //
struct __insieme_globals __GLOBAL__;

// start code fragment :: Prototype for external function: ceil ... type: ((real<8>)->real<8>) //
double ceil(double);
static double ceil_wrap(void* _closure, double var_53) { return ceil(var_53); }

// start code fragment :: Prototype for external function: rand ... type: (()->int<4>) //
int rand();
static int rand_wrap(void* _closure) { return rand(); }

// start code fragment :: Prototype for external function: printf ... type: ((ref<array<char,1>>,var_list)->int<4>) //
int printf(char*, ...);

// start code fragment :: Prototype for external function: clock ... type: (()->int<8>) //
long clock();
static long clock_wrap(void* _closure) { return clock(); }

// start code fragment :: Definition of begin_timer ... type: (()->int<8>) //
long begin_timer(){
	long t_begin = 0;
	((t_begin) = clock());
	return (t_begin);
}
static long begin_timer_wrap(void* _closure) { return begin_timer(); }

// start code fragment :: struct for job __insieme_job_5 //
struct __insieme_job_5 { 
	unsigned structSize;
	unsigned min, max;
	void (*fun)(isbr_JobArgs*);
	// ---- additional captured variables -----
};

// start code fragment :: Definitions for function type: __insieme_funType_6 //
//
// -------------------- Begin of constructs for function type (()->unit)---------------------
// Base-struct of describing closures of type __insieme_funType_6 <-> (()->unit)
typedef struct ___insieme_funType_6 { 
    void(*call)(void*);
} __insieme_funType_6;

// Type safe function for invoking closures of type __insieme_funType_6
static inline void __insieme_funType_6_call(__insieme_funType_6* closure) {  closure->call(closure); }

// A constructor for closures wrapping pure functions of type (()->unit)
static inline __insieme_funType_6* __insieme_funType_6_ctr(__insieme_funType_6* target, void(*call)(void*)) {
	*target = (__insieme_funType_6){call};
	return target;
}
// ----------------------- end of constructs for function (()->unit)-----------------------

// start code fragment :: Definition of __insieme_closure_7 ... type: (()->unit) //
// -- Begin - Closure Constructs ------------------------------------------------------------
// struct definition a closure of type (()->unit)
typedef struct ___insieme_closure_7 {
    void(*call)(void*);
    __insieme_funType_6* nested;
} __insieme_closure_7;

static inline void __insieme_closure_7_bind(__insieme_closure_7* closure) {  closure->nested->call(closure->nested); }

static inline __insieme_closure_7* __insieme_closure_7_ctr(__insieme_closure_7* closure, __insieme_funType_6* nested) {
    *closure = (__insieme_closure_7){&__insieme_closure_7_bind, nested};
    return closure;
}
// -- End - Closure Constructs --------------------------------------------------------------

// start code fragment :: capture-struct for pfor-body __insieme_pfor_body_9_fun //
struct __insieme_pfor_body_9_fun_capture {
	int m;
};

// start code fragment :: Prototype for external function: exp ... type: ((real<8>)->real<8>) //
double exp(double);
static double exp_wrap(void* _closure, double var_56) { return exp(var_56); }

// start code fragment :: Definition of coupon ... type: ((int<4>,real<8>,real<8>)->real<8>) //
double coupon(int m, double r, double nomval) { return (nomval*(exp(r)-1.0)); }
static double coupon_wrap(void* _closure, int m, double r, double nomval) { return coupon(m, r, nomval); }

// start code fragment :: Definition of __insieme_supp_10 ... type: ((int<4>,int<4>)->unit) //
void __insieme_supp_10(int var_46, int var_45){
	double prob_u = (((*(&((__GLOBAL__).prob))).data[((unsigned int)(((var_45*3)+2)))]));
	double prob_m = (((*(&((__GLOBAL__).prob))).data[((unsigned int)(((var_45*3)+1)))]));
	double prob_d = (((*(&((__GLOBAL__).prob))).data[((unsigned int)((var_45*3)))]));
	double pv_u = (((*(&((__GLOBAL__).pv_1))).data[((unsigned int)((((*(&((__GLOBAL__).succ))).data[((unsigned int)(((var_45*3)+2)))]))))]));
	double pv_m = (((*(&((__GLOBAL__).pv_1))).data[((unsigned int)((((*(&((__GLOBAL__).succ))).data[((unsigned int)(((var_45*3)+1)))]))))]));
	double pv_d = (((*(&((__GLOBAL__).pv_1))).data[((unsigned int)((((*(&((__GLOBAL__).succ))).data[((unsigned int)((var_45*3)))]))))]));
	int i = ((((2*1000)+1)*var_46)+var_45);
	((((*(&((__GLOBAL__).pv))).data[((unsigned int)(var_45))])) = (exp(((((double)(0))-(((*(&((__GLOBAL__).rate))).data[((unsigned int)((i)))])))*(*(&((__GLOBAL__).dt)))))*(((((prob_d)*(pv_d))+((prob_m)*(pv_m)))+((prob_u)*(pv_u)))+coupon(var_46, (((*(&((__GLOBAL__).rate))).data[((unsigned int)((i)))])), (*(&((__GLOBAL__).nomval)))))));
}
static void __insieme_supp_10_wrap(void* _closure, int var_46, int var_45) { __insieme_supp_10(var_46, var_45); }

// start code fragment :: function for pfor-body __insieme_pfor_body_9_fun //
void __insieme_pfor_body_9_fun(const isbr_PForRange range) {
	// ----- captured variables -----
	int var_54 = ((struct __insieme_pfor_body_9_fun_capture*)(range.context))->m;
	
	// ----- process iterations -----
	for(int __it = range.start; __it<range.end; __it+=range.step) {
		__insieme_supp_10(var_54, __it);
	}
	
}

// start code fragment :: Definition of backward_column ... type: ((int<4>)->unit) //
void backward_column(int m) { {
	isbr_pfor(isbr_getThreadGroup(0),(isbr_PForRange){0, ((2*1000)+1), 1, &((struct __insieme_pfor_body_9_fun_capture){m})},&__insieme_pfor_body_9_fun);
	isbr_barrier(isbr_getThreadGroup(0));
}; }
static void backward_column_wrap(void* _closure, int m) { backward_column(m); }

// start code fragment :: capture-struct for pfor-body __insieme_pfor_body_11_fun //
struct __insieme_pfor_body_11_fun_capture {
};

// start code fragment :: Definition of __insieme_supp_12 ... type: ((int<4>)->unit) //
void __insieme_supp_12(int var_50) { ((((*(&((__GLOBAL__).pv_1))).data[((unsigned int)(var_50))])) = (((*(&((__GLOBAL__).pv))).data[((unsigned int)(var_50))]))); }
static void __insieme_supp_12_wrap(void* _closure, int var_50) { __insieme_supp_12(var_50); }

// start code fragment :: function for pfor-body __insieme_pfor_body_11_fun //
void __insieme_pfor_body_11_fun(const isbr_PForRange range) {
	// ----- captured variables -----
	
	// ----- process iterations -----
	for(int __it = range.start; __it<range.end; __it+=range.step) {
		__insieme_supp_12(__it);
	}
	
}

// start code fragment :: Definition of __insieme_supp_8 ... type: (()->unit) //
void __insieme_supp_8() { for(int var_40 = (((int)(0))-(1000-1)); var_40 < ((((int)(0))-0)+1); var_40 += 1) {
	backward_column((((int)(0))-var_40));
	{
		isbr_pfor(isbr_getThreadGroup(0),(isbr_PForRange){0, ((2*1000)+1), 1, 0},&__insieme_pfor_body_11_fun);
		isbr_barrier(isbr_getThreadGroup(0));
	};
}; }
static void __insieme_supp_8_wrap(void* _closure) { __insieme_supp_8(); }

// start code fragment :: function for job __insieme_job_5 //
void fun__insieme_job_5(isbr_JobArgs* args) {
	// ----------- Unpacking local scope variables ----------
	// ---------- Unpacking auto-captured variables ---------
	// ------------------ Processing Guards -----------------
	// ------------------ Default processing -----------------
	__insieme_funType_6_call((__insieme_funType_6*)__insieme_closure_7_ctr((__insieme_closure_7*)alloca(sizeof(__insieme_closure_7)),(__insieme_funType_6*)__insieme_funType_6_ctr((__insieme_funType_6*)alloca(sizeof(__insieme_funType_6)),&__insieme_supp_8_wrap)));
}

// start code fragment :: Definition of end_timer ... type: ((int<8>)->int<8>) //
long end_timer(long t_begin){
	long t_end = 0;
	((t_end) = clock());
	return ((t_end)-t_begin);
}
static long end_timer_wrap(void* _closure, long t_begin) { return end_timer(t_begin); }

// start code fragment :: Definition of main ... type: (()->int<4>) //
int main(){
	;
	((*(&((__GLOBAL__).nomval))) = 1000.0);
	((*(&((__GLOBAL__).dt))) = 1.0);
	int m = 0;
	int j = 0;
	float ticks = 0.0;
	((((*(&((__GLOBAL__).succ))).data[((unsigned int)(2))])) = 2);
	((((*(&((__GLOBAL__).succ))).data[((unsigned int)(1))])) = 1);
	((((*(&((__GLOBAL__).succ))).data[((unsigned int)(0))])) = 0);
	{
		for(int var_27 = 1; var_27 < (2*1000); var_27 += 1) {
			((((*(&((__GLOBAL__).succ))).data[((unsigned int)(((var_27*3)+2)))])) = (var_27+1));
			((((*(&((__GLOBAL__).succ))).data[((unsigned int)(((var_27*3)+1)))])) = var_27);
			((((*(&((__GLOBAL__).succ))).data[((unsigned int)((var_27*3)))])) = (var_27-1));
		};
		((j) = (1+(((int)(ceil((((double)(((2*1000)-1)))/((double)(1))))))*1)));
	};
	((((*(&((__GLOBAL__).succ))).data[((unsigned int)((((2*1000)*3)+2)))])) = (2*1000));
	((((*(&((__GLOBAL__).succ))).data[((unsigned int)((((2*1000)*3)+1)))])) = ((2*1000)-1));
	((((*(&((__GLOBAL__).succ))).data[((unsigned int)(((2*1000)*3)))])) = ((2*1000)-2));
	{
		for(int var_29 = 0; var_29 < ((2*1000)+1); var_29 += 1) {
			((((*(&((__GLOBAL__).prob))).data[((unsigned int)(((var_29*3)+2)))])) = ((1.0/4.0)*((1.0-0.05)+(0.1*(((double)(rand()))/(((double)(2147483647))+1.0))))));
			((((*(&((__GLOBAL__).prob))).data[((unsigned int)(((var_29*3)+1)))])) = ((1.0/2.0)*((1.0-0.05)+(0.1*(((double)(rand()))/(((double)(2147483647))+1.0))))));
			((((*(&((__GLOBAL__).prob))).data[((unsigned int)((var_29*3)))])) = ((1.0-(((*(&((__GLOBAL__).prob))).data[((unsigned int)(((var_29*3)+1)))])))-(((*(&((__GLOBAL__).prob))).data[((unsigned int)(((var_29*3)+2)))]))));
		};
		((j) = (0+(((int)(ceil((((double)((((2*1000)+1)-0)))/((double)(1))))))*1)));
	};
	{
		for(int var_33 = 0; var_33 < 1000; var_33 += 1)  { {
			for(int var_31 = 0; var_31 < ((2*1000)+1); var_31 += 1)  { ((((*(&((__GLOBAL__).rate))).data[((unsigned int)(((((2*1000)+1)*var_33)+var_31)))])) = (((0.01+(0.05*(((double)(var_31))/((double)(1000)))))+(0.03*(((double)(var_33))/((double)(1000)))))*((1.0-0.05)+(0.1*(((double)(rand()))/(((double)(2147483647))+1.0)))))); };
			((j) = (0+(((int)(ceil((((double)((((2*1000)+1)-0)))/((double)(1))))))*1)));
		}; };
		((m) = (0+(((int)(ceil((((double)((1000-0)))/((double)(1))))))*1)));
	};
	printf("start..\n", 0);
	double begin = ((double)(begin_timer()));
	{
		for(int var_36 = 0; var_36 < ((2*1000)+1); var_36 += 1)  { ((((*(&((__GLOBAL__).pv_1))).data[((unsigned int)(var_36))])) = (*(&((__GLOBAL__).nomval)))); };
		((j) = (0+(((int)(ceil((((double)((((2*1000)+1)-0)))/((double)(1))))))*1)));
	};
	isbr_merge(isbr_parallel(memcpy(malloc(sizeof(struct __insieme_job_5)),&((struct __insieme_job_5){sizeof(struct __insieme_job_5),1,isbr_getMaxThreads(),&fun__insieme_job_5}),sizeof(struct __insieme_job_5))));
	((ticks) = ((float)(end_timer(((long)((begin)))))));
	printf("pval=%8.2f\n", (((*(&((__GLOBAL__).pv))).data[((unsigned int)(1000))])));
}
static int main_wrap(void* _closure) { return main(); }
