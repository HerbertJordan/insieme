// --- Generated Inspire Code ---
#include <alloca.h>
#include <stddef.h>
#include <stdlib.h>
#include <runtime.h>
#define bool int
#define true 1
#define false 0
#define null 0

// start code fragment :: vector_type_declaration of __insieme_type_0 <=> vector<real<8>,2001000> //
typedef struct ___insieme_type_0 { 
    double data[2001000];
} __insieme_type_0;

// A constructor initializing a vector of the type __insieme_type_0 uniformly
static inline __insieme_type_0 __insieme_type_0_init_uniform(double value) {
	__insieme_type_0 res;
	for (int i=0; i<2001000;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_1 <=> vector<real<8>,6003> //
typedef struct ___insieme_type_1 { 
    double data[6003];
} __insieme_type_1;

// A constructor initializing a vector of the type __insieme_type_1 uniformly
static inline __insieme_type_1 __insieme_type_1_init_uniform(double value) {
	__insieme_type_1 res;
	for (int i=0; i<6003;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_2 <=> vector<int<4>,6003> //
typedef struct ___insieme_type_2 { 
    int data[6003];
} __insieme_type_2;

// A constructor initializing a vector of the type __insieme_type_2 uniformly
static inline __insieme_type_2 __insieme_type_2_init_uniform(int value) {
	__insieme_type_2 res;
	for (int i=0; i<6003;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_3 <=> vector<real<8>,2001> //
typedef struct ___insieme_type_3 { 
    double data[2001];
} __insieme_type_3;

// A constructor initializing a vector of the type __insieme_type_3 uniformly
static inline __insieme_type_3 __insieme_type_3_init_uniform(double value) {
	__insieme_type_3 res;
	for (int i=0; i<2001;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: type_declaration___insieme_globals //
struct __insieme_globals { 
    __insieme_type_0 rate;
    __insieme_type_1 prob;
    __insieme_type_2 succ;
    __insieme_type_3 pv;
    __insieme_type_3 pv_1;
    double nomval;
    double dt;
};

// start code fragment :: global data //
struct __insieme_globals __GLOBAL__;

// start code fragment :: Prototype for external function: ceil ... type: ((real<8>)->real<8>) //
double ceil(double);
static double ceil_wrap(void* _closure, double var_49) { return ceil(var_49); }

// start code fragment :: Prototype for external function: rand ... type: (()->int<4>) //
int rand();
static int rand_wrap(void* _closure) { return rand(); }

// start code fragment :: array type definition of __insieme_type_6 <=> array<char,1> //
typedef struct ___insieme_type_6 { 
    char* data;
} __insieme_type_6;

// start code fragment :: Prototype for external function: printf ... type: ((ref<array<char,1>>,var_list)->int<4>) //
int printf(char*, ...);

// start code fragment :: Prototype for external function: clock ... type: (()->int<8>) //
long clock();
static long clock_wrap(void* _closure) { return clock(); }

// start code fragment :: Definition of begin_timer ... type: (()->int<8>) //
long begin_timer(){
	long t_begin = 0;
	((t_begin) = clock());
	return (t_begin);
}
static long begin_timer_wrap(void* _closure) { return begin_timer(); }

// start code fragment :: struct for job __insieme_job_10 //
struct __insieme_job_10 { 
	unsigned structSize;
	unsigned min, max;
	void (*fun)(isbr_JobArgs*);
	// ---- additional captured variables -----
};

// start code fragment :: Definitions for function type: __insieme_funType_11 //
//
// -------------------- Begin of constructs for function type (()->unit)---------------------
// Base-struct of describing closures of type __insieme_funType_11 <-> (()->unit)
typedef struct ___insieme_funType_11 { 
    void(*call)(void*);
} __insieme_funType_11;

// Type safe function for invoking closures of type __insieme_funType_11
static inline void __insieme_funType_11_call(__insieme_funType_11* closure) {  closure->call(closure); }

// A constructor for closures wrapping pure functions of type (()->unit)
static inline __insieme_funType_11* __insieme_funType_11_ctr(__insieme_funType_11* target, void(*call)(void*)) {
	*target = (__insieme_funType_11){call};
	return target;
}
// ----------------------- end of constructs for function (()->unit)-----------------------

// start code fragment :: Definition of __insieme_closure_12 ... type: (()->unit) //
// -- Begin - Closure Constructs ------------------------------------------------------------
// struct definition a closure of type (()->unit)
typedef struct ___insieme_closure_12 {
    void(*call)(void*);
    __insieme_funType_11* nested;
} __insieme_closure_12;

static inline void __insieme_closure_12_bind(__insieme_closure_12* closure) {  closure->nested->call(closure->nested); }

static inline __insieme_closure_12* __insieme_closure_12_ctr(__insieme_closure_12* closure, __insieme_funType_11* nested) {
    *closure = (__insieme_closure_12){&__insieme_closure_12_bind, nested};
    return closure;
}
// -- End - Closure Constructs --------------------------------------------------------------

// start code fragment :: capture-struct for pfor-body __insieme_pfor_body_15_fun //
struct __insieme_pfor_body_15_fun_capture {
	int m;
};

// start code fragment :: Prototype for external function: exp ... type: ((real<8>)->real<8>) //
double exp(double);
static double exp_wrap(void* _closure, double var_52) { return exp(var_52); }

// start code fragment :: Definition of coupon ... type: ((int<4>,real<8>,real<8>)->real<8>) //
double coupon(int m, double r, double nomval) { return (nomval*(exp(r)-1.0)); }
static double coupon_wrap(void* _closure, int m, double r, double nomval) { return coupon(m, r, nomval); }

// start code fragment :: Definition of __insieme_supp_16 ... type: ((int<4>,int<4>)->unit) //
void __insieme_supp_16(int var_38, int var_37){
	double prob_u = ((*(&((__GLOBAL__).prob))).data[((unsigned int)(((var_37*3)+2)))]);
	double prob_m = ((*(&((__GLOBAL__).prob))).data[((unsigned int)(((var_37*3)+1)))]);
	double prob_d = ((*(&((__GLOBAL__).prob))).data[((unsigned int)((var_37*3)))]);
	double pv_u = ((*(&((__GLOBAL__).pv_1))).data[((unsigned int)((((*(&((__GLOBAL__).succ))).data[((unsigned int)(((var_37*3)+2)))]))))]);
	double pv_m = ((*(&((__GLOBAL__).pv_1))).data[((unsigned int)((((*(&((__GLOBAL__).succ))).data[((unsigned int)(((var_37*3)+1)))]))))]);
	double pv_d = ((*(&((__GLOBAL__).pv_1))).data[((unsigned int)((((*(&((__GLOBAL__).succ))).data[((unsigned int)((var_37*3)))]))))]);
	int i = ((((2*1000)+1)*var_38)+var_37);
	((((*(&((__GLOBAL__).pv))).data[((unsigned int)(var_37))])) = (exp(((((double)(0))-(((*(&((__GLOBAL__).rate))).data[((unsigned int)((i)))])))*(*(&((__GLOBAL__).dt)))))*(((((prob_d)*(pv_d))+((prob_m)*(pv_m)))+((prob_u)*(pv_u)))+coupon(var_38, (((*(&((__GLOBAL__).rate))).data[((unsigned int)((i)))])), (*(&((__GLOBAL__).nomval)))))));
}
static void __insieme_supp_16_wrap(void* _closure, int var_38, int var_37) { __insieme_supp_16(var_38, var_37); }

// start code fragment :: function for pfor-body __insieme_pfor_body_15_fun //
void __insieme_pfor_body_15_fun(const isbr_PForRange range) {
	// ----- captured variables -----
	int var_50 = ((struct __insieme_pfor_body_15_fun_capture*)(range.context))->m;
	
	// ----- process iterations -----
	for(int __it = range.start; __it<range.end; __it+=range.step) {
		__insieme_supp_16(var_50, __it);
	}
	
}

// start code fragment :: Definition of __insieme_supp_14 ... type: ((int<4>)->unit) //
void __insieme_supp_14(int m) { {
	isbr_pfor(isbr_getThreadGroup(0),(isbr_PForRange){0, ((2*1000)+1), 1, &((struct __insieme_pfor_body_15_fun_capture){m})},&__insieme_pfor_body_15_fun);
	isbr_barrier(isbr_getThreadGroup(0));
}; }
static void __insieme_supp_14_wrap(void* _closure, int m) { __insieme_supp_14(m); }

// start code fragment :: capture-struct for pfor-body __insieme_pfor_body_17_fun //
struct __insieme_pfor_body_17_fun_capture {
};

// start code fragment :: Definition of __insieme_supp_18 ... type: ((int<4>)->unit) //
void __insieme_supp_18(int var_42) { ((((*(&((__GLOBAL__).pv_1))).data[((unsigned int)(var_42))])) = (((*(&((__GLOBAL__).pv))).data[((unsigned int)(var_42))]))); }
static void __insieme_supp_18_wrap(void* _closure, int var_42) { __insieme_supp_18(var_42); }

// start code fragment :: function for pfor-body __insieme_pfor_body_17_fun //
void __insieme_pfor_body_17_fun(const isbr_PForRange range) {
	// ----- captured variables -----
	
	// ----- process iterations -----
	for(int __it = range.start; __it<range.end; __it+=range.step) {
		__insieme_supp_18(__it);
	}
	
}

// start code fragment :: Definition of __insieme_supp_13 ... type: (()->unit) //
void __insieme_supp_13() { for(int n = (((int)(0))-(1000-1)); n < ((((int)(0))-0)+1); n += 1) {
	__insieme_supp_14((((int)(0))-(n)));
	{
		isbr_pfor(isbr_getThreadGroup(0),(isbr_PForRange){0, ((2*1000)+1), 1, 0},&__insieme_pfor_body_17_fun);
		isbr_barrier(isbr_getThreadGroup(0));
	};
}; }
static void __insieme_supp_13_wrap(void* _closure) { __insieme_supp_13(); }

// start code fragment :: function for job __insieme_job_10 //
void fun__insieme_job_10(isbr_JobArgs* args) {
	// ----------- Unpacking local scope variables ----------
	// ---------- Unpacking auto-captured variables ---------
	// ------------------ Processing Guards -----------------
	// ------------------ Default processing -----------------
	__insieme_funType_11_call((__insieme_funType_11*)__insieme_closure_12_ctr((__insieme_closure_12*)alloca(sizeof(__insieme_closure_12)),(__insieme_funType_11*)__insieme_funType_11_ctr((__insieme_funType_11*)alloca(sizeof(__insieme_funType_11)),&__insieme_supp_13_wrap)));
}

// start code fragment :: Definition of end_timer ... type: ((int<8>)->int<8>) //
long end_timer(long t_begin){
	long t_end = 0;
	((t_end) = clock());
	return ((t_end)-t_begin);
}
static long end_timer_wrap(void* _closure, long t_begin) { return end_timer(t_begin); }

// start code fragment :: main function //
int main() {
	{
		;
		((*(&((__GLOBAL__).nomval))) = 1000.0);
		((*(&((__GLOBAL__).dt))) = 1.0);
		int m = 0;
		int j = 0;
		float ticks = 0.0;
		((((*(&((__GLOBAL__).succ))).data[((unsigned int)(2))])) = 2);
		((((*(&((__GLOBAL__).succ))).data[((unsigned int)(1))])) = 1);
		((((*(&((__GLOBAL__).succ))).data[((unsigned int)(0))])) = 0);
		{
			for(int var_5 = 1; var_5 < (2*1000); var_5 += 1) {
				((((*(&((__GLOBAL__).succ))).data[((unsigned int)((((var_5)*3)+2)))])) = ((var_5)+1));
				((((*(&((__GLOBAL__).succ))).data[((unsigned int)((((var_5)*3)+1)))])) = (var_5));
				((((*(&((__GLOBAL__).succ))).data[((unsigned int)(((var_5)*3)))])) = ((var_5)-1));
			};
			((j) = (1+(((int)(ceil((((double)(((2*1000)-1)))/((double)(1))))))*1)));
		};
		((((*(&((__GLOBAL__).succ))).data[((unsigned int)((((2*1000)*3)+2)))])) = (2*1000));
		((((*(&((__GLOBAL__).succ))).data[((unsigned int)((((2*1000)*3)+1)))])) = ((2*1000)-1));
		((((*(&((__GLOBAL__).succ))).data[((unsigned int)(((2*1000)*3)))])) = ((2*1000)-2));
		{
			for(int var_6 = 0; var_6 < ((2*1000)+1); var_6 += 1) {
				((((*(&((__GLOBAL__).prob))).data[((unsigned int)((((var_6)*3)+2)))])) = ((1.0/4.0)*((1.0-0.05)+(0.1*(((double)(rand()))/(((double)(2147483647))+1.0))))));
				((((*(&((__GLOBAL__).prob))).data[((unsigned int)((((var_6)*3)+1)))])) = ((1.0/2.0)*((1.0-0.05)+(0.1*(((double)(rand()))/(((double)(2147483647))+1.0))))));
				((((*(&((__GLOBAL__).prob))).data[((unsigned int)(((var_6)*3)))])) = ((1.0-(((*(&((__GLOBAL__).prob))).data[((unsigned int)((((var_6)*3)+1)))])))-(((*(&((__GLOBAL__).prob))).data[((unsigned int)((((var_6)*3)+2)))]))));
			};
			((j) = (0+(((int)(ceil((((double)((((2*1000)+1)-0)))/((double)(1))))))*1)));
		};
		{
			for(int var_8 = 0; var_8 < 1000; var_8 += 1)  { {
				for(int var_7 = 0; var_7 < ((2*1000)+1); var_7 += 1)  { ((((*(&((__GLOBAL__).rate))).data[((unsigned int)(((((2*1000)+1)*(var_8))+(var_7))))])) = (((0.01+(0.05*(((double)((var_7)))/((double)(1000)))))+(0.03*(((double)((var_8)))/((double)(1000)))))*((1.0-0.05)+(0.1*(((double)(rand()))/(((double)(2147483647))+1.0)))))); };
				((j) = (0+(((int)(ceil((((double)((((2*1000)+1)-0)))/((double)(1))))))*1)));
			}; };
			((m) = (0+(((int)(ceil((((double)((1000-0)))/((double)(1))))))*1)));
		};
		printf(((char*)((*(&((__insieme_type_6){"start..\n"}))).data)), 0);
		double begin = ((double)(begin_timer()));
		{
			for(int var_12 = 0; var_12 < ((2*1000)+1); var_12 += 1)  { ((((*(&((__GLOBAL__).pv_1))).data[((unsigned int)((var_12)))])) = (*(&((__GLOBAL__).nomval)))); };
			((j) = (0+(((int)(ceil((((double)((((2*1000)+1)-0)))/((double)(1))))))*1)));
		};
		isbr_merge(isbr_parallel(memcpy(malloc(sizeof(struct __insieme_job_10)),&((struct __insieme_job_10){sizeof(struct __insieme_job_10),1,isbr_getMaxThreads(),&fun__insieme_job_10}),sizeof(struct __insieme_job_10))));
		((ticks) = ((float)(end_timer(((long)(begin))))));
		printf(((char*)((*(&((__insieme_type_6){"pval=%8.2f\n"}))).data)), (((*(&((__GLOBAL__).pv))).data[((unsigned int)(1000))])));
	}
}
