// -------------- Pretty Print Inspire --------------
// Inspire Program 
//  Entry Point: 
fun(int<4> v1, array<ref<array<ref<char>,1>>,1> v2) {
        decl ref<int<8>> v3 = ( var(0));
        decl ref<int<8>> v4 = ( var(0));
        decl ref<real<8>> v5 = ( var(0.0));
        decl ref<real<8>> v6 = ( var(0.0));
        (v3 := clock());
        decl ref<vector<vector<ref<real<4>>,650>,650>> v7 = ( var(vector.initUniform(vector.initUniform(( var(0.0))))));
        decl ref<vector<vector<ref<real<4>>,650>,650>> v8 = ( var(vector.initUniform(vector.initUniform(( var(0.0))))));
        decl ref<vector<vector<ref<real<4>>,650>,650>> v9 = ( var(vector.initUniform(vector.initUniform(( var(0.0))))));
        decl ref<vector<vector<ref<real<4>>,650>,650>> v10 = ( var(vector.initUniform(vector.initUniform(( var(0.0))))));
        memset(( *v7), 0, CAST<uint<8>>((650*650)));
        memset(( *v9), 0, CAST<uint<8>>((650*650)));
        for(decl ref<int<4>> v11 = ( var(0)) .. 650 : 1) 
            for(decl ref<int<4>> v12 = ( var(0)) .. 650 : 1) 
                (((( *v9)[CAST<uint<4>>(( *v11))])[CAST<uint<4>>(( *v12))]) := CAST<real<4>>(fun(int<4> v13, int<4> v14) {
                    return (CAST<real<8>>(40)*sin(CAST<real<8>>(((16*((2*v13)-1))*v14))));
                }(( *v11), ( *v12))))
            
        ;
        decl ref<real<8>> v15 = ( var(CAST<real<8>>(0)));
        decl ref<real<8>> v16 = ( var(CAST<real<8>>(0)));
        decl ref<real<8>> v17 = ( var(CAST<real<8>>(0)));
        decl ref<real<8>> v18 = ( var(0.0));
        decl ref<real<8>> v19 = ( var(pow((CAST<real<8>>(1)/CAST<real<8>>(650)), CAST<real<8>>(2))));
        (v4 := clock());
        (v5 := (CAST<real<8>>((( *v4)-( *v3)))/CAST<real<8>>(1000000l)));
        (v3 := clock());
        for(decl ref<int<4>> v27 = ( var(0)) .. 10 : 1) {
            for(decl ref<int<4>> v21 = ( var(1)) .. (650-1) : 1) {
                for(decl ref<int<4>> v20 = ( var(1)) .. (650-1) : 1) 
                    (((( *v8)[CAST<uint<4>>(( *v21))])[CAST<uint<4>>(( *v20))]) := CAST<real<4>>(((CAST<real<8>>(1)/CAST<real<8>>(4))*(CAST<real<8>>((((( *((( *v7)[CAST<uint<4>>((( *v21)-1))])[CAST<uint<4>>(( *v20))]))+( *((( *v7)[CAST<uint<4>>(( *v21))])[CAST<uint<4>>((( *v20)+1))])))+( *((( *v7)[CAST<uint<4>>(( *v21))])[CAST<uint<4>>((( *v20)-1))])))+( *((( *v7)[CAST<uint<4>>((( *v21)+1))])[CAST<uint<4>>(( *v20))]))))-(( *v19)*CAST<real<8>>(( *((( *v9)[CAST<uint<4>>(( *v21))])[CAST<uint<4>>(( *v20))]))))))))
                ;
            };
            memcpy(( *v7), ( *v8), CAST<uint<8>>((650*650)));
            for(decl ref<int<4>> v23 = ( var(1)) .. (650-1) : 1) {
                for(decl ref<int<4>> v22 = ( var(1)) .. (650-1) : 1) 
                    (((( *v10)[CAST<uint<4>>(( *v23))])[CAST<uint<4>>(( *v22))]) := (((((( *((( *v9)[CAST<uint<4>>(( *v23))])[CAST<uint<4>>(( *v22))]))-(CAST<real<4>>(4)*( *((( *v7)[CAST<uint<4>>(( *v23))])[CAST<uint<4>>(( *v22))]))))+( *((( *v7)[CAST<uint<4>>((( *v23)-1))])[CAST<uint<4>>(( *v22))])))+( *((( *v7)[CAST<uint<4>>((( *v23)+1))])[CAST<uint<4>>(( *v22))])))+( *((( *v7)[CAST<uint<4>>(( *v23))])[CAST<uint<4>>((( *v22)-1))])))+( *((( *v7)[CAST<uint<4>>(( *v23))])[CAST<uint<4>>((( *v22)+1))]))))
                ;
            };
            decl ref<real<8>> v24 = ( var(CAST<real<8>>(0)));
            for(decl ref<int<4>> v26 = ( var(1)) .. (650-1) : 1) {
                for(decl ref<int<4>> v25 = ( var(1)) .. (650-1) : 1) 
                    (v24 := (( *v24)+pow(CAST<real<8>>(( *((( *v10)[CAST<uint<4>>(( *v26))])[CAST<uint<4>>(( *v25))]))), CAST<real<8>>(2))))
                ;
            };
            (v18 := (sqrt(( *v24))/CAST<real<8>>((650-1))));
        };
        (v4 := clock());
        (v6 := (CAST<real<8>>((( *v4)-( *v3)))/CAST<real<8>>(1000000l)));
    }

