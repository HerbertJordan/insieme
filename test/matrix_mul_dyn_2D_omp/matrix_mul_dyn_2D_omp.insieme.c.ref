// --- Generated Inspire Code ---
#include <alloca.h>
#include <stddef.h>
#include <runtime.h>
#define bool int
#define true 1
#define false 0
#define null 0

// start code fragment :: Definition of createMatrix ... type: ((uint<4>,uint<4>)->ref<array<ref<array<real<8>,1>>,1>>) //
double** createMatrix(unsigned int x, unsigned int y){
	double* data = (((double*){malloc(sizeof(double*)*((((unsigned long)((x*y)))*sizeof(double))/sizeof(double)))}));
	double** index = (((double**){malloc(sizeof(double**)*((((unsigned long)(x))*sizeof(double*))/sizeof(double*)))}));
	((((index)[((unsigned int)(0))])) = (data));
	for(unsigned int var_6 = ((unsigned int)(1)); var_6 < x; var_6 += 1)  { ((((index)[var_6])) = (&((data)[(var_6*y)]))); };
	return (index);
}
static double** createMatrix_wrap(void* _closure, unsigned int x, unsigned int y) { return createMatrix(x, y); }

// start code fragment :: struct for job __insieme_job_1 //
struct __insieme_job_1 { 
	unsigned structSize;
	unsigned min, max;
	void (*fun)(isbr_JobArgs*);
	// ---- additional captured variables -----
	double*** var_67;
	double*** var_68;
	double*** var_69;
};

// start code fragment :: Definitions for function type: __insieme_funType_2 //
//
// -------------------- Begin of constructs for function type (()->unit)---------------------
// Base-struct of describing closures of type __insieme_funType_2 <-> (()->unit)
typedef struct ___insieme_funType_2 { 
    void(*call)(void*);
} __insieme_funType_2;

// Type safe function for invoking closures of type __insieme_funType_2
static inline void __insieme_funType_2_call(__insieme_funType_2* closure) {  closure->call(closure); }

// A constructor for closures wrapping pure functions of type (()->unit)
static inline __insieme_funType_2* __insieme_funType_2_ctr(__insieme_funType_2* target, void(*call)(void*)) {
	*target = (__insieme_funType_2){call};
	return target;
}
// ----------------------- end of constructs for function (()->unit)-----------------------

// start code fragment :: Definitions for function type: __insieme_funType_4 //
//
// -------------------- Begin of constructs for function type ((ref<ref<array<ref<array<real<8>,1>>,1>>>,ref<ref<array<ref<array<real<8>,1>>,1>>>,ref<ref<array<ref<array<real<8>,1>>,1>>>)->unit)---------------------
// Base-struct of describing closures of type __insieme_funType_4 <-> ((ref<ref<array<ref<array<real<8>,1>>,1>>>,ref<ref<array<ref<array<real<8>,1>>,1>>>,ref<ref<array<ref<array<real<8>,1>>,1>>>)->unit)
typedef struct ___insieme_funType_4 { 
    void(*call)(void*, double***, double***, double***);
} __insieme_funType_4;

// Type safe function for invoking closures of type __insieme_funType_4
static inline void __insieme_funType_4_call(__insieme_funType_4* closure, double*** p1, double*** p2, double*** p3) {  closure->call(closure, p1,p2,p3); }

// A constructor for closures wrapping pure functions of type ((ref<ref<array<ref<array<real<8>,1>>,1>>>,ref<ref<array<ref<array<real<8>,1>>,1>>>,ref<ref<array<ref<array<real<8>,1>>,1>>>)->unit)
static inline __insieme_funType_4* __insieme_funType_4_ctr(__insieme_funType_4* target, void(*call)(void*, double***, double***, double***)) {
	*target = (__insieme_funType_4){call};
	return target;
}
// ----------------------- end of constructs for function ((ref<ref<array<ref<array<real<8>,1>>,1>>>,ref<ref<array<ref<array<real<8>,1>>,1>>>,ref<ref<array<ref<array<real<8>,1>>,1>>>)->unit)-----------------------

// start code fragment :: Definition of __insieme_closure_3 ... type: (()->unit) //
// -- Begin - Closure Constructs ------------------------------------------------------------
// struct definition a closure of type (()->unit)
typedef struct ___insieme_closure_3 {
    void(*call)(void*);
    __insieme_funType_4* nested;
    double*** c1;
    double*** c2;
    double*** c3;
} __insieme_closure_3;

static inline void __insieme_closure_3_bind(__insieme_closure_3* closure) {  closure->nested->call(closure->nested, closure->c1,closure->c2,closure->c3); }

static inline __insieme_closure_3* __insieme_closure_3_ctr(__insieme_closure_3* closure, __insieme_funType_4* nested, double*** c1, double*** c2, double*** c3) {
    *closure = (__insieme_closure_3){&__insieme_closure_3_bind, nested, c1, c2, c3};
    return closure;
}
// -- End - Closure Constructs --------------------------------------------------------------

// start code fragment :: capture-struct for pfor-body __insieme_pfor_body_6_fun //
struct __insieme_pfor_body_6_fun_capture {
	double*** var_51;
};

// start code fragment :: Definition of __insieme_supp_7 ... type: ((ref<ref<array<ref<array<real<8>,1>>,1>>>,int<4>)->unit) //
void __insieme_supp_7(double*** var_55, int var_54) { for(int var_16 = 0; var_16 < 1000; var_16 += 1)  { ((((((*var_55)[((unsigned int)(var_54))]))[((unsigned int)(var_16))])) = ((double)((var_54*var_16)))); }; }
static void __insieme_supp_7_wrap(void* _closure, double*** var_55, int var_54) { __insieme_supp_7(var_55, var_54); }

// start code fragment :: function for pfor-body __insieme_pfor_body_6_fun //
void __insieme_pfor_body_6_fun(const isbr_PForRange range) {
	// ----- captured variables -----
	double*** var_70 = ((struct __insieme_pfor_body_6_fun_capture*)(range.context))->var_51;
	
	// ----- process iterations -----
	for(int __it = range.start; __it<range.end; __it+=range.step) {
		__insieme_supp_7(var_70, __it);
	}
	
}

// start code fragment :: capture-struct for pfor-body __insieme_pfor_body_8_fun //
struct __insieme_pfor_body_8_fun_capture {
	double*** var_50;
};

// start code fragment :: Definition of __insieme_supp_9 ... type: ((ref<ref<array<ref<array<real<8>,1>>,1>>>,int<4>)->unit) //
void __insieme_supp_9(double*** var_59, int var_58) { for(int var_24 = 0; var_24 < 1000; var_24 += 1)  { ((((((*var_59)[((unsigned int)(var_58))]))[((unsigned int)(var_24))])) = ((double)((((var_58==var_24))?(1):(0))))); }; }
static void __insieme_supp_9_wrap(void* _closure, double*** var_59, int var_58) { __insieme_supp_9(var_59, var_58); }

// start code fragment :: function for pfor-body __insieme_pfor_body_8_fun //
void __insieme_pfor_body_8_fun(const isbr_PForRange range) {
	// ----- captured variables -----
	double*** var_72 = ((struct __insieme_pfor_body_8_fun_capture*)(range.context))->var_50;
	
	// ----- process iterations -----
	for(int __it = range.start; __it<range.end; __it+=range.step) {
		__insieme_supp_9(var_72, __it);
	}
	
}

// start code fragment :: capture-struct for pfor-body __insieme_pfor_body_10_fun //
struct __insieme_pfor_body_10_fun_capture {
	double*** var_49;
	double*** var_50;
	double*** var_51;
};

// start code fragment :: Definition of __insieme_supp_11 ... type: ((ref<ref<array<ref<array<real<8>,1>>,1>>>,ref<ref<array<ref<array<real<8>,1>>,1>>>,ref<ref<array<ref<array<real<8>,1>>,1>>>,int<4>)->unit) //
void __insieme_supp_11(double*** var_65, double*** var_64, double*** var_63, int var_62) { for(int var_31 = 0; var_31 < 1000; var_31 += 1) {
	double sum = ((double)(0));
	for(int var_30 = 0; var_30 < 1000; var_30 += 1)  { ((sum) = ((sum)+((((((*var_63)[((unsigned int)(var_62))]))[((unsigned int)(var_30))]))*(((((*var_64)[((unsigned int)(var_30))]))[((unsigned int)(var_31))]))))); };
	((((((*var_65)[((unsigned int)(var_62))]))[((unsigned int)(var_31))])) = (sum));
}; }
static void __insieme_supp_11_wrap(void* _closure, double*** var_65, double*** var_64, double*** var_63, int var_62) { __insieme_supp_11(var_65, var_64, var_63, var_62); }

// start code fragment :: function for pfor-body __insieme_pfor_body_10_fun //
void __insieme_pfor_body_10_fun(const isbr_PForRange range) {
	// ----- captured variables -----
	double*** var_74 = ((struct __insieme_pfor_body_10_fun_capture*)(range.context))->var_49;
	double*** var_75 = ((struct __insieme_pfor_body_10_fun_capture*)(range.context))->var_50;
	double*** var_76 = ((struct __insieme_pfor_body_10_fun_capture*)(range.context))->var_51;
	
	// ----- process iterations -----
	for(int __it = range.start; __it<range.end; __it+=range.step) {
		__insieme_supp_11(var_74, var_75, var_76, __it);
	}
	
}

// start code fragment :: Definition of __insieme_supp_5 ... type: ((ref<ref<array<ref<array<real<8>,1>>,1>>>,ref<ref<array<ref<array<real<8>,1>>,1>>>,ref<ref<array<ref<array<real<8>,1>>,1>>>)->unit) //
void __insieme_supp_5(double*** var_51, double*** var_50, double*** var_49){
	{
		isbr_pfor(isbr_getThreadGroup(0),(isbr_PForRange){0, 1000, 1, &((struct __insieme_pfor_body_6_fun_capture){var_51})},&__insieme_pfor_body_6_fun);
		isbr_barrier(isbr_getThreadGroup(0));
	};
	{
		isbr_pfor(isbr_getThreadGroup(0),(isbr_PForRange){0, 1000, 1, &((struct __insieme_pfor_body_8_fun_capture){var_50})},&__insieme_pfor_body_8_fun);
		isbr_barrier(isbr_getThreadGroup(0));
	};
	{
		isbr_pfor(isbr_getThreadGroup(0),(isbr_PForRange){0, 1000, 1, &((struct __insieme_pfor_body_10_fun_capture){var_49, var_50, var_51})},&__insieme_pfor_body_10_fun);
		isbr_barrier(isbr_getThreadGroup(0));
	};
}
static void __insieme_supp_5_wrap(void* _closure, double*** var_51, double*** var_50, double*** var_49) { __insieme_supp_5(var_51, var_50, var_49); }

// start code fragment :: function for job __insieme_job_1 //
void fun__insieme_job_1(isbr_JobArgs* args) {
	// ----------- Unpacking local scope variables ----------
	// ---------- Unpacking auto-captured variables ---------
	double*** var_67 = ((struct __insieme_job_1*)args)->var_67;
	double*** var_68 = ((struct __insieme_job_1*)args)->var_68;
	double*** var_69 = ((struct __insieme_job_1*)args)->var_69;
	// ------------------ Processing Guards -----------------
	// ------------------ Default processing -----------------
	__insieme_funType_2_call((__insieme_funType_2*)__insieme_closure_3_ctr((__insieme_closure_3*)alloca(sizeof(__insieme_closure_3)),(__insieme_funType_4*)__insieme_funType_4_ctr((__insieme_funType_4*)alloca(sizeof(__insieme_funType_4)),&__insieme_supp_5_wrap), var_67, var_68, var_69));
}

// start code fragment :: Prototype for external function: printf ... type: ((ref<array<char,1>>,var_list)->int<4>) //
int printf(char*, ...);

// start code fragment :: vector_type_declaration of __insieme_type_12 <=> vector<char,3> //
typedef struct ___insieme_type_12 { 
    char data[3];
} __insieme_type_12;

// A constructor initializing a vector of the type __insieme_type_12 uniformly
static inline __insieme_type_12 __insieme_type_12_init_uniform(char value) {
	__insieme_type_12 res;
	for (int i=0; i<3;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_13 <=> vector<char,4> //
typedef struct ___insieme_type_13 { 
    char data[4];
} __insieme_type_13;

// A constructor initializing a vector of the type __insieme_type_13 uniformly
static inline __insieme_type_13 __insieme_type_13_init_uniform(char value) {
	__insieme_type_13 res;
	for (int i=0; i<4;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: Definition of freeMatrix ... type: ((ref<array<ref<array<real<8>,1>>,1>>)->unit) //
void freeMatrix(double** matrix){
	double** var_9 = matrix;
	{
		free((((var_9)[((unsigned int)(0))])));
		;
	};
}
static void freeMatrix_wrap(void* _closure, double** matrix) { freeMatrix(matrix); }

// start code fragment :: Definition of main ... type: (()->int<4>) //
int main(){
	double** A = createMatrix(((unsigned int)(1000)), ((unsigned int)(1000)));
	double** B = createMatrix(((unsigned int)(1000)), ((unsigned int)(1000)));
	double** C = createMatrix(((unsigned int)(1000)), ((unsigned int)(1000)));
	isbr_merge(isbr_parallel(memcpy(malloc(sizeof(struct __insieme_job_1)),&((struct __insieme_job_1){sizeof(struct __insieme_job_1),1,isbr_getMaxThreads(),&fun__insieme_job_1,&A,&B,&C}),sizeof(struct __insieme_job_1))));
	int success = 1;
	for(int var_45 = 0; var_45 < 1000; var_45 += 1) {
		for(int var_38 = 0; var_38 < (((1000<1000))?(1000):(1000)); var_38 += 1)  { if(((((((A)[((unsigned int)(var_45))]))[((unsigned int)(var_38))]))!=(((((C)[((unsigned int)(var_45))]))[((unsigned int)(var_38))])))) { ((success) = 0); }; };
		for(int var_44 = (((1000<1000))?(1000):(1000)); var_44 < (((1000>1000))?(1000):(1000)); var_44 += 1)  { if(((((((C)[((unsigned int)(var_45))]))[((unsigned int)(var_44))]))!=((double)(0)))) { ((success) = 0); }; };
	};
	printf("Verification: %s\n", ((((success)!=0))?(((((__insieme_type_12){{'O', 'K', '\0'}})).data)):(((((__insieme_type_13){{'E', 'R', 'R', '\0'}})).data))));
	freeMatrix((A));
	freeMatrix((B));
	freeMatrix((C));
}
static int main_wrap(void* _closure) { return main(); }
