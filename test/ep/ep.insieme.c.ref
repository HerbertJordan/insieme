// --- Generated Inspire Code ---
#include <alloca.h>
#include <stddef.h>
#include <stdlib.h>
#include <runtime.h>
#define bool int
#define true 1
#define false 0
#define null 0
// --- Entry Point ---

// start code fragment :: type_declaration___insieme_globals //
struct __insieme_globals { 
    double _x[131073];
    double* x;
    double q[10];
    double elapsed[64];
    double start[64];
    int sec;
};

// start code fragment :: Prototype for external function: printf ... type: ((ref<array<char,1>>,var_list)->int<4>) //
int printf(char*, ...);

// start code fragment :: Prototype for external function: sprintf ... type: ((ref<array<char,1>>,ref<array<char,1>>,var_list)->int<4>) //
int sprintf(char*, char*, ...);

// start code fragment :: Prototype for external function: pow ... type: ((real<8>,real<8>)->real<8>) //
double pow(double, double);

// start code fragment :: Prototype for external function: ceil ... type: ((real<8>)->real<8>) //
double ceil(double);

// start code fragment :: Definition of vranlc //
void vranlc(int n, double* x_seed, double a, double* y) {
	{
		int i = 0;
		double x = 0.0;
		double t1 = 0.0;
		double t2 = 0.0;
		double t3 = 0.0;
		double t4 = 0.0;
		double a1 = 0.0;
		double a2 = 0.0;
		double x1 = 0.0;
		double x2 = 0.0;
		double z = 0.0;
		((t1) = (((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*a));
		((a1) = ((double)(((int)((t1))))));
		((a2) = (a-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(a1))));
		((x) = ((x_seed[0])));
		{
			for(int var_52 = 1; var_52 < (n+1); var_52 += 1) {
				((t1) = (((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*(x)));
				((x1) = ((double)(((int)((t1))))));
				((x2) = ((x)-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(x1))));
				((t1) = (((a1)*(x2))+((a2)*(x1))));
				((t2) = ((double)(((int)((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*(t1)))))));
				((z) = ((t1)-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(t2))));
				((t3) = ((((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(z))+((a2)*(x2))));
				((t4) = ((double)(((int)(((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5))*(t3)))))));
				((x) = ((t3)-((((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0))*(t4))));
				(((y[((unsigned int)((var_52)))])) = ((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5))*(x)));
			};
			((i) = (1+(((int)(ceil((((double)(((n+1)-1)))/((double)(1))))))*1)));
		};
		(((x_seed[0])) = (x));
	}
}


// start code fragment :: Definition of randlc //
double randlc(double* x, double a) {
	{
		double t1 = 0.0;
		double t2 = 0.0;
		double t3 = 0.0;
		double t4 = 0.0;
		double a1 = 0.0;
		double a2 = 0.0;
		double x1 = 0.0;
		double x2 = 0.0;
		double z = 0.0;
		((t1) = (((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*a));
		((a1) = ((double)(((int)((t1))))));
		((a2) = (a-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(a1))));
		((t1) = (((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((x[0]))));
		((x1) = ((double)(((int)((t1))))));
		((x2) = (((x[0]))-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(x1))));
		((t1) = (((a1)*(x2))+((a2)*(x1))));
		((t2) = ((double)(((int)((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*(t1)))))));
		((z) = ((t1)-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(t2))));
		((t3) = ((((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(z))+((a2)*(x2))));
		((t4) = ((double)(((int)(((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5))*(t3)))))));
		(((x[0])) = ((t3)-((((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0))*(t4))));
		return ((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5))*((x[0])));;
	}
}


// start code fragment :: Prototype for external function: log ... type: ((real<8>)->real<8>) //
double log(double);

// start code fragment :: Prototype for external function: sqrt ... type: ((real<8>)->real<8>) //
double sqrt(double);

// start code fragment :: Prototype for external function: fabs ... type: ((real<8>)->real<8>) //
double fabs(double);

// start code fragment :: Definition of timer_clear //
void timer_clear(struct __insieme_globals var_69, int n) {
	{
		((((((var_69).elapsed))[((unsigned int)(n))])) = 0.0);
	}
}


// start code fragment :: type_declaration_timeval //
struct timeval { 
    long tv_sec;
    long tv_usec;
};

// start code fragment :: type_declaration_timezone //
struct timezone { 
    int tz_minuteswest;
    int tz_dsttime;
};

// start code fragment :: Prototype for external function: gettimeofday ... type: ((ref<array<struct<tv_sec:int<8>,tv_usec:int<8>>,1>>,ref<array<struct<tz_minuteswest:int<4>,tz_dsttime:int<4>>,1>>)->int<4>) //
int gettimeofday(struct timeval*, struct timezone*);

// start code fragment :: Definition of wtime //
void wtime(struct __insieme_globals var_76, double* t) {
	{
		struct timeval tv;
		gettimeofday((&tv), null);
		if(((*(&((var_76).sec)))<0)) {
			((*(&((var_76).sec))) = ((int)((*(&((tv).tv_sec))))));
		};
		(((t[0])) = (((double)(((*(&((tv).tv_sec)))-((long)((*(&((var_76).sec))))))))+(1.0e-6*((double)((*(&((tv).tv_usec))))))));
	}
}


// start code fragment :: Definition of elapsed_time //
double elapsed_time(struct __insieme_globals var_74) {
	{
		double t = 0.0;
		wtime(&var_74, (&t));
		return (t);;
	}
}


// start code fragment :: Definition of timer_start //
void timer_start(struct __insieme_globals var_72, int n) {
	{
		((((((var_72).start))[((unsigned int)(n))])) = elapsed_time(&var_72));
	}
}


// start code fragment :: Definition of timer_stop //
void timer_stop(struct __insieme_globals var_97, int n) {
	{
		double t = 0.0;
		double now = 0.0;
		((now) = elapsed_time(&var_97));
		((t) = ((now)-(((((var_97).start))[((unsigned int)(n))]))));
		((((((var_97).elapsed))[((unsigned int)(n))])) = ((((((var_97).elapsed))[((unsigned int)(n))]))+(t)));
	}
}


// start code fragment :: Definition of timer_read //
double timer_read(struct __insieme_globals var_110, int n) {
	{
		return (((((var_110).elapsed))[((unsigned int)(n))]));;
	}
}


// start code fragment :: Definition of c_print_results //
void c_print_results(char* name, char class, int n1, int n2, int n3, int niter, int nthreads, double t, double mops, char* optype, int passed_verification, char* npbversion, char* compiletime, char* cc, char* clink, char* c_lib, char* c_inc, char* cflags, char* clinkflags, char* rand) {
	{
		char* evalue = "1000";
		printf("\n\n %s Benchmark Completed\n", (name));
		printf(" Class           =                        %c\n", ((int)(class)));
		if(((n2==0)&&<?>Unhandled Type of Call Target</?>)) {
			printf(" Size            =             %12d\n", n1);
		} else {
			printf(" Size            =              %3dx%3dx%3d\n", n1, n2, n3);
		};
		printf(" Iterations      =             %12d\n", niter);
		printf(" Threads         =             %12d\n", nthreads);
		printf(" Time in seconds =             %12.2f\n", 0.0);
		printf(" Mop/s total     =             %12.2f\n", 0.0);
		printf(" Operation type  = %24s\n", (optype));
		if(((bool)(passed_verification))) {
			printf(" Verification    =               SUCCESSFUL\n", 0);
		} else {
			printf(" Verification    =             UNSUCCESSFUL\n", 0);
		};
		printf(" Version         =             %12s\n", (npbversion));
		printf(" Compile date    =             %12s\n", (compiletime));
		printf("\n Compile options:\n", 0);
		printf("    CC           = %s\n", (cc));
		printf("    CLINK        = %s\n", (clink));
		printf("    C_LIB        = %s\n", (c_lib));
		printf("    C_INC        = %s\n", (c_inc));
		printf("    CFLAGS       = %s\n", (cflags));
		printf("    CLINKFLAGS   = %s\n", (clinkflags));
		printf("    RAND         = %s\n", (rand));
	}
}


// start code fragment :: Definition of main //
int main(int argc, char** argv) {
	{
		struct __insieme_globals* var_1 = malloc(sizeof(struct __insieme_globals));
		((*(&((*var_1).x))) = null);
		((*(&((*var_1).sec))) = (((int)(0))-1));
		double Mops = 0.0;
		double t1 = 0.0;
		double t2 = 0.0;
		double t3 = 0.0;
		double t4 = 0.0;
		double x1 = 0.0;
		double x2 = 0.0;
		double sx = 0.0;
		double sy = 0.0;
		double tm = 0.0;
		double an = 0.0;
		double tt = 0.0;
		double gc = 0.0;
		double dum[3] = {1.0, 1.0, 1.0};
		int np = 0;
		int ierr = 0;
		int node = 0;
		int no_nodes = 0;
		int i = 0;
		int ik = 0;
		int kk = 0;
		int l = 0;
		int k = 0;
		int nit = 0;
		int ierrcode = 0;
		int no_large_nodes = 0;
		int np_add = 0;
		int k_offset = 0;
		int j = 0;
		int nthreads = 1;
		int verified = 0;
		char size[14];
		(((((*var_1).x))) = ((&((((*var_1)._x))[((unsigned int)(1))]))));
		printf("\n\n NAS Parallel Benchmarks 2.3 OpenMP C version - EP Benchmark\n", 0);
		sprintf(size, "%12.0f", pow(2.0, ((double)((25+1)))));
		{
			for(int var_36 = (((int)(0))-13); var_36 < ((((int)(0))-1)+1); var_36 += 1) {
				if((((int)(((size[((unsigned int)((((int)(0))-(var_36))))]))))=='.')) {
					(((size[((unsigned int)((((int)(0))-(var_36))))])) = ' ');
				};
			};
			((j) = (13+(((int)(ceil((((double)((((((int)(0))-1)+1)-13)))/((double)(1))))))*1)));
		};
		printf(" Number of random numbers generated: %13s\n", (size));
		((verified) = 0);
		((np) = (1<<(25-16)));
		vranlc(0, (&(dum[((unsigned int)(0))])), ((dum[((unsigned int)(1))])), (&(dum[((unsigned int)(2))])));
		(((dum[((unsigned int)(0))])) = randlc((&(dum[((unsigned int)(1))])), ((dum[((unsigned int)(2))]))));
		{
			for(int var_66 = 0; var_66 < (2*(1<<16)); var_66 += 1) {
				((((((*var_1).x))[((unsigned int)((var_66)))])) = (((double)(0))-1.0e99));
			};
			((i) = (0+(((int)(ceil((((double)(((2*(1<<16))-0)))/((double)(1))))))*1)));
		};
		((Mops) = log(sqrt(fabs((((1.0>1.0))?(<?>Unhandled Type of Call Target</?>):(<?>Unhandled Type of Call Target</?>))))));
		timer_clear(var_1, 1);
		timer_clear(var_1, 2);
		timer_clear(var_1, 3);
		timer_start(var_1, 1);
		vranlc(0, (&t1), 1220703125.0, (((*var_1).x)));
		((t1) = 1220703125.0);
		{
			for(int var_82 = 1; var_82 < ((16+1)+1); var_82 += 1) {
				((t2) = randlc((&t1), (t1)));
			};
			((i) = (1+(((int)(ceil((((double)((((16+1)+1)-1)))/((double)(1))))))*1)));
		};
		((an) = (t1));
		((tt) = 271828183.0);
		((gc) = 0.0);
		((sx) = 0.0);
		((sy) = 0.0);
		{
			for(int var_83 = 0; var_83 < ((10-1)+1); var_83 += 1) {
				((((((*var_1).q))[((unsigned int)((var_83)))])) = 0.0);
			};
			((i) = (0+(((int)(ceil((((double)((((10-1)+1)-0)))/((double)(1))))))*1)));
		};
		((k_offset) = (((int)(0))-1));
		{
			double t1 = 0.0;
			double t2 = 0.0;
			double t3 = 0.0;
			double t4 = 0.0;
			double x1 = 0.0;
			double x2 = 0.0;
			int kk = 0;
			int i = 0;
			int ik = 0;
			int l = 0;
			double qq[10];
			{
				for(int var_95 = 0; var_95 < 10; var_95 += 1) {
					(((qq[((unsigned int)((var_95)))])) = 0.0);
				};
				((i) = (0+(((int)(ceil((((double)((10-0)))/((double)(1))))))*1)));
			};
			{
				for(int var_107 = 1; var_107 < ((np)+1); var_107 += 1) {
					((kk) = ((k_offset)+(var_107)));
					((t1) = 271828183.0);
					((t2) = (an));
					{
						for(int var_96 = 1; var_96 < (100+1); var_96 += 1) {
							((ik) = ((kk)/2));
							if(((2*(ik))!=(kk))) {
								((t3) = randlc((&t1), (t2)));
							};
							if(((ik)==0)) break;
							((t3) = randlc((&t2), (t2)));
							((kk) = (ik));
						};
						((i) = (1+(((int)(ceil((((double)(((100+1)-1)))/((double)(1))))))*1)));
					};
					if((0==1)) {
						timer_start(var_1, 3);
					};
					vranlc((2*(1<<16)), (&t1), 1220703125.0, (((*var_1)._x)));
					if((0==1)) {
						timer_stop(var_1, 3);
					};
					if((0==1)) {
						timer_start(var_1, 2);
					};
					{
						for(int var_106 = 0; var_106 < (1<<16); var_106 += 1) {
							((x1) = ((2.0*(((((*var_1).x))[((unsigned int)((2*(var_106))))])))-1.0));
							((x2) = ((2.0*(((((*var_1).x))[((unsigned int)(((2*(var_106))+1)))])))-1.0));
							((t1) = (((x1)*(x1))+((x2)*(x2))));
							if(((t1)<=1.0)) {
								((t2) = sqrt((((((double)(0))-2.0)*log((t1)))/(t1))));
								((t3) = ((x1)*(t2)));
								((t4) = ((x2)*(t2)));
								((l) = ((int)((((fabs((t3))>fabs((t4))))?(<?>Unhandled Type of Call Target</?>):(<?>Unhandled Type of Call Target</?>)))));
								(((qq[((unsigned int)((l)))])) = (((qq[((unsigned int)((l)))]))+1.0));
								((sx) = ((sx)+(t3)));
								((sy) = ((sy)+(t4)));
							};
						};
						((i) = (0+(((int)(ceil((((double)(((1<<16)-0)))/((double)(1))))))*1)));
					};
					if((0==1)) {
						timer_stop(var_1, 2);
					};
				};
				((k) = (1+(((int)(ceil((((double)((((np)+1)-1)))/((double)(1))))))*1)));
			};
			{
				{
					for(int var_108 = 0; var_108 < ((10-1)+1); var_108 += 1) {
						((((((*var_1).q))[((unsigned int)((var_108)))])) = ((((((*var_1).q))[((unsigned int)((var_108)))]))+((qq[((unsigned int)((var_108)))]))));
					};
					((i) = (0+(((int)(ceil((((double)((((10-1)+1)-0)))/((double)(1))))))*1)));
				};
			};
		};
		{
			for(int var_109 = 0; var_109 < ((10-1)+1); var_109 += 1) {
				((gc) = ((gc)+(((((*var_1).q))[((unsigned int)((var_109)))]))));
			};
			((i) = (0+(((int)(ceil((((double)((((10-1)+1)-0)))/((double)(1))))))*1)));
		};
		timer_stop(var_1, 1);
		((tm) = timer_read(var_1, 1));
		((nit) = 0);
		if((25==24)) {
			if(((fabs((((sx)-(((double)(0))-3.247834652034740e3))/(sx)))<=1.0e-8)&&<?>Unhandled Type of Call Target</?>)) {
				((verified) = 1);
			};
		} else if((25==25)) {
			if(((fabs((((sx)-(((double)(0))-2.863319731645753e3))/(sx)))<=1.0e-8)&&<?>Unhandled Type of Call Target</?>)) {
				((verified) = 1);
			};
		} else if((25==28)) {
			if(((fabs((((sx)-(((double)(0))-4.295875165629892e3))/(sx)))<=1.0e-8)&&<?>Unhandled Type of Call Target</?>)) {
				((verified) = 1);
			};
		} else if((25==30)) {
			if(((fabs((((sx)-4.033815542441498e4)/(sx)))<=1.0e-8)&&<?>Unhandled Type of Call Target</?>)) {
				((verified) = 1);
			};
		} else if((25==32)) {
			if(((fabs((((sx)-4.764367927995374e4)/(sx)))<=1.0e-8)&&<?>Unhandled Type of Call Target</?>)) {
				((verified) = 1);
			};
		};
		((Mops) = ((pow(2.0, ((double)((25+1))))/(tm))/1000000.0));
		printf("EP Benchmark Results: \nCPU Time = %10.4f\nN = 2^%5d\nNo. Gaussian Pairs = %15.0f\nSums = %25.15e %25.15e\nCounts:\n", 0.0, 25, (gc), (sx), (sy));
		{
			for(int var_123 = 0; var_123 < ((10-1)+1); var_123 += 1) {
				printf("%3d %15.0f\n", (var_123), (((((*var_1).q))[((unsigned int)((var_123)))])));
			};
			((i) = (0+(((int)(ceil((((double)((((10-1)+1)-0)))/((double)(1))))))*1)));
		};
		c_print_results("EP", 'W', (25+1), 0, 0, (nit), (nthreads), (tm), (Mops), "Random numbers generated", (verified), "2.3", "03 Dec 2010", "cc", "cc", "-lm", "-I../common", "-O3 ", "-lm", "randdp");
		if((0==1)) {
			printf("Total time:     %f", timer_read(var_1, 1));
			printf("Gaussian pairs: %f", timer_read(var_1, 2));
			printf("Random numbers: %f", timer_read(var_1, 3));
		};
	}
}

