// --- Generated Inspire Code ---
#include <alloca.h>
#include <stddef.h>
#include <stdlib.h>
#include <runtime.h>
#define bool int
#define true 1
#define false 0
#define null 0
// --- Entry Point ---

// start code fragment :: type_declaration___insieme_globals //
struct __insieme_globals { 
    double(* _x)[131073];
    double* x;
    double(* q)[10];
    double(* start)[64];
    double(* elapsed)[64];
    int sec;
};

// start code fragment :: Prototype for external function: printf //
int printf(char*, ...);

// start code fragment :: Prototype for external function: sprintf //
int sprintf(char*, char*, ...);

// start code fragment :: Prototype for external function: pow //
double pow(double, double);

// start code fragment :: Prototype for external function: ceil //
double ceil(double);

// start code fragment :: Definition of vranlc //
void vranlc(int n, double* x_seed, double a, double* y) {
	{
		int i = 0;
		double x = 0.0;
		double t1 = 0.0;
		double t2 = 0.0;
		double t3 = 0.0;
		double t4 = 0.0;
		double a1 = 0.0;
		double a2 = 0.0;
		double x1 = 0.0;
		double x2 = 0.0;
		double z = 0.0;
		((t1) = (((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*a));
		((a1) = ((double)(((int)((t1))))));
		((a2) = (a-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(a1))));
		((x) = ((x_seed[0])));
		{
			for(int var_52 = 1; var_52 < (n+1); var_52 += 1) {
				((t1) = (((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*(x)));
				((x1) = ((double)(((int)((t1))))));
				((x2) = ((x)-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(x1))));
				((t1) = (((a1)*(x2))+((a2)*(x1))));
				((t2) = ((double)(((int)((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*(t1)))))));
				((z) = ((t1)-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(t2))));
				((t3) = ((((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(z))+((a2)*(x2))));
				((t4) = ((double)(((int)(((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5))*(t3)))))));
				((x) = ((t3)-((((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0))*(t4))));
				(((y[((unsigned int)((var_52)))])) = ((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5))*(x)));
			};
			((i) = (1+(((int)(ceil((((double)(((n+1)-1)))/((double)(1))))))*1)));
		};
		(((x_seed[0])) = (x));
	}
}


// start code fragment :: Definition of randlc //
double randlc(double* x, double a) {
	{
		double t1 = 0.0;
		double t2 = 0.0;
		double t3 = 0.0;
		double t4 = 0.0;
		double a1 = 0.0;
		double a2 = 0.0;
		double x1 = 0.0;
		double x2 = 0.0;
		double z = 0.0;
		((t1) = (((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*a));
		((a1) = ((double)(((int)((t1))))));
		((a2) = (a-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(a1))));
		((t1) = (((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((x[0]))));
		((x1) = ((double)(((int)((t1))))));
		((x2) = (((x[0]))-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(x1))));
		((t1) = (((a1)*(x2))+((a2)*(x1))));
		((t2) = ((double)(((int)((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*(t1)))))));
		((z) = ((t1)-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(t2))));
		((t3) = ((((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(z))+((a2)*(x2))));
		((t4) = ((double)(((int)(((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5))*(t3)))))));
		(((x[0])) = ((t3)-((((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0))*(t4))));
		return ((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5))*((x[0])));;
	}
}


// start code fragment :: Prototype for external function: log //
double log(double);

// start code fragment :: Prototype for external function: sqrt //
double sqrt(double);

// start code fragment :: Prototype for external function: fabs //
double fabs(double);

// start code fragment :: Definitions for function type: __insieme_funType_type_0 //
// Abstract prototype for lambdas of type __insieme_funType_type_0
struct __insieme_funType_type_0 { 
    void(*fun)(void*, int);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_0
void call__insieme_funType_type_0(struct __insieme_funType_type_0* lambda, int p1) { return lambda->fun(lambda, p1); }

// start code fragment :: Definitions for function type: __insieme_funType_type_1 //
// Abstract prototype for lambdas of type __insieme_funType_type_1
struct __insieme_funType_type_1 { 
    void(*fun)(void*, int);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: Definition of timer_clear //
void timer_clear(void* _capture, int n) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_70 = ((struct __insieme_funType_type_1*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		((((((((*var_70).elapsed))[0]))[((unsigned int)(n))])) = 0.0);
	}
}


// start code fragment :: Definitions for function type: __insieme_funType_type_2 //
// Abstract prototype for lambdas of type __insieme_funType_type_2
struct __insieme_funType_type_2 { 
    double(*fun)(void*);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_2
double call__insieme_funType_type_2(struct __insieme_funType_type_2* lambda) { return lambda->fun(lambda); }

// start code fragment :: Definitions for function type: __insieme_funType_type_3 //
// Abstract prototype for lambdas of type __insieme_funType_type_3
struct __insieme_funType_type_3 { 
    double(*fun)(void*);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: Definitions for function type: __insieme_funType_type_4 //
// Abstract prototype for lambdas of type __insieme_funType_type_4
struct __insieme_funType_type_4 { 
    void(*fun)(void*, double*);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_4
void call__insieme_funType_type_4(struct __insieme_funType_type_4* lambda, double* p1) { return lambda->fun(lambda, p1); }

// start code fragment :: Definitions for function type: __insieme_funType_type_5 //
// Abstract prototype for lambdas of type __insieme_funType_type_5
struct __insieme_funType_type_5 { 
    void(*fun)(void*, double*);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: type_declaration_timeval //
struct timeval { 
    long tv_sec;
    long tv_usec;
};

// start code fragment :: type_declaration_timezone //
struct timezone { 
    int tz_minuteswest;
    int tz_dsttime;
};

// start code fragment :: Prototype for external function: gettimeofday //
int gettimeofday(struct timeval*, struct timezone*);

// start code fragment :: Definition of wtime //
void wtime(void* _capture, double* t) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_77 = ((struct __insieme_funType_type_5*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		struct timeval tv;
		gettimeofday(&tv, null);
		if(((((*var_77).sec))<0)) {
			((((*var_77).sec)) = ((int)((((tv).tv_sec)))));
		};
		(((t[0])) = (((double)(((((tv).tv_sec))-((long)((((*var_77).sec)))))))+(1.0e-6*((double)((((tv).tv_usec)))))));
	}
}


// start code fragment :: Definition of elapsed_time //
double elapsed_time(void* _capture) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_74 = ((struct __insieme_funType_type_3*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		double t = 0.0;
		call__insieme_funType_type_4(((struct __insieme_funType_type_4*)(&((struct __insieme_funType_type_5){&wtime, 0, var_74}))), &t);
		return (t);;
	}
}


// start code fragment :: Definition of timer_start //
void timer_start(void* _capture, int n) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_73 = ((struct __insieme_funType_type_1*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		((((((((*var_73).start))[0]))[((unsigned int)(n))])) = call__insieme_funType_type_2(((struct __insieme_funType_type_2*)(&((struct __insieme_funType_type_3){&elapsed_time, 0, var_73})))));
	}
}


// start code fragment :: Definition of timer_stop //
void timer_stop(void* _capture, int n) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_98 = ((struct __insieme_funType_type_1*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		double t = 0.0;
		double now = 0.0;
		((now) = call__insieme_funType_type_2(((struct __insieme_funType_type_2*)(&((struct __insieme_funType_type_3){&elapsed_time, 0, var_98})))));
		((t) = ((now)-(((((((*var_98).start))[0]))[((unsigned int)(n))]))));
		((((((((*var_98).elapsed))[0]))[((unsigned int)(n))])) = ((((((((*var_98).elapsed))[0]))[((unsigned int)(n))]))+(t)));
	}
}


// start code fragment :: Definitions for function type: __insieme_funType_type_6 //
// Abstract prototype for lambdas of type __insieme_funType_type_6
struct __insieme_funType_type_6 { 
    double(*fun)(void*, int);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_6
double call__insieme_funType_type_6(struct __insieme_funType_type_6* lambda, int p1) { return lambda->fun(lambda, p1); }

// start code fragment :: Definitions for function type: __insieme_funType_type_7 //
// Abstract prototype for lambdas of type __insieme_funType_type_7
struct __insieme_funType_type_7 { 
    double(*fun)(void*, int);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: Definition of timer_read //
double timer_read(void* _capture, int n) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_111 = ((struct __insieme_funType_type_7*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		return (((((((*var_111).elapsed))[0]))[((unsigned int)(n))]));;
	}
}


// start code fragment :: Definitions for function type: __insieme_funType_type_8 //
// Abstract prototype for lambdas of type __insieme_funType_type_8
struct __insieme_funType_type_8 { 
    bool(*fun)(void*);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_8
bool call__insieme_funType_type_8(struct __insieme_funType_type_8* lambda) { return lambda->fun(lambda); }

// start code fragment :: Definitions for function type: __insieme_funType_type_9 //
// Abstract prototype for lambdas of type __insieme_funType_type_9
struct __insieme_funType_type_9 { 
    bool(*fun)(void*);
    const size_t size;
    double* p0;
};

// start code fragment :: Definition of __insieme_supp_10 //
bool __insieme_supp_10(void* _capture) {
	// --------- Captured Stuff - Begin -------------
	double* var_165 = ((struct __insieme_funType_type_9*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	return (fabs((((*var_165)-(((double)(0))-6.958407078382297e3))/(*var_165)))<=1.0e-8);
}


// start code fragment :: Definition of __insieme_supp_11 //
bool __insieme_supp_11(void* _capture) {
	// --------- Captured Stuff - Begin -------------
	double* var_167 = ((struct __insieme_funType_type_9*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	return (fabs((((*var_167)-(((double)(0))-6.320053679109499e3))/(*var_167)))<=1.0e-8);
}


// start code fragment :: Definition of __insieme_supp_12 //
bool __insieme_supp_12(void* _capture) {
	// --------- Captured Stuff - Begin -------------
	double* var_169 = ((struct __insieme_funType_type_9*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	return (fabs((((*var_169)-(((double)(0))-1.580732573678431e4))/(*var_169)))<=1.0e-8);
}


// start code fragment :: Definition of __insieme_supp_13 //
bool __insieme_supp_13(void* _capture) {
	// --------- Captured Stuff - Begin -------------
	double* var_171 = ((struct __insieme_funType_type_9*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	return (fabs((((*var_171)-(((double)(0))-2.660669192809235e4))/(*var_171)))<=1.0e-8);
}


// start code fragment :: Definition of __insieme_supp_14 //
bool __insieme_supp_14(void* _capture) {
	// --------- Captured Stuff - Begin -------------
	double* var_173 = ((struct __insieme_funType_type_9*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	return (fabs((((*var_173)-(((double)(0))-8.084072988043731e4))/(*var_173)))<=1.0e-8);
}


// start code fragment :: Definition of c_print_results //
void c_print_results(char* name, char class, int n1, int n2, int n3, int niter, int nthreads, double t, double mops, char* optype, int passed_verification, char* npbversion, char* compiletime, char* cc, char* clink, char* c_lib, char* c_inc, char* cflags, char* clinkflags, char* rand) {
	{
		char* evalue = "1000";
		printf("\n\n %s Benchmark Completed\n", name);
		printf(" Class           =                        %c\n", ((int)(class)));
		if(((n2==0)&&(n3==0))) {
			printf(" Size            =             %12d\n", n1);
		} else {
			printf(" Size            =              %3dx%3dx%3d\n", n1, n2, n3);
		};
		printf(" Iterations      =             %12d\n", niter);
		printf(" Threads         =             %12d\n", nthreads);
		printf(" Time in seconds =             %12.2f\n", 0.0);
		printf(" Mop/s total     =             %12.2f\n", 0.0);
		printf(" Operation type  = %24s\n", optype);
		if(((bool)(passed_verification))) {
			printf(" Verification    =               SUCCESSFUL\n", 0);
		} else {
			printf(" Verification    =             UNSUCCESSFUL\n", 0);
		};
		printf(" Version         =             %12s\n", npbversion);
		printf(" Compile date    =             %12s\n", compiletime);
		printf("\n Compile options:\n", 0);
		printf("    CC           = %s\n", cc);
		printf("    CLINK        = %s\n", clink);
		printf("    C_LIB        = %s\n", c_lib);
		printf("    C_INC        = %s\n", c_inc);
		printf("    CFLAGS       = %s\n", cflags);
		printf("    CLINKFLAGS   = %s\n", clinkflags);
		printf("    RAND         = %s\n", rand);
	}
}


// start code fragment :: Definition of main //
int main(int argc, char** argv) {
	{
		struct __insieme_globals var_1 = ((struct __insieme_globals){(calloc(sizeof(double[131073]), 1)),
			null,
			(calloc(sizeof(double[10]), 1)),
			(calloc(sizeof(double[64]), 1)),
			(calloc(sizeof(double[64]), 1)),
			(((int)(0))-1)
		});
		double Mops = 0.0;
		double t1 = 0.0;
		double t2 = 0.0;
		double t3 = 0.0;
		double t4 = 0.0;
		double x1 = 0.0;
		double x2 = 0.0;
		double sx = 0.0;
		double sy = 0.0;
		double tm = 0.0;
		double an = 0.0;
		double tt = 0.0;
		double gc = 0.0;
		double dum[3] = {1.0, 1.0, 1.0};
		int np = 0;
		int ierr = 0;
		int node = 0;
		int no_nodes = 0;
		int i = 0;
		int ik = 0;
		int kk = 0;
		int l = 0;
		int k = 0;
		int nit = 0;
		int ierrcode = 0;
		int no_large_nodes = 0;
		int np_add = 0;
		int k_offset = 0;
		int j = 0;
		int nthreads = 1;
		int verified = 0;
		char size[14];
		((((var_1).x)) = &((((((var_1)._x))[0]))[((unsigned int)(1))]));
		printf("\n\n NAS Parallel Benchmarks 2.3 OpenMP C version - EP Benchmark\n", 0);
		sprintf((size), "%12.0f", pow(2.0, ((double)((25+1)))));
		{
			for(int var_149 = (((int)(0))-13); var_149 < ((((int)(0))-1)+1); var_149 += 1) {
				if((((int)((((size)[((unsigned int)((((int)(0))-(var_149))))]))))=='.')) {
					((((size)[((unsigned int)((((int)(0))-(var_149))))])) = ((char)(' ')));
				};
			};
			((j) = (13+(((int)(ceil((((double)((((((int)(0))-1)+1)-13)))/((double)(1))))))*1)));
		};
		printf(" Number of random numbers generated: %13s\n", (size));
		((verified) = 0);
		((np) = (1<<(25-16)));
		vranlc(0, &((dum)[((unsigned int)(0))]), (((dum)[((unsigned int)(1))])), &((dum)[((unsigned int)(2))]));
		((((dum)[((unsigned int)(0))])) = randlc(&((dum)[((unsigned int)(1))]), (((dum)[((unsigned int)(2))]))));
		{
			for(int var_150 = 0; var_150 < (2*(1<<16)); var_150 += 1) {
				((((((var_1).x))[((unsigned int)((var_150)))])) = (((double)(0))-1.0e99));
			};
			((i) = (0+(((int)(ceil((((double)(((2*(1<<16))-0)))/((double)(1))))))*1)));
		};
		((Mops) = log(sqrt(fabs((((1.0>1.0))?(1.0):(1.0))))));
		call__insieme_funType_type_0(((struct __insieme_funType_type_0*)(&((struct __insieme_funType_type_1){&timer_clear, 0, &var_1}))), 1);
		call__insieme_funType_type_0(((struct __insieme_funType_type_0*)(&((struct __insieme_funType_type_1){&timer_clear, 0, &var_1}))), 2);
		call__insieme_funType_type_0(((struct __insieme_funType_type_0*)(&((struct __insieme_funType_type_1){&timer_clear, 0, &var_1}))), 3);
		call__insieme_funType_type_0(((struct __insieme_funType_type_0*)(&((struct __insieme_funType_type_1){&timer_start, 0, &var_1}))), 1);
		vranlc(0, &t1, 1220703125.0, (((var_1).x)));
		((t1) = 1220703125.0);
		{
			for(int var_153 = 1; var_153 < ((16+1)+1); var_153 += 1) {
				((t2) = randlc(&t1, (t1)));
			};
			((i) = (1+(((int)(ceil((((double)((((16+1)+1)-1)))/((double)(1))))))*1)));
		};
		((an) = (t1));
		((tt) = 271828183.0);
		((gc) = 0.0);
		((sx) = 0.0);
		((sy) = 0.0);
		{
			for(int var_154 = 0; var_154 < ((10-1)+1); var_154 += 1) {
				((((((((var_1).q))[0]))[((unsigned int)((var_154)))])) = 0.0);
			};
			((i) = (0+(((int)(ceil((((double)((((10-1)+1)-0)))/((double)(1))))))*1)));
		};
		((k_offset) = (((int)(0))-1));
		{
			double t1 = 0.0;
			double t2 = 0.0;
			double t3 = 0.0;
			double t4 = 0.0;
			double x1 = 0.0;
			double x2 = 0.0;
			int kk = 0;
			int i = 0;
			int ik = 0;
			int l = 0;
			double qq[10];
			{
				for(int var_155 = 0; var_155 < 10; var_155 += 1) {
					((((qq)[((unsigned int)((var_155)))])) = 0.0);
				};
				((i) = (0+(((int)(ceil((((double)((10-0)))/((double)(1))))))*1)));
			};
			{
				for(int var_162 = 1; var_162 < ((np)+1); var_162 += 1) {
					((kk) = ((k_offset)+(var_162)));
					((t1) = 271828183.0);
					((t2) = (an));
					{
						for(int var_156 = 1; var_156 < (100+1); var_156 += 1) {
							((ik) = ((kk)/2));
							if(((2*(ik))!=(kk))) {
								((t3) = randlc(&t1, (t2)));
							};
							if(((ik)==0)) break;
							((t3) = randlc(&t2, (t2)));
							((kk) = (ik));
						};
						((i) = (1+(((int)(ceil((((double)(((100+1)-1)))/((double)(1))))))*1)));
					};
					if((0==1)) {
						call__insieme_funType_type_0(((struct __insieme_funType_type_0*)(&((struct __insieme_funType_type_1){&timer_start, 0, &var_1}))), 3);
					};
					vranlc((2*(1<<16)), &t1, 1220703125.0, (((((var_1)._x))[0])));
					if((0==1)) {
						call__insieme_funType_type_0(((struct __insieme_funType_type_0*)(&((struct __insieme_funType_type_1){&timer_stop, 0, &var_1}))), 3);
					};
					if((0==1)) {
						call__insieme_funType_type_0(((struct __insieme_funType_type_0*)(&((struct __insieme_funType_type_1){&timer_start, 0, &var_1}))), 2);
					};
					{
						for(int var_161 = 0; var_161 < (1<<16); var_161 += 1) {
							((x1) = ((2.0*(((((var_1).x))[((unsigned int)((2*(var_161))))])))-1.0));
							((x2) = ((2.0*(((((var_1).x))[((unsigned int)(((2*(var_161))+1)))])))-1.0));
							((t1) = (((x1)*(x1))+((x2)*(x2))));
							if(((t1)<=1.0)) {
								((t2) = sqrt((((((double)(0))-2.0)*log((t1)))/(t1))));
								((t3) = ((x1)*(t2)));
								((t4) = ((x2)*(t2)));
								((l) = ((int)((((fabs((t3))>fabs((t4))))?(fabs((t3))):(fabs((t4)))))));
								((((qq)[((unsigned int)((l)))])) = ((((qq)[((unsigned int)((l)))]))+1.0));
								((sx) = ((sx)+(t3)));
								((sy) = ((sy)+(t4)));
							};
						};
						((i) = (0+(((int)(ceil((((double)(((1<<16)-0)))/((double)(1))))))*1)));
					};
					if((0==1)) {
						call__insieme_funType_type_0(((struct __insieme_funType_type_0*)(&((struct __insieme_funType_type_1){&timer_stop, 0, &var_1}))), 2);
					};
				};
				((k) = (1+(((int)(ceil((((double)((((np)+1)-1)))/((double)(1))))))*1)));
			};
			{
				{
					for(int var_163 = 0; var_163 < ((10-1)+1); var_163 += 1) {
						((((((((var_1).q))[0]))[((unsigned int)((var_163)))])) = ((((((((var_1).q))[0]))[((unsigned int)((var_163)))]))+(((qq)[((unsigned int)((var_163)))]))));
					};
					((i) = (0+(((int)(ceil((((double)((((10-1)+1)-0)))/((double)(1))))))*1)));
				};
			};
		};
		{
			for(int var_164 = 0; var_164 < ((10-1)+1); var_164 += 1) {
				((gc) = ((gc)+(((((((var_1).q))[0]))[((unsigned int)((var_164)))]))));
			};
			((i) = (0+(((int)(ceil((((double)((((10-1)+1)-0)))/((double)(1))))))*1)));
		};
		call__insieme_funType_type_0(((struct __insieme_funType_type_0*)(&((struct __insieme_funType_type_1){&timer_stop, 0, &var_1}))), 1);
		((tm) = call__insieme_funType_type_6(((struct __insieme_funType_type_6*)(&((struct __insieme_funType_type_7){&timer_read, 0, &var_1}))), 1));
		((nit) = 0);
		if((25==24)) {
			if(((fabs((((sx)-(((double)(0))-3.247834652034740e3))/(sx)))<=1.0e-8)&&call__insieme_funType_type_8(((struct __insieme_funType_type_8*)(&((struct __insieme_funType_type_9){&__insieme_supp_10, 0, &sy})))))) {
				((verified) = 1);
			};
		} else if((25==25)) {
			if(((fabs((((sx)-(((double)(0))-2.863319731645753e3))/(sx)))<=1.0e-8)&&call__insieme_funType_type_8(((struct __insieme_funType_type_8*)(&((struct __insieme_funType_type_9){&__insieme_supp_11, 0, &sy})))))) {
				((verified) = 1);
			};
		} else if((25==28)) {
			if(((fabs((((sx)-(((double)(0))-4.295875165629892e3))/(sx)))<=1.0e-8)&&call__insieme_funType_type_8(((struct __insieme_funType_type_8*)(&((struct __insieme_funType_type_9){&__insieme_supp_12, 0, &sy})))))) {
				((verified) = 1);
			};
		} else if((25==30)) {
			if(((fabs((((sx)-4.033815542441498e4)/(sx)))<=1.0e-8)&&call__insieme_funType_type_8(((struct __insieme_funType_type_8*)(&((struct __insieme_funType_type_9){&__insieme_supp_13, 0, &sy})))))) {
				((verified) = 1);
			};
		} else if((25==32)) {
			if(((fabs((((sx)-4.764367927995374e4)/(sx)))<=1.0e-8)&&call__insieme_funType_type_8(((struct __insieme_funType_type_8*)(&((struct __insieme_funType_type_9){&__insieme_supp_14, 0, &sy})))))) {
				((verified) = 1);
			};
		};
		((Mops) = ((pow(2.0, ((double)((25+1))))/(tm))/1000000.0));
		printf("EP Benchmark Results: \nCPU Time = %10.4f\nN = 2^%5d\nNo. Gaussian Pairs = %15.0f\nSums = %25.15e %25.15e\nCounts:\n", 0.0, 25, (gc), (sx), (sy));
		{
			for(int var_175 = 0; var_175 < ((10-1)+1); var_175 += 1) {
				printf("%3d %15.0f\n", (var_175), (((((((var_1).q))[0]))[((unsigned int)((var_175)))])));
			};
			((i) = (0+(((int)(ceil((((double)((((10-1)+1)-0)))/((double)(1))))))*1)));
		};
		c_print_results("EP", ((char)('W')), (25+1), 0, 0, (nit), (nthreads), (tm), (Mops), "Random numbers generated", (verified), "2.3", "03 Dec 2010", "cc", "cc", "-lm", "-I../common", "-O3 ", "-lm", "randdp");
		if((0==1)) {
			printf("Total time:     %f", call__insieme_funType_type_6(((struct __insieme_funType_type_6*)(&((struct __insieme_funType_type_7){&timer_read, 0, &var_1}))), 1));
			printf("Gaussian pairs: %f", call__insieme_funType_type_6(((struct __insieme_funType_type_6*)(&((struct __insieme_funType_type_7){&timer_read, 0, &var_1}))), 2));
			printf("Random numbers: %f", call__insieme_funType_type_6(((struct __insieme_funType_type_6*)(&((struct __insieme_funType_type_7){&timer_read, 0, &var_1}))), 3));
		};
	}
}

