// --- Generated Inspire Code ---
#include <alloca.h>
#include <stddef.h>
#include <runtime.h>
#define bool int
#define true 1
#define false 0
#define null 0

// start code fragment :: vector_type_declaration of __insieme_type_1 <=> vector<real<8>,131073> //
typedef struct ___insieme_type_1 { 
    double data[131073];
} __insieme_type_1;

// A constructor initializing a vector of the type __insieme_type_1 uniformly
static inline __insieme_type_1 __insieme_type_1_init_uniform(double value) {
	__insieme_type_1 res;
	for (int i=0; i<131073;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_2 <=> vector<real<8>,10> //
typedef struct ___insieme_type_2 { 
    double data[10];
} __insieme_type_2;

// A constructor initializing a vector of the type __insieme_type_2 uniformly
static inline __insieme_type_2 __insieme_type_2_init_uniform(double value) {
	__insieme_type_2 res;
	for (int i=0; i<10;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_3 <=> vector<real<8>,64> //
typedef struct ___insieme_type_3 { 
    double data[64];
} __insieme_type_3;

// A constructor initializing a vector of the type __insieme_type_3 uniformly
static inline __insieme_type_3 __insieme_type_3_init_uniform(double value) {
	__insieme_type_3 res;
	for (int i=0; i<64;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: type_declaration___insieme_globals //
struct __insieme_globals { 
    __insieme_type_1 _x;
    double* x;
    __insieme_type_2 q;
    __insieme_type_3 start;
    __insieme_type_3 elapsed;
    int sec;
};

// start code fragment :: vector_type_declaration of __insieme_type_4 <=> vector<real<8>,3> //
typedef struct ___insieme_type_4 { 
    double data[3];
} __insieme_type_4;

// A constructor initializing a vector of the type __insieme_type_4 uniformly
static inline __insieme_type_4 __insieme_type_4_init_uniform(double value) {
	__insieme_type_4 res;
	for (int i=0; i<3;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_5 <=> vector<char,14> //
typedef struct ___insieme_type_5 { 
    char data[14];
} __insieme_type_5;

// A constructor initializing a vector of the type __insieme_type_5 uniformly
static inline __insieme_type_5 __insieme_type_5_init_uniform(char value) {
	__insieme_type_5 res;
	for (int i=0; i<14;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: Prototype for external function: printf ... type: ((ref<array<char,1>>,var_list)->int<4>) //
int printf(char*, ...);

// start code fragment :: Prototype for external function: sprintf ... type: ((ref<array<char,1>>,ref<array<char,1>>,var_list)->int<4>) //
int sprintf(char*, char*, ...);

// start code fragment :: Prototype for external function: pow ... type: ((real<8>,real<8>)->real<8>) //
double pow(double, double);
static double pow_wrap(void* _closure, double var_165, double var_166) { return pow(var_165, var_166); }

// start code fragment :: Prototype for external function: ceil ... type: ((real<8>)->real<8>) //
double ceil(double);
static double ceil_wrap(void* _closure, double var_167) { return ceil(var_167); }

// start code fragment :: Definition of vranlc ... type: ((int<4>,ref<array<real<8>,1>>,real<8>,ref<array<real<8>,1>>)->unit) //
void vranlc(int n, double* x_seed, double a, double* y){
	int i = 0;
	double x = 0.0;
	double t1 = 0.0;
	double t2 = 0.0;
	double t3 = 0.0;
	double t4 = 0.0;
	double a1 = 0.0;
	double a2 = 0.0;
	double x1 = 0.0;
	double x2 = 0.0;
	double z = 0.0;
	((t1) = (((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*a));
	((a1) = ((double)(((int)((t1))))));
	((a2) = (a-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(a1))));
	((x) = ((x_seed[0])));
	{
		for(int var_75 = 1; var_75 < (n+1); var_75 += 1) {
			((t1) = (((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*(x)));
			((x1) = ((double)(((int)((t1))))));
			((x2) = ((x)-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(x1))));
			((t1) = (((a1)*(x2))+((a2)*(x1))));
			((t2) = ((double)(((int)((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*(t1)))))));
			((z) = ((t1)-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(t2))));
			((t3) = ((((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(z))+((a2)*(x2))));
			((t4) = ((double)(((int)(((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5))*(t3)))))));
			((x) = ((t3)-((((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0))*(t4))));
			(((y[((unsigned int)(var_75))])) = ((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5))*(x)));
		};
		((i) = (1+(((int)(ceil((((double)(((n+1)-1)))/((double)(1))))))*1)));
	};
	(((x_seed[0])) = (x));
}
static void vranlc_wrap(void* _closure, int n, double* x_seed, double a, double* y) { vranlc(n, x_seed, a, y); }

// start code fragment :: Definition of randlc ... type: ((ref<array<real<8>,1>>,real<8>)->real<8>) //
double randlc(double* x, double a){
	double t1 = 0.0;
	double t2 = 0.0;
	double t3 = 0.0;
	double t4 = 0.0;
	double a1 = 0.0;
	double a2 = 0.0;
	double x1 = 0.0;
	double x2 = 0.0;
	double z = 0.0;
	((t1) = (((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*a));
	((a1) = ((double)(((int)((t1))))));
	((a2) = (a-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(a1))));
	((t1) = (((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((x[0]))));
	((x1) = ((double)(((int)((t1))))));
	((x2) = (((x[0]))-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(x1))));
	((t1) = (((a1)*(x2))+((a2)*(x1))));
	((t2) = ((double)(((int)((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*(t1)))))));
	((z) = ((t1)-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(t2))));
	((t3) = ((((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(z))+((a2)*(x2))));
	((t4) = ((double)(((int)(((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5))*(t3)))))));
	(((x[0])) = ((t3)-((((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0))*(t4))));
	return ((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5))*((x[0])));
}
static double randlc_wrap(void* _closure, double* x, double a) { return randlc(x, a); }

// start code fragment :: Prototype for external function: log ... type: ((real<8>)->real<8>) //
double log(double);
static double log_wrap(void* _closure, double var_168) { return log(var_168); }

// start code fragment :: Prototype for external function: sqrt ... type: ((real<8>)->real<8>) //
double sqrt(double);
static double sqrt_wrap(void* _closure, double var_169) { return sqrt(var_169); }

// start code fragment :: Prototype for external function: fabs ... type: ((real<8>)->real<8>) //
double fabs(double);
static double fabs_wrap(void* _closure, double var_170) { return fabs(var_170); }

// start code fragment :: Definition of timer_clear ... type: ((ref<struct<_x:vector<real<8>,131073>,x:ref<array<real<8>,1>>,q:vector<real<8>,10>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,int<4>)->unit) //
void timer_clear(struct __insieme_globals* var_26, int n) { ((((*(&((*var_26).elapsed))).data[((unsigned int)(n))])) = 0.0); }
static void timer_clear_wrap(void* _closure, struct __insieme_globals* var_26, int n) { timer_clear(var_26, n); }

// start code fragment :: type_declaration_timeval //
struct timeval { 
    long tv_sec;
    long tv_usec;
};

// start code fragment :: type_declaration_timezone //
struct timezone { 
    int tz_minuteswest;
    int tz_dsttime;
};

// start code fragment :: Prototype for external function: gettimeofday ... type: ((ref<array<struct<tv_sec:int<8>,tv_usec:int<8>>,1>>,ref<array<struct<tz_minuteswest:int<4>,tz_dsttime:int<4>>,1>>)->int<4>) //
int gettimeofday(struct timeval*, struct timezone*);
static int gettimeofday_wrap(void* _closure, struct timeval* var_171, struct timezone* var_172) { return gettimeofday(var_171, var_172); }

// start code fragment :: Definition of wtime ... type: ((ref<struct<_x:vector<real<8>,131073>,x:ref<array<real<8>,1>>,q:vector<real<8>,10>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,ref<array<real<8>,1>>)->unit) //
void wtime(struct __insieme_globals* var_29, double* t){
	struct timeval tv;
	gettimeofday((&tv), 0);
	if(((*(&((*var_29).sec)))<0)) { ((*(&((*var_29).sec))) = ((int)((*(&((tv).tv_sec)))))); };
	(((t[0])) = (((double)(((*(&((tv).tv_sec)))-((long)((*(&((*var_29).sec))))))))+(1.0e-6*((double)((*(&((tv).tv_usec))))))));
}
static void wtime_wrap(void* _closure, struct __insieme_globals* var_29, double* t) { wtime(var_29, t); }

// start code fragment :: Definition of elapsed_time ... type: ((ref<struct<_x:vector<real<8>,131073>,x:ref<array<real<8>,1>>,q:vector<real<8>,10>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>)->real<8>) //
double elapsed_time(struct __insieme_globals* var_33){
	double t = 0.0;
	wtime(var_33, (&t));
	return (t);
}
static double elapsed_time_wrap(void* _closure, struct __insieme_globals* var_33) { return elapsed_time(var_33); }

// start code fragment :: Definition of timer_start ... type: ((ref<struct<_x:vector<real<8>,131073>,x:ref<array<real<8>,1>>,q:vector<real<8>,10>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,int<4>)->unit) //
void timer_start(struct __insieme_globals* var_36, int n) { ((((*(&((*var_36).start))).data[((unsigned int)(n))])) = elapsed_time(var_36)); }
static void timer_start_wrap(void* _closure, struct __insieme_globals* var_36, int n) { timer_start(var_36, n); }

// start code fragment :: Definition of timer_stop ... type: ((ref<struct<_x:vector<real<8>,131073>,x:ref<array<real<8>,1>>,q:vector<real<8>,10>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,int<4>)->unit) //
void timer_stop(struct __insieme_globals* var_39, int n){
	double t = 0.0;
	double now = 0.0;
	((now) = elapsed_time(var_39));
	((t) = ((now)-(((*(&((*var_39).start))).data[((unsigned int)(n))]))));
	((((*(&((*var_39).elapsed))).data[((unsigned int)(n))])) = ((((*(&((*var_39).elapsed))).data[((unsigned int)(n))]))+(t)));
}
static void timer_stop_wrap(void* _closure, struct __insieme_globals* var_39, int n) { timer_stop(var_39, n); }

// start code fragment :: Definition of timer_read ... type: ((ref<struct<_x:vector<real<8>,131073>,x:ref<array<real<8>,1>>,q:vector<real<8>,10>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,int<4>)->real<8>) //
double timer_read(struct __insieme_globals* var_44, int n) { return (((*(&((*var_44).elapsed))).data[((unsigned int)(n))])); }
static double timer_read_wrap(void* _closure, struct __insieme_globals* var_44, int n) { return timer_read(var_44, n); }

// start code fragment :: Definition of c_print_results ... type: ((ref<array<char,1>>,char,int<4>,int<4>,int<4>,int<4>,int<4>,real<8>,real<8>,ref<array<char,1>>,int<4>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>)->unit) //
void c_print_results(char* name, char class, int n1, int n2, int n3, int niter, int nthreads, double t, double mops, char* optype, int passed_verification, char* npbversion, char* compiletime, char* cc, char* clink, char* c_lib, char* c_inc, char* cflags, char* clinkflags, char* rand){
	char* evalue = "1000";
	printf("\n\n %s Benchmark Completed\n", name);
	printf(" Class           =                        %c\n", ((int)(class)));
	if(((n2==0)&&(n3==0))) { printf(" Size            =             %12d\n", n1); } else  { printf(" Size            =              %3dx%3dx%3d\n", n1, n2, n3); };
	printf(" Iterations      =             %12d\n", niter);
	printf(" Threads         =             %12d\n", nthreads);
	printf(" Time in seconds =             %12.2f\n", 0.0);
	printf(" Mop/s total     =             %12.2f\n", 0.0);
	printf(" Operation type  = %24s\n", optype);
	if((passed_verification!=0)) { printf(" Verification    =               SUCCESSFUL\n", 0); } else  { printf(" Verification    =             UNSUCCESSFUL\n", 0); };
	printf(" Version         =             %12s\n", npbversion);
	printf(" Compile date    =             %12s\n", compiletime);
	printf("\n Compile options:\n", 0);
	printf("    CC           = %s\n", cc);
	printf("    CLINK        = %s\n", clink);
	printf("    C_LIB        = %s\n", c_lib);
	printf("    C_INC        = %s\n", c_inc);
	printf("    CFLAGS       = %s\n", cflags);
	printf("    CLINKFLAGS   = %s\n", clinkflags);
	printf("    RAND         = %s\n", rand);
}
static void c_print_results_wrap(void* _closure, char* name, char class, int n1, int n2, int n3, int niter, int nthreads, double t, double mops, char* optype, int passed_verification, char* npbversion, char* compiletime, char* cc, char* clink, char* c_lib, char* c_inc, char* cflags, char* clinkflags, char* rand) { c_print_results(name, class, n1, n2, n3, niter, nthreads, t, mops, optype, passed_verification, npbversion, compiletime, cc, clink, c_lib, c_inc, cflags, clinkflags, rand); }

// start code fragment :: Definition of main ... type: ((int<4>,ref<array<ref<array<char,1>>,1>>)->int<4>) //
int main(int argc, char** argv){
	struct __insieme_globals* var_1 = malloc(sizeof(struct __insieme_globals));
	((*(&((*var_1).x))) = 0);
	((*(&((*var_1).sec))) = (((int)(0))-1));
	double Mops = 0.0;
	double t1 = 0.0;
	double t2 = 0.0;
	double t3 = 0.0;
	double t4 = 0.0;
	double x1 = 0.0;
	double x2 = 0.0;
	double sx = 0.0;
	double sy = 0.0;
	double tm = 0.0;
	double an = 0.0;
	double tt = 0.0;
	double gc = 0.0;
	__insieme_type_4 dum = ((__insieme_type_4){{1.0, 1.0, 1.0}});
	int np = 0;
	int ierr = 0;
	int node = 0;
	int no_nodes = 0;
	int i = 0;
	int ik = 0;
	int kk = 0;
	int l = 0;
	int k = 0;
	int nit = 0;
	int ierrcode = 0;
	int no_large_nodes = 0;
	int np_add = 0;
	int k_offset = 0;
	int j = 0;
	int nthreads = 1;
	int verified = 0;
	__insieme_type_5 size;
	((*(&((*var_1).x))) = (&((*(&((*var_1)._x))).data[((unsigned int)(1))])));
	printf("\n\n NAS Parallel Benchmarks 2.3 OpenMP C version - EP Benchmark\n", 0);
	sprintf((((char*){(size).data})), "%12.0f", pow(2.0, ((double)((25+1)))));
	{
		for(int var_112 = (((int)(0))-13); var_112 < ((((int)(0))-1)+1); var_112 += 1)  { if((((int)((((size).data[((unsigned int)((((int)(0))-var_112)))]))))==46)) { ((((size).data[((unsigned int)((((int)(0))-var_112)))])) = ' '); }; };
		((j) = (13+(((int)(ceil((((double)((((((int)(0))-1)+1)-13)))/((double)(1))))))*1)));
	};
	printf(" Number of random numbers generated: %13s\n", ((size)).data);
	((verified) = 0);
	((np) = (1<<(25-16)));
	vranlc(0, (&((dum).data[((unsigned int)(0))])), (((dum).data[((unsigned int)(1))])), (&((dum).data[((unsigned int)(2))])));
	((((dum).data[((unsigned int)(0))])) = randlc((&((dum).data[((unsigned int)(1))])), (((dum).data[((unsigned int)(2))]))));
	{
		for(int var_114 = 0; var_114 < (2*(1<<16)); var_114 += 1)  { ((((*(&((*var_1).x)))[((unsigned int)(var_114))])) = (((double)(0))-1.0e99)); };
		((i) = (0+(((int)(ceil((((double)(((2*(1<<16))-0)))/((double)(1))))))*1)));
	};
	((Mops) = log(sqrt(fabs((((1.0>1.0))?(1.0):(1.0))))));
	timer_clear(var_1, 1);
	timer_clear(var_1, 2);
	timer_clear(var_1, 3);
	timer_start(var_1, 1);
	vranlc(0, (&t1), 1220703125.0, (*(&((*var_1).x))));
	((t1) = 1220703125.0);
	{
		for(int var_118 = 1; var_118 < ((16+1)+1); var_118 += 1)  { ((t2) = randlc((&t1), (t1))); };
		((i) = (1+(((int)(ceil((((double)((((16+1)+1)-1)))/((double)(1))))))*1)));
	};
	((an) = (t1));
	((tt) = 271828183.0);
	((gc) = 0.0);
	((sx) = 0.0);
	((sy) = 0.0);
	{
		for(int var_120 = 0; var_120 < ((10-1)+1); var_120 += 1)  { ((((*(&((*var_1).q))).data[((unsigned int)(var_120))])) = 0.0); };
		((i) = (0+(((int)(ceil((((double)((((10-1)+1)-0)))/((double)(1))))))*1)));
	};
	((k_offset) = (((int)(0))-1));
	{
		double t1 = 0.0;
		double t2 = 0.0;
		double t3 = 0.0;
		double t4 = 0.0;
		double x1 = 0.0;
		double x2 = 0.0;
		int kk = 0;
		int i = 0;
		int ik = 0;
		int l = 0;
		__insieme_type_2 qq;
		{
			for(int var_133 = 0; var_133 < 10; var_133 += 1)  { ((((qq).data[((unsigned int)(var_133))])) = 0.0); };
			((i) = (0+(((int)(ceil((((double)((10-0)))/((double)(1))))))*1)));
		};
		{
			for(int var_147 = 1; var_147 < ((np)+1); var_147 += 1) {
				((kk) = ((k_offset)+var_147));
				((t1) = 271828183.0);
				((t2) = (an));
				{
					for(int var_135 = 1; var_135 < (100+1); var_135 += 1) {
						((ik) = ((kk)/2));
						if(((2*(ik))!=(kk))) { ((t3) = randlc((&t1), (t2))); };
						if(((ik)==0)) { break; };
						((t3) = randlc((&t2), (t2)));
						((kk) = (ik));
					};
					((i) = (1+(((int)(ceil((((double)(((100+1)-1)))/((double)(1))))))*1)));
				};
				if((0==1)) { timer_start(var_1, 3); };
				vranlc((2*(1<<16)), (&t1), 1220703125.0, (((double*){(*(&((*var_1)._x))).data})));
				if((0==1)) { timer_stop(var_1, 3); };
				if((0==1)) { timer_start(var_1, 2); };
				{
					for(int var_145 = 0; var_145 < (1<<16); var_145 += 1) {
						((x1) = ((2.0*(((*(&((*var_1).x)))[((unsigned int)((2*var_145)))])))-1.0));
						((x2) = ((2.0*(((*(&((*var_1).x)))[((unsigned int)(((2*var_145)+1)))])))-1.0));
						((t1) = (((x1)*(x1))+((x2)*(x2))));
						if(((t1)<=1.0)){
							((t2) = sqrt((((((double)(0))-2.0)*log((t1)))/(t1))));
							((t3) = ((x1)*(t2)));
							((t4) = ((x2)*(t2)));
							((l) = ((int)((((fabs((t3))>fabs((t4))))?(fabs((t3))):(fabs((t4)))))));
							((((qq).data[((unsigned int)((l)))])) = ((((qq).data[((unsigned int)((l)))]))+1.0));
							((sx) = ((sx)+(t3)));
							((sy) = ((sy)+(t4)));
						};
					};
					((i) = (0+(((int)(ceil((((double)(((1<<16)-0)))/((double)(1))))))*1)));
				};
				if((0==1)) { timer_stop(var_1, 2); };
			};
			((k) = (1+(((int)(ceil((((double)((((np)+1)-1)))/((double)(1))))))*1)));
		};
		 { {
			for(int var_149 = 0; var_149 < ((10-1)+1); var_149 += 1)  { ((((*(&((*var_1).q))).data[((unsigned int)(var_149))])) = ((((*(&((*var_1).q))).data[((unsigned int)(var_149))]))+(((qq).data[((unsigned int)(var_149))])))); };
			((i) = (0+(((int)(ceil((((double)((((10-1)+1)-0)))/((double)(1))))))*1)));
		}; };
	};
	{
		for(int var_151 = 0; var_151 < ((10-1)+1); var_151 += 1)  { ((gc) = ((gc)+(((*(&((*var_1).q))).data[((unsigned int)(var_151))])))); };
		((i) = (0+(((int)(ceil((((double)((((10-1)+1)-0)))/((double)(1))))))*1)));
	};
	timer_stop(var_1, 1);
	((tm) = timer_read(var_1, 1));
	((nit) = 0);
	if((25==24)) { if(((fabs((((sx)-(((double)(0))-3.247834652034740e3))/(sx)))<=1.0e-8)&&(fabs((((sy)-(((double)(0))-6.958407078382297e3))/(sy)))<=1.0e-8))) { ((verified) = 1); }; } else  { if((25==25)) { if(((fabs((((sx)-(((double)(0))-2.863319731645753e3))/(sx)))<=1.0e-8)&&(fabs((((sy)-(((double)(0))-6.320053679109499e3))/(sy)))<=1.0e-8))) { ((verified) = 1); }; } else  { if((25==28)) { if(((fabs((((sx)-(((double)(0))-4.295875165629892e3))/(sx)))<=1.0e-8)&&(fabs((((sy)-(((double)(0))-1.580732573678431e4))/(sy)))<=1.0e-8))) { ((verified) = 1); }; } else  { if((25==30)) { if(((fabs((((sx)-4.033815542441498e4)/(sx)))<=1.0e-8)&&(fabs((((sy)-(((double)(0))-2.660669192809235e4))/(sy)))<=1.0e-8))) { ((verified) = 1); }; } else  { if((25==32)) { if(((fabs((((sx)-4.764367927995374e4)/(sx)))<=1.0e-8)&&(fabs((((sy)-(((double)(0))-8.084072988043731e4))/(sy)))<=1.0e-8))) { ((verified) = 1); }; }; }; }; }; };
	((Mops) = ((pow(2.0, ((double)((25+1))))/(tm))/1000000.0));
	printf("EP Benchmark Results: \nCPU Time = %10.4f\nN = 2^%5d\nNo. Gaussian Pairs = %15.0f\nSums = %25.15e %25.15e\nCounts:\n", 0.0, 25, (gc), (sx), (sy));
	{
		for(int var_163 = 0; var_163 < ((10-1)+1); var_163 += 1)  { printf("%3d %15.0f\n", var_163, (((*(&((*var_1).q))).data[((unsigned int)(var_163))]))); };
		((i) = (0+(((int)(ceil((((double)((((10-1)+1)-0)))/((double)(1))))))*1)));
	};
	c_print_results("EP", 'W', (25+1), 0, 0, (nit), (nthreads), (tm), (Mops), "Random numbers generated", (verified), "2.3", "03 Dec 2010", "cc", "cc", "-lm", "-I../common", "-O3 ", "-lm", "randdp");
	if((0==1)){
		printf("Total time:     %f", timer_read(var_1, 1));
		printf("Gaussian pairs: %f", timer_read(var_1, 2));
		printf("Random numbers: %f", timer_read(var_1, 3));
	};
}
static int main_wrap(void* _closure, int argc, char** argv) { return main(argc, argv); }
