// --- Generated Inspire Code ---
#include <alloca.h>
#include <stddef.h>
#include <stdlib.h>
#include <runtime.h>
#define bool int
#define true 1
#define false 0
#define null 0

// start code fragment :: array type definition of __insieme_type_1 <=> array<char,1> //
typedef struct ___insieme_type_1 { 
    char* data;
    unsigned size[1];
} __insieme_type_1;

// start code fragment :: array type definition of __insieme_type_0 <=> array<array<char,1>,1> //
typedef struct ___insieme_type_0 { 
    __insieme_type_1* data;
    unsigned size[1];
} __insieme_type_0;

// start code fragment :: Prototype for external function: strlen ... type: ((ref<array<char,1>>)->uint<8>) //
unsigned long strlen(char*);
static unsigned long strlen_wrap(void* _closure, __insieme_type_1* var_149) { return strlen(((char*)((*(var_149)).data))); }

// start code fragment :: vector_type_declaration of __insieme_type_3 <=> vector<real<8>,131073> //
typedef struct ___insieme_type_3 { 
    double data[131073];
} __insieme_type_3;

// A constructor initializing a vector of the type __insieme_type_3 uniformly
static inline __insieme_type_3 __insieme_type_3_init_uniform(double value) {
	__insieme_type_3 res;
	for (int i=0; i<131073;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: array type definition of __insieme_type_4 <=> array<real<8>,1> //
typedef struct ___insieme_type_4 { 
    double* data;
    unsigned size[1];
} __insieme_type_4;

// start code fragment :: vector_type_declaration of __insieme_type_5 <=> vector<real<8>,10> //
typedef struct ___insieme_type_5 { 
    double data[10];
} __insieme_type_5;

// A constructor initializing a vector of the type __insieme_type_5 uniformly
static inline __insieme_type_5 __insieme_type_5_init_uniform(double value) {
	__insieme_type_5 res;
	for (int i=0; i<10;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_6 <=> vector<real<8>,64> //
typedef struct ___insieme_type_6 { 
    double data[64];
} __insieme_type_6;

// A constructor initializing a vector of the type __insieme_type_6 uniformly
static inline __insieme_type_6 __insieme_type_6_init_uniform(double value) {
	__insieme_type_6 res;
	for (int i=0; i<64;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: type_declaration___insieme_globals //
struct __insieme_globals { 
    __insieme_type_3 _x;
    __insieme_type_4 x;
    __insieme_type_5 q;
    __insieme_type_6 start;
    __insieme_type_6 elapsed;
    int sec;
};

// start code fragment :: vector_type_declaration of __insieme_type_9 <=> vector<real<8>,3> //
typedef struct ___insieme_type_9 { 
    double data[3];
} __insieme_type_9;

// A constructor initializing a vector of the type __insieme_type_9 uniformly
static inline __insieme_type_9 __insieme_type_9_init_uniform(double value) {
	__insieme_type_9 res;
	for (int i=0; i<3;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_12 <=> vector<char,14> //
typedef struct ___insieme_type_12 { 
    char data[14];
} __insieme_type_12;

// A constructor initializing a vector of the type __insieme_type_12 uniformly
static inline __insieme_type_12 __insieme_type_12_init_uniform(char value) {
	__insieme_type_12 res;
	for (int i=0; i<14;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: Prototype for external function: printf ... type: ((ref<array<char,1>>,var_list)->int<4>) //
int printf(char*, ...);

// start code fragment :: Prototype for external function: sprintf ... type: ((ref<array<char,1>>,ref<array<char,1>>,var_list)->int<4>) //
int sprintf(char*, char*, ...);

// start code fragment :: Prototype for external function: pow ... type: ((real<8>,real<8>)->real<8>) //
double pow(double, double);
static double pow_wrap(void* _closure, double var_150, double var_151) { return pow(var_150, var_151); }

// start code fragment :: Prototype for external function: ceil ... type: ((real<8>)->real<8>) //
double ceil(double);
static double ceil_wrap(void* _closure, double var_152) { return ceil(var_152); }

// start code fragment :: Definition of vranlc ... type: ((int<4>,ref<array<real<8>,1>>,real<8>,ref<array<real<8>,1>>)->unit) //
void vranlc(int n, __insieme_type_4* x_seed, double a, __insieme_type_4* y){
	int i = 0;
	double x = 0.0;
	double t1 = 0.0;
	double t2 = 0.0;
	double t3 = 0.0;
	double t4 = 0.0;
	double a1 = 0.0;
	double a2 = 0.0;
	double x1 = 0.0;
	double x2 = 0.0;
	double z = 0.0;
	((t1) = (((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*a));
	((a1) = ((double)(((int)(t1)))));
	((a2) = (a-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(a1))));
	((x) = (((*x_seed).data[0])));
	{
		for(int var_52 = 1; var_52 < (n+1); var_52 += 1) {
			((t1) = (((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*(x)));
			((x1) = ((double)(((int)(t1)))));
			((x2) = ((x)-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(x1))));
			((t1) = (((a1)*(x2))+((a2)*(x1))));
			((t2) = ((double)(((int)((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*(t1)))))));
			((z) = ((t1)-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(t2))));
			((t3) = ((((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(z))+((a2)*(x2))));
			((t4) = ((double)(((int)(((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5))*(t3)))))));
			((x) = ((t3)-((((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0))*(t4))));
			((((*y).data[((unsigned int)((var_52)))])) = ((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5))*(x)));
		};
		((i) = (1+(((int)(ceil((((double)(((n+1)-1)))/((double)(1))))))*1)));
	};
	((((*x_seed).data[0])) = (x));
}
static void vranlc_wrap(void* _closure, int n, __insieme_type_4* x_seed, double a, __insieme_type_4* y) { vranlc(n, x_seed, a, y); }

// start code fragment :: Definition of randlc ... type: ((ref<array<real<8>,1>>,real<8>)->real<8>) //
double randlc(__insieme_type_4* x, double a){
	double t1 = 0.0;
	double t2 = 0.0;
	double t3 = 0.0;
	double t4 = 0.0;
	double a1 = 0.0;
	double a2 = 0.0;
	double x1 = 0.0;
	double x2 = 0.0;
	double z = 0.0;
	((t1) = (((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*a));
	((a1) = ((double)(((int)(t1)))));
	((a2) = (a-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(a1))));
	((t1) = (((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*(((*x).data[0]))));
	((x1) = ((double)(((int)(t1)))));
	((x2) = ((((*x).data[0]))-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(x1))));
	((t1) = (((a1)*(x2))+((a2)*(x1))));
	((t2) = ((double)(((int)((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*(t1)))))));
	((z) = ((t1)-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(t2))));
	((t3) = ((((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(z))+((a2)*(x2))));
	((t4) = ((double)(((int)(((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5))*(t3)))))));
	((((*x).data[0])) = ((t3)-((((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0))*(t4))));
	return ((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5))*(((*x).data[0])));
}
static double randlc_wrap(void* _closure, __insieme_type_4* x, double a) { return randlc(x, a); }

// start code fragment :: Prototype for external function: log ... type: ((real<8>)->real<8>) //
double log(double);
static double log_wrap(void* _closure, double var_153) { return log(var_153); }

// start code fragment :: Prototype for external function: sqrt ... type: ((real<8>)->real<8>) //
double sqrt(double);
static double sqrt_wrap(void* _closure, double var_154) { return sqrt(var_154); }

// start code fragment :: Prototype for external function: fabs ... type: ((real<8>)->real<8>) //
double fabs(double);
static double fabs_wrap(void* _closure, double var_155) { return fabs(var_155); }

// start code fragment :: Definition of timer_clear ... type: ((ref<struct<_x:vector<real<8>,131073>,x:array<real<8>,1>,q:vector<real<8>,10>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,int<4>)->unit) //
void timer_clear(struct __insieme_globals* var_69, int n) { ((((*(&((*var_69).elapsed))).data[((unsigned int)(n))])) = 0.0); }
static void timer_clear_wrap(void* _closure, struct __insieme_globals* var_69, int n) { timer_clear(var_69, n); }

// start code fragment :: type_declaration_timeval //
struct timeval { 
    long tv_sec;
    long tv_usec;
};

// start code fragment :: array type definition of __insieme_type_16 <=> array<struct<tv_sec:int<8>,tv_usec:int<8>>,1> //
typedef struct ___insieme_type_16 { 
    struct timeval* data;
    unsigned size[1];
} __insieme_type_16;

// start code fragment :: type_declaration_timezone //
struct timezone { 
    int tz_minuteswest;
    int tz_dsttime;
};

// start code fragment :: array type definition of __timezone_ptr_t <=> array<struct<tz_minuteswest:int<4>,tz_dsttime:int<4>>,1> //
typedef struct ___timezone_ptr_t { 
    struct timezone* data;
    unsigned size[1];
} __timezone_ptr_t;

// start code fragment :: Prototype for external function: gettimeofday ... type: ((ref<array<struct<tv_sec:int<8>,tv_usec:int<8>>,1>>,ref<array<struct<tz_minuteswest:int<4>,tz_dsttime:int<4>>,1>>)->int<4>) //
int gettimeofday(struct timeval*, struct timezone*);
static int gettimeofday_wrap(void* _closure, __insieme_type_16* var_156, __timezone_ptr_t* var_157) { return gettimeofday(((struct timeval*)((*(var_156)).data)), ((struct timezone*)((*(var_157)).data))); }

// start code fragment :: Definition of wtime ... type: ((ref<struct<_x:vector<real<8>,131073>,x:array<real<8>,1>,q:vector<real<8>,10>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,ref<array<real<8>,1>>)->unit) //
void wtime(struct __insieme_globals* var_76, __insieme_type_4* t){
	struct timeval tv;
	gettimeofday(((struct timeval*)((*((&((__insieme_type_16){&tv,{1}})))).data)), ((struct timezone*)((*(((__timezone_ptr_t*)memcpy(alloca(sizeof(__timezone_ptr_t)), &((__timezone_ptr_t){0,{0}}), sizeof(__timezone_ptr_t))))).data)));
	if(((*(&((*var_76).sec)))<0)) { ((*(&((*var_76).sec))) = ((int)((*(&((tv).tv_sec)))))); };
	((((*t).data[0])) = (((double)(((*(&((tv).tv_sec)))-((long)((*(&((*var_76).sec))))))))+(1.0e-6*((double)((*(&((tv).tv_usec))))))));
}
static void wtime_wrap(void* _closure, struct __insieme_globals* var_76, __insieme_type_4* t) { wtime(var_76, t); }

// start code fragment :: Definition of elapsed_time ... type: ((ref<struct<_x:vector<real<8>,131073>,x:array<real<8>,1>,q:vector<real<8>,10>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>)->real<8>) //
double elapsed_time(struct __insieme_globals* var_74){
	double t = 0.0;
	wtime(var_74, (&((__insieme_type_4){&t,{1}})));
	return (t);
}
static double elapsed_time_wrap(void* _closure, struct __insieme_globals* var_74) { return elapsed_time(var_74); }

// start code fragment :: Definition of timer_start ... type: ((ref<struct<_x:vector<real<8>,131073>,x:array<real<8>,1>,q:vector<real<8>,10>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,int<4>)->unit) //
void timer_start(struct __insieme_globals* var_72, int n) { ((((*(&((*var_72).start))).data[((unsigned int)(n))])) = elapsed_time(var_72)); }
static void timer_start_wrap(void* _closure, struct __insieme_globals* var_72, int n) { timer_start(var_72, n); }

// start code fragment :: Definition of timer_stop ... type: ((ref<struct<_x:vector<real<8>,131073>,x:array<real<8>,1>,q:vector<real<8>,10>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,int<4>)->unit) //
void timer_stop(struct __insieme_globals* var_97, int n){
	double t = 0.0;
	double now = 0.0;
	((now) = elapsed_time(var_97));
	((t) = ((now)-(((*(&((*var_97).start))).data[((unsigned int)(n))]))));
	((((*(&((*var_97).elapsed))).data[((unsigned int)(n))])) = ((((*(&((*var_97).elapsed))).data[((unsigned int)(n))]))+(t)));
}
static void timer_stop_wrap(void* _closure, struct __insieme_globals* var_97, int n) { timer_stop(var_97, n); }

// start code fragment :: Definition of timer_read ... type: ((ref<struct<_x:vector<real<8>,131073>,x:array<real<8>,1>,q:vector<real<8>,10>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,int<4>)->real<8>) //
double timer_read(struct __insieme_globals* var_110, int n) { return (((*(&((*var_110).elapsed))).data[((unsigned int)(n))])); }
static double timer_read_wrap(void* _closure, struct __insieme_globals* var_110, int n) { return timer_read(var_110, n); }

// start code fragment :: Definition of c_print_results ... type: ((ref<array<char,1>>,char,int<4>,int<4>,int<4>,int<4>,int<4>,real<8>,real<8>,ref<array<char,1>>,int<4>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>)->unit) //
void c_print_results(__insieme_type_1* name, char class, int n1, int n2, int n3, int niter, int nthreads, double t, double mops, __insieme_type_1* optype, int passed_verification, __insieme_type_1* npbversion, __insieme_type_1* compiletime, __insieme_type_1* cc, __insieme_type_1* clink, __insieme_type_1* c_lib, __insieme_type_1* c_inc, __insieme_type_1* cflags, __insieme_type_1* clinkflags, __insieme_type_1* rand){
	__insieme_type_1 evalue = ((__insieme_type_1){"1000"});
	printf(((char*)((*(&((__insieme_type_1){"\n\n %s Benchmark Completed\n"}))).data)), ((char*)((*(name)).data)));
	printf(((char*)((*(&((__insieme_type_1){" Class           =                        %c\n"}))).data)), ((int)(class)));
	if(((n2==0)&&(n3==0))) { printf(((char*)((*(&((__insieme_type_1){" Size            =             %12d\n"}))).data)), n1); } else  { printf(((char*)((*(&((__insieme_type_1){" Size            =              %3dx%3dx%3d\n"}))).data)), n1, n2, n3); };
	printf(((char*)((*(&((__insieme_type_1){" Iterations      =             %12d\n"}))).data)), niter);
	printf(((char*)((*(&((__insieme_type_1){" Threads         =             %12d\n"}))).data)), nthreads);
	printf(((char*)((*(&((__insieme_type_1){" Time in seconds =             %12.2f\n"}))).data)), 0.0);
	printf(((char*)((*(&((__insieme_type_1){" Mop/s total     =             %12.2f\n"}))).data)), 0.0);
	printf(((char*)((*(&((__insieme_type_1){" Operation type  = %24s\n"}))).data)), ((char*)((*(optype)).data)));
	if((passed_verification!=0)) { printf(((char*)((*(&((__insieme_type_1){" Verification    =               SUCCESSFUL\n"}))).data)), 0); } else  { printf(((char*)((*(&((__insieme_type_1){" Verification    =             UNSUCCESSFUL\n"}))).data)), 0); };
	printf(((char*)((*(&((__insieme_type_1){" Version         =             %12s\n"}))).data)), ((char*)((*(npbversion)).data)));
	printf(((char*)((*(&((__insieme_type_1){" Compile date    =             %12s\n"}))).data)), ((char*)((*(compiletime)).data)));
	printf(((char*)((*(&((__insieme_type_1){"\n Compile options:\n"}))).data)), 0);
	printf(((char*)((*(&((__insieme_type_1){"    CC           = %s\n"}))).data)), ((char*)((*(cc)).data)));
	printf(((char*)((*(&((__insieme_type_1){"    CLINK        = %s\n"}))).data)), ((char*)((*(clink)).data)));
	printf(((char*)((*(&((__insieme_type_1){"    C_LIB        = %s\n"}))).data)), ((char*)((*(c_lib)).data)));
	printf(((char*)((*(&((__insieme_type_1){"    C_INC        = %s\n"}))).data)), ((char*)((*(c_inc)).data)));
	printf(((char*)((*(&((__insieme_type_1){"    CFLAGS       = %s\n"}))).data)), ((char*)((*(cflags)).data)));
	printf(((char*)((*(&((__insieme_type_1){"    CLINKFLAGS   = %s\n"}))).data)), ((char*)((*(clinkflags)).data)));
	printf(((char*)((*(&((__insieme_type_1){"    RAND         = %s\n"}))).data)), ((char*)((*(rand)).data)));
}
static void c_print_results_wrap(void* _closure, __insieme_type_1* name, char class, int n1, int n2, int n3, int niter, int nthreads, double t, double mops, __insieme_type_1* optype, int passed_verification, __insieme_type_1* npbversion, __insieme_type_1* compiletime, __insieme_type_1* cc, __insieme_type_1* clink, __insieme_type_1* c_lib, __insieme_type_1* c_inc, __insieme_type_1* cflags, __insieme_type_1* clinkflags, __insieme_type_1* rand) { c_print_results(name, class, n1, n2, n3, niter, nthreads, t, mops, optype, passed_verification, npbversion, compiletime, cc, clink, c_lib, c_inc, cflags, clinkflags, rand); }

// start code fragment :: main function //
int main(int __argc, char** __argv) {
	
	// encapsulating arguments within Insieme Types ...
	int argc = __argc;
	__insieme_type_0 argv = (__insieme_type_0){alloca(sizeof(__insieme_type_1) * argc), {argc}};
	for(int i=0; i<argc; ++i) {
		argv.data[i] = (__insieme_type_1){__argv[i],{strlen(__argv[i])+1}};
	}
	
	// ---- begin of actual code body ----
	{
		struct __insieme_globals* var_1 = malloc(sizeof(struct __insieme_globals));
		((*(&((*var_1).x))) = (__insieme_type_4){0,{0}});
		((*(&((*var_1).sec))) = (((int)(0))-1));
		double Mops = 0.0;
		double t1 = 0.0;
		double t2 = 0.0;
		double t3 = 0.0;
		double t4 = 0.0;
		double x1 = 0.0;
		double x2 = 0.0;
		double sx = 0.0;
		double sy = 0.0;
		double tm = 0.0;
		double an = 0.0;
		double tt = 0.0;
		double gc = 0.0;
		__insieme_type_9 dum = ((__insieme_type_9){{1.0, 1.0, 1.0}});
		int np = 0;
		int ierr = 0;
		int node = 0;
		int no_nodes = 0;
		int i = 0;
		int ik = 0;
		int kk = 0;
		int l = 0;
		int k = 0;
		int nit = 0;
		int ierrcode = 0;
		int no_large_nodes = 0;
		int np_add = 0;
		int k_offset = 0;
		int j = 0;
		int nthreads = 1;
		int verified = 0;
		__insieme_type_12 size;
		((*(&((*var_1).x))) = (*(&((__insieme_type_4){&((*(&((*var_1)._x))).data[((unsigned int)(1))]),{1}}))));
		printf(((char*)((*(&((__insieme_type_1){"\n\n NAS Parallel Benchmarks 2.3 OpenMP C version - EP Benchmark\n"}))).data)), 0);
		sprintf(((char*)((*((&((__insieme_type_1){(size).data,{1}})))).data)), ((char*)((*(&((__insieme_type_1){"%12.0f"}))).data)), pow(2.0, ((double)((25+1)))));
		{
			for(int var_36 = (((int)(0))-13); var_36 < ((((int)(0))-1)+1); var_36 += 1)  { if(((((size).data[((unsigned int)((((int)(0))-(var_36))))]))=='.')) { ((((size).data[((unsigned int)((((int)(0))-(var_36))))])) = ' '); }; };
			((j) = (13+(((int)(ceil((((double)((((((int)(0))-1)+1)-13)))/((double)(1))))))*1)));
		};
		printf(((char*)((*(&((__insieme_type_1){" Number of random numbers generated: %13s\n"}))).data)), ((size)).data);
		((verified) = 0);
		((np) = (1<<(25-16)));
		vranlc(0, (&((__insieme_type_4){&((dum).data[((unsigned int)(0))]),{1}})), (((dum).data[((unsigned int)(1))])), (&((__insieme_type_4){&((dum).data[((unsigned int)(2))]),{1}})));
		((((dum).data[((unsigned int)(0))])) = randlc((&((__insieme_type_4){&((dum).data[((unsigned int)(1))]),{1}})), (((dum).data[((unsigned int)(2))]))));
		{
			for(int var_66 = 0; var_66 < (2*(1<<16)); var_66 += 1)  { ((((*(&((*var_1).x))).data[((unsigned int)((var_66)))])) = (((double)(0))-1.0e99)); };
			((i) = (0+(((int)(ceil((((double)(((2*(1<<16))-0)))/((double)(1))))))*1)));
		};
		((Mops) = log(sqrt(fabs((((1.0>1.0))?(1.0):(1.0))))));
		timer_clear(var_1, 1);
		timer_clear(var_1, 2);
		timer_clear(var_1, 3);
		timer_start(var_1, 1);
		vranlc(0, (&((__insieme_type_4){&t1,{1}})), 1220703125.0, (&((*var_1).x)));
		((t1) = 1220703125.0);
		{
			for(int var_82 = 1; var_82 < ((16+1)+1); var_82 += 1)  { ((t2) = randlc((&((__insieme_type_4){&t1,{1}})), (t1))); };
			((i) = (1+(((int)(ceil((((double)((((16+1)+1)-1)))/((double)(1))))))*1)));
		};
		((an) = (t1));
		((tt) = 271828183.0);
		((gc) = 0.0);
		((sx) = 0.0);
		((sy) = 0.0);
		{
			for(int var_83 = 0; var_83 < ((10-1)+1); var_83 += 1)  { ((((*(&((*var_1).q))).data[((unsigned int)((var_83)))])) = 0.0); };
			((i) = (0+(((int)(ceil((((double)((((10-1)+1)-0)))/((double)(1))))))*1)));
		};
		((k_offset) = (((int)(0))-1));
		{
			double t1 = 0.0;
			double t2 = 0.0;
			double t3 = 0.0;
			double t4 = 0.0;
			double x1 = 0.0;
			double x2 = 0.0;
			int kk = 0;
			int i = 0;
			int ik = 0;
			int l = 0;
			__insieme_type_5 qq;
			{
				for(int var_95 = 0; var_95 < 10; var_95 += 1)  { ((((qq).data[((unsigned int)((var_95)))])) = 0.0); };
				((i) = (0+(((int)(ceil((((double)((10-0)))/((double)(1))))))*1)));
			};
			{
				for(int var_107 = 1; var_107 < ((np)+1); var_107 += 1) {
					((kk) = ((k_offset)+(var_107)));
					((t1) = 271828183.0);
					((t2) = (an));
					{
						for(int var_96 = 1; var_96 < (100+1); var_96 += 1) {
							((ik) = ((kk)/2));
							if(((2*(ik))!=(kk))) { ((t3) = randlc((&((__insieme_type_4){&t1,{1}})), (t2))); };
							if(((ik)==0)) { break; };
							((t3) = randlc((&((__insieme_type_4){&t2,{1}})), (t2)));
							((kk) = (ik));
						};
						((i) = (1+(((int)(ceil((((double)(((100+1)-1)))/((double)(1))))))*1)));
					};
					if((0==1)) { timer_start(var_1, 3); };
					vranlc((2*(1<<16)), (&((__insieme_type_4){&t1,{1}})), 1220703125.0, (&((__insieme_type_4){(*(&((*var_1)._x))).data,{1}})));
					if((0==1)) { timer_stop(var_1, 3); };
					if((0==1)) { timer_start(var_1, 2); };
					{
						for(int var_106 = 0; var_106 < (1<<16); var_106 += 1) {
							((x1) = ((2.0*(((*(&((*var_1).x))).data[((unsigned int)((2*(var_106))))])))-1.0));
							((x2) = ((2.0*(((*(&((*var_1).x))).data[((unsigned int)(((2*(var_106))+1)))])))-1.0));
							((t1) = (((x1)*(x1))+((x2)*(x2))));
							if(((t1)<=1.0)){
								((t2) = sqrt((((((double)(0))-2.0)*log((t1)))/(t1))));
								((t3) = ((x1)*(t2)));
								((t4) = ((x2)*(t2)));
								((l) = ((int)((((fabs((t3))>fabs((t4))))?(fabs((t3))):(fabs((t4)))))));
								((((qq).data[((unsigned int)((l)))])) = ((((qq).data[((unsigned int)((l)))]))+1.0));
								((sx) = ((sx)+(t3)));
								((sy) = ((sy)+(t4)));
							};
						};
						((i) = (0+(((int)(ceil((((double)(((1<<16)-0)))/((double)(1))))))*1)));
					};
					if((0==1)) { timer_stop(var_1, 2); };
				};
				((k) = (1+(((int)(ceil((((double)((((np)+1)-1)))/((double)(1))))))*1)));
			};
			 { {
				for(int var_108 = 0; var_108 < ((10-1)+1); var_108 += 1)  { ((((*(&((*var_1).q))).data[((unsigned int)((var_108)))])) = ((((*(&((*var_1).q))).data[((unsigned int)((var_108)))]))+(((qq).data[((unsigned int)((var_108)))])))); };
				((i) = (0+(((int)(ceil((((double)((((10-1)+1)-0)))/((double)(1))))))*1)));
			}; };
		};
		{
			for(int var_109 = 0; var_109 < ((10-1)+1); var_109 += 1)  { ((gc) = ((gc)+(((*(&((*var_1).q))).data[((unsigned int)((var_109)))])))); };
			((i) = (0+(((int)(ceil((((double)((((10-1)+1)-0)))/((double)(1))))))*1)));
		};
		timer_stop(var_1, 1);
		((tm) = timer_read(var_1, 1));
		((nit) = 0);
		if((25==24)) { if(((fabs((((sx)-(((double)(0))-3.247834652034740e3))/(sx)))<=1.0e-8)&&(fabs((((sy)-(((double)(0))-6.958407078382297e3))/(sy)))<=1.0e-8))) { ((verified) = 1); }; } else  { if((25==25)) { if(((fabs((((sx)-(((double)(0))-2.863319731645753e3))/(sx)))<=1.0e-8)&&(fabs((((sy)-(((double)(0))-6.320053679109499e3))/(sy)))<=1.0e-8))) { ((verified) = 1); }; } else  { if((25==28)) { if(((fabs((((sx)-(((double)(0))-4.295875165629892e3))/(sx)))<=1.0e-8)&&(fabs((((sy)-(((double)(0))-1.580732573678431e4))/(sy)))<=1.0e-8))) { ((verified) = 1); }; } else  { if((25==30)) { if(((fabs((((sx)-4.033815542441498e4)/(sx)))<=1.0e-8)&&(fabs((((sy)-(((double)(0))-2.660669192809235e4))/(sy)))<=1.0e-8))) { ((verified) = 1); }; } else  { if((25==32)) { if(((fabs((((sx)-4.764367927995374e4)/(sx)))<=1.0e-8)&&(fabs((((sy)-(((double)(0))-8.084072988043731e4))/(sy)))<=1.0e-8))) { ((verified) = 1); }; }; }; }; }; };
		((Mops) = ((pow(2.0, ((double)((25+1))))/(tm))/1000000.0));
		printf(((char*)((*(&((__insieme_type_1){"EP Benchmark Results: \nCPU Time = %10.4f\nN = 2^%5d\nNo. Gaussian Pairs = %15.0f\nSums = %25.15e %25.15e\nCounts:\n"}))).data)), 0.0, 25, (gc), (sx), (sy));
		{
			for(int var_123 = 0; var_123 < ((10-1)+1); var_123 += 1)  { printf(((char*)((*(&((__insieme_type_1){"%3d %15.0f\n"}))).data)), (var_123), (((*(&((*var_1).q))).data[((unsigned int)((var_123)))]))); };
			((i) = (0+(((int)(ceil((((double)((((10-1)+1)-0)))/((double)(1))))))*1)));
		};
		c_print_results(&((__insieme_type_1){"EP"}), 'W', (25+1), 0, 0, (nit), (nthreads), (tm), (Mops), &((__insieme_type_1){"Random numbers generated"}), (verified), &((__insieme_type_1){"2.3"}), &((__insieme_type_1){"03 Dec 2010"}), &((__insieme_type_1){"cc"}), &((__insieme_type_1){"cc"}), &((__insieme_type_1){"-lm"}), &((__insieme_type_1){"-I../common"}), &((__insieme_type_1){"-O3 "}), &((__insieme_type_1){"-lm"}), &((__insieme_type_1){"randdp"}));
		if((0==1)){
			printf(((char*)((*(&((__insieme_type_1){"Total time:     %f"}))).data)), timer_read(var_1, 1));
			printf(((char*)((*(&((__insieme_type_1){"Gaussian pairs: %f"}))).data)), timer_read(var_1, 2));
			printf(((char*)((*(&((__insieme_type_1){"Random numbers: %f"}))).data)), timer_read(var_1, 3));
		};
	}
	// ----  end of actual code body  ----
	
}

