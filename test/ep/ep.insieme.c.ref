// --- Generated Inspire Code ---
#include <alloca.h>
#include <stddef.h>
#include <stdlib.h>
#include <runtime.h>
#define bool int
#define true 1
#define false 0
#define null 0

// start code fragment :: array type definition of __insieme_type_1 <=> array<char,1> //
typedef struct ___insieme_type_1 { 
    char* data;
} __insieme_type_1;

// start code fragment :: array type definition of __insieme_type_0 <=> array<array<char,1>,1> //
typedef struct ___insieme_type_0 { 
    __insieme_type_1* data;
} __insieme_type_0;

// start code fragment :: vector_type_declaration of __insieme_type_2 <=> vector<real<8>,131073> //
typedef struct ___insieme_type_2 { 
    double data[131073];
} __insieme_type_2;

// A constructor initializing a vector of the type __insieme_type_2 uniformly
static inline __insieme_type_2 __insieme_type_2_init_uniform(double value) {
	__insieme_type_2 res;
	for (int i=0; i<131073;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: array type definition of __insieme_type_3 <=> array<real<8>,1> //
typedef struct ___insieme_type_3 { 
    double* data;
} __insieme_type_3;

// start code fragment :: vector_type_declaration of __insieme_type_4 <=> vector<real<8>,10> //
typedef struct ___insieme_type_4 { 
    double data[10];
} __insieme_type_4;

// A constructor initializing a vector of the type __insieme_type_4 uniformly
static inline __insieme_type_4 __insieme_type_4_init_uniform(double value) {
	__insieme_type_4 res;
	for (int i=0; i<10;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_5 <=> vector<real<8>,64> //
typedef struct ___insieme_type_5 { 
    double data[64];
} __insieme_type_5;

// A constructor initializing a vector of the type __insieme_type_5 uniformly
static inline __insieme_type_5 __insieme_type_5_init_uniform(double value) {
	__insieme_type_5 res;
	for (int i=0; i<64;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: type_declaration___insieme_globals //
struct __insieme_globals { 
    __insieme_type_2 _x;
    __insieme_type_3 x;
    __insieme_type_4 q;
    __insieme_type_5 start;
    __insieme_type_5 elapsed;
    int sec;
};

// start code fragment :: global data //
struct __insieme_globals __GLOBAL__;

// start code fragment :: vector_type_declaration of __insieme_type_7 <=> vector<real<8>,3> //
typedef struct ___insieme_type_7 { 
    double data[3];
} __insieme_type_7;

// A constructor initializing a vector of the type __insieme_type_7 uniformly
static inline __insieme_type_7 __insieme_type_7_init_uniform(double value) {
	__insieme_type_7 res;
	for (int i=0; i<3;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_10 <=> vector<char,14> //
typedef struct ___insieme_type_10 { 
    char data[14];
} __insieme_type_10;

// A constructor initializing a vector of the type __insieme_type_10 uniformly
static inline __insieme_type_10 __insieme_type_10_init_uniform(char value) {
	__insieme_type_10 res;
	for (int i=0; i<14;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: Prototype for external function: printf ... type: ((ref<array<char,1>>,var_list)->int<4>) //
int printf(char*, ...);

// start code fragment :: Prototype for external function: sprintf ... type: ((ref<array<char,1>>,ref<array<char,1>>,var_list)->int<4>) //
int sprintf(char*, char*, ...);

// start code fragment :: Prototype for external function: pow ... type: ((real<8>,real<8>)->real<8>) //
double pow(double, double);
static double pow_wrap(void* _closure, double var_161, double var_162) { return pow(var_161, var_162); }

// start code fragment :: Prototype for external function: ceil ... type: ((real<8>)->real<8>) //
double ceil(double);
static double ceil_wrap(void* _closure, double var_163) { return ceil(var_163); }

// start code fragment :: Definition of vranlc ... type: ((int<4>,ref<array<real<8>,1>>,real<8>,ref<array<real<8>,1>>)->unit) //
void vranlc(int n, __insieme_type_3* x_seed, double a, __insieme_type_3* y){
	int i = 0;
	double x = 0.0;
	double t1 = 0.0;
	double t2 = 0.0;
	double t3 = 0.0;
	double t4 = 0.0;
	double a1 = 0.0;
	double a2 = 0.0;
	double x1 = 0.0;
	double x2 = 0.0;
	double z = 0.0;
	((t1) = (((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*a));
	((a1) = ((double)(((int)(t1)))));
	((a2) = (a-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(a1))));
	((x) = (((*x_seed).data[0])));
	{
		for(int var_54 = 1; var_54 < (n+1); var_54 += 1) {
			((t1) = (((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*(x)));
			((x1) = ((double)(((int)(t1)))));
			((x2) = ((x)-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(x1))));
			((t1) = (((a1)*(x2))+((a2)*(x1))));
			((t2) = ((double)(((int)((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*(t1)))))));
			((z) = ((t1)-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(t2))));
			((t3) = ((((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(z))+((a2)*(x2))));
			((t4) = ((double)(((int)(((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5))*(t3)))))));
			((x) = ((t3)-((((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0))*(t4))));
			((((*y).data[((unsigned int)(var_54))])) = ((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5))*(x)));
		};
		((i) = (1+(((int)(ceil((((double)(((n+1)-1)))/((double)(1))))))*1)));
	};
	((((*x_seed).data[0])) = (x));
}
static void vranlc_wrap(void* _closure, int n, __insieme_type_3* x_seed, double a, __insieme_type_3* y) { vranlc(n, x_seed, a, y); }

// start code fragment :: Definition of randlc ... type: ((ref<array<real<8>,1>>,real<8>)->real<8>) //
double randlc(__insieme_type_3* x, double a){
	double t1 = 0.0;
	double t2 = 0.0;
	double t3 = 0.0;
	double t4 = 0.0;
	double a1 = 0.0;
	double a2 = 0.0;
	double x1 = 0.0;
	double x2 = 0.0;
	double z = 0.0;
	((t1) = (((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*a));
	((a1) = ((double)(((int)(t1)))));
	((a2) = (a-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(a1))));
	((t1) = (((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*(((*x).data[0]))));
	((x1) = ((double)(((int)(t1)))));
	((x2) = ((((*x).data[0]))-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(x1))));
	((t1) = (((a1)*(x2))+((a2)*(x1))));
	((t2) = ((double)(((int)((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*(t1)))))));
	((z) = ((t1)-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(t2))));
	((t3) = ((((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(z))+((a2)*(x2))));
	((t4) = ((double)(((int)(((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5))*(t3)))))));
	((((*x).data[0])) = ((t3)-((((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0))*(t4))));
	return ((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5))*(((*x).data[0])));
}
static double randlc_wrap(void* _closure, __insieme_type_3* x, double a) { return randlc(x, a); }

// start code fragment :: Prototype for external function: log ... type: ((real<8>)->real<8>) //
double log(double);
static double log_wrap(void* _closure, double var_164) { return log(var_164); }

// start code fragment :: Prototype for external function: sqrt ... type: ((real<8>)->real<8>) //
double sqrt(double);
static double sqrt_wrap(void* _closure, double var_165) { return sqrt(var_165); }

// start code fragment :: Prototype for external function: fabs ... type: ((real<8>)->real<8>) //
double fabs(double);
static double fabs_wrap(void* _closure, double var_166) { return fabs(var_166); }

// start code fragment :: Definition of timer_clear ... type: ((int<4>)->unit) //
void timer_clear(int n) { ((((*(&((__GLOBAL__).elapsed))).data[((unsigned int)(n))])) = 0.0); }
static void timer_clear_wrap(void* _closure, int n) { timer_clear(n); }

// start code fragment :: type_declaration_timeval //
struct timeval { 
    long tv_sec;
    long tv_usec;
};

// start code fragment :: array type definition of __insieme_type_15 <=> array<struct<tv_sec:int<8>,tv_usec:int<8>>,1> //
typedef struct ___insieme_type_15 { 
    struct timeval* data;
} __insieme_type_15;

// start code fragment :: type_declaration_timezone //
struct timezone { 
    int tz_minuteswest;
    int tz_dsttime;
};

// start code fragment :: array type definition of __timezone_ptr_t <=> array<struct<tz_minuteswest:int<4>,tz_dsttime:int<4>>,1> //
typedef struct ___timezone_ptr_t { 
    struct timezone* data;
} __timezone_ptr_t;

// start code fragment :: Prototype for external function: gettimeofday ... type: ((ref<array<struct<tv_sec:int<8>,tv_usec:int<8>>,1>>,ref<array<struct<tz_minuteswest:int<4>,tz_dsttime:int<4>>,1>>)->int<4>) //
int gettimeofday(struct timeval*, struct timezone*);
static int gettimeofday_wrap(void* _closure, __insieme_type_15* var_167, __timezone_ptr_t* var_168) { return gettimeofday(((struct timeval*)((*(var_167)).data)), ((struct timezone*)((*(var_168)).data))); }

// start code fragment :: Definition of wtime ... type: ((ref<array<real<8>,1>>)->unit) //
void wtime(__insieme_type_3* t){
	struct timeval tv;
	gettimeofday(((struct timeval*)((*((&((__insieme_type_15){&tv})))).data)), ((struct timezone*)((*(((__timezone_ptr_t*)memcpy(alloca(sizeof(__timezone_ptr_t)), &((__timezone_ptr_t){0}), sizeof(__timezone_ptr_t))))).data)));
	if(((*(&((__GLOBAL__).sec)))<0)) { ((*(&((__GLOBAL__).sec))) = ((int)((*(&((tv).tv_sec)))))); };
	((((*t).data[0])) = (((double)(((*(&((tv).tv_sec)))-((long)((*(&((__GLOBAL__).sec))))))))+(1.0e-6*((double)((*(&((tv).tv_usec))))))));
}
static void wtime_wrap(void* _closure, __insieme_type_3* t) { wtime(t); }

// start code fragment :: Definition of elapsed_time ... type: (()->real<8>) //
double elapsed_time(){
	double t = 0.0;
	wtime((&((__insieme_type_3){&t})));
	return (t);
}
static double elapsed_time_wrap(void* _closure) { return elapsed_time(); }

// start code fragment :: Definition of timer_start ... type: ((int<4>)->unit) //
void timer_start(int n) { ((((*(&((__GLOBAL__).start))).data[((unsigned int)(n))])) = elapsed_time()); }
static void timer_start_wrap(void* _closure, int n) { timer_start(n); }

// start code fragment :: Definition of timer_stop ... type: ((int<4>)->unit) //
void timer_stop(int n){
	double t = 0.0;
	double now = 0.0;
	((now) = elapsed_time());
	((t) = ((now)-(((*(&((__GLOBAL__).start))).data[((unsigned int)(n))]))));
	((((*(&((__GLOBAL__).elapsed))).data[((unsigned int)(n))])) = ((((*(&((__GLOBAL__).elapsed))).data[((unsigned int)(n))]))+(t)));
}
static void timer_stop_wrap(void* _closure, int n) { timer_stop(n); }

// start code fragment :: Definition of timer_read ... type: ((int<4>)->real<8>) //
double timer_read(int n) { return (((*(&((__GLOBAL__).elapsed))).data[((unsigned int)(n))])); }
static double timer_read_wrap(void* _closure, int n) { return timer_read(n); }

// start code fragment :: Definition of c_print_results ... type: ((ref<array<char,1>>,char,int<4>,int<4>,int<4>,int<4>,int<4>,real<8>,real<8>,ref<array<char,1>>,int<4>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>)->unit) //
void c_print_results(__insieme_type_1* name, char class, int n1, int n2, int n3, int niter, int nthreads, double t, double mops, __insieme_type_1* optype, int passed_verification, __insieme_type_1* npbversion, __insieme_type_1* compiletime, __insieme_type_1* cc, __insieme_type_1* clink, __insieme_type_1* c_lib, __insieme_type_1* c_inc, __insieme_type_1* cflags, __insieme_type_1* clinkflags, __insieme_type_1* rand){
	__insieme_type_1 evalue = ((__insieme_type_1){"1000"});
	printf(((char*)((*(&((__insieme_type_1){"\n\n %s Benchmark Completed\n"}))).data)), ((char*)((*(name)).data)));
	printf(((char*)((*(&((__insieme_type_1){" Class           =                        %c\n"}))).data)), ((int)(class)));
	if(((n2==0)&&(n3==0))) { printf(((char*)((*(&((__insieme_type_1){" Size            =             %12d\n"}))).data)), n1); } else  { printf(((char*)((*(&((__insieme_type_1){" Size            =              %3dx%3dx%3d\n"}))).data)), n1, n2, n3); };
	printf(((char*)((*(&((__insieme_type_1){" Iterations      =             %12d\n"}))).data)), niter);
	printf(((char*)((*(&((__insieme_type_1){" Threads         =             %12d\n"}))).data)), nthreads);
	printf(((char*)((*(&((__insieme_type_1){" Time in seconds =             %12.2f\n"}))).data)), 0.0);
	printf(((char*)((*(&((__insieme_type_1){" Mop/s total     =             %12.2f\n"}))).data)), 0.0);
	printf(((char*)((*(&((__insieme_type_1){" Operation type  = %24s\n"}))).data)), ((char*)((*(optype)).data)));
	if((passed_verification!=0)) { printf(((char*)((*(&((__insieme_type_1){" Verification    =               SUCCESSFUL\n"}))).data)), 0); } else  { printf(((char*)((*(&((__insieme_type_1){" Verification    =             UNSUCCESSFUL\n"}))).data)), 0); };
	printf(((char*)((*(&((__insieme_type_1){" Version         =             %12s\n"}))).data)), ((char*)((*(npbversion)).data)));
	printf(((char*)((*(&((__insieme_type_1){" Compile date    =             %12s\n"}))).data)), ((char*)((*(compiletime)).data)));
	printf(((char*)((*(&((__insieme_type_1){"\n Compile options:\n"}))).data)), 0);
	printf(((char*)((*(&((__insieme_type_1){"    CC           = %s\n"}))).data)), ((char*)((*(cc)).data)));
	printf(((char*)((*(&((__insieme_type_1){"    CLINK        = %s\n"}))).data)), ((char*)((*(clink)).data)));
	printf(((char*)((*(&((__insieme_type_1){"    C_LIB        = %s\n"}))).data)), ((char*)((*(c_lib)).data)));
	printf(((char*)((*(&((__insieme_type_1){"    C_INC        = %s\n"}))).data)), ((char*)((*(c_inc)).data)));
	printf(((char*)((*(&((__insieme_type_1){"    CFLAGS       = %s\n"}))).data)), ((char*)((*(cflags)).data)));
	printf(((char*)((*(&((__insieme_type_1){"    CLINKFLAGS   = %s\n"}))).data)), ((char*)((*(clinkflags)).data)));
	printf(((char*)((*(&((__insieme_type_1){"    RAND         = %s\n"}))).data)), ((char*)((*(rand)).data)));
}
static void c_print_results_wrap(void* _closure, __insieme_type_1* name, char class, int n1, int n2, int n3, int niter, int nthreads, double t, double mops, __insieme_type_1* optype, int passed_verification, __insieme_type_1* npbversion, __insieme_type_1* compiletime, __insieme_type_1* cc, __insieme_type_1* clink, __insieme_type_1* c_lib, __insieme_type_1* c_inc, __insieme_type_1* cflags, __insieme_type_1* clinkflags, __insieme_type_1* rand) { c_print_results(name, class, n1, n2, n3, niter, nthreads, t, mops, optype, passed_verification, npbversion, compiletime, cc, clink, c_lib, c_inc, cflags, clinkflags, rand); }

// start code fragment :: main function //
int main(int __argc, char** __argv) {
	
	// encapsulating arguments within Insieme Types ...
	int argc = __argc;
	__insieme_type_0 argv = (__insieme_type_0){alloca(sizeof(__insieme_type_1) * argc)};
	for(int i=0; i<argc; ++i) {
		argv.data[i] = (__insieme_type_1){__argv[i]};
	}
	
	// ---- begin of actual code body ----
	{
		;
		((*(&((__GLOBAL__).x))) = (__insieme_type_3){0});
		((*(&((__GLOBAL__).sec))) = (((int)(0))-1));
		double Mops = 0.0;
		double t1 = 0.0;
		double t2 = 0.0;
		double t3 = 0.0;
		double t4 = 0.0;
		double x1 = 0.0;
		double x2 = 0.0;
		double sx = 0.0;
		double sy = 0.0;
		double tm = 0.0;
		double an = 0.0;
		double tt = 0.0;
		double gc = 0.0;
		__insieme_type_7 dum = ((__insieme_type_7){{1.0, 1.0, 1.0}});
		int np = 0;
		int ierr = 0;
		int node = 0;
		int no_nodes = 0;
		int i = 0;
		int ik = 0;
		int kk = 0;
		int l = 0;
		int k = 0;
		int nit = 0;
		int ierrcode = 0;
		int no_large_nodes = 0;
		int np_add = 0;
		int k_offset = 0;
		int j = 0;
		int nthreads = 1;
		int verified = 0;
		__insieme_type_10 size;
		((*(&((__GLOBAL__).x))) = (*(&((__insieme_type_3){&((*(&((__GLOBAL__)._x))).data[((unsigned int)(1))])}))));
		printf(((char*)((*(&((__insieme_type_1){"\n\n NAS Parallel Benchmarks 2.3 OpenMP C version - EP Benchmark\n"}))).data)), 0);
		sprintf(((char*)((*((&((__insieme_type_1){(size).data})))).data)), ((char*)((*(&((__insieme_type_1){"%12.0f"}))).data)), pow(2.0, ((double)((25+1)))));
		{
			for(int var_37 = (((int)(0))-13); var_37 < ((((int)(0))-1)+1); var_37 += 1)  { if(((((size).data[((unsigned int)((((int)(0))-var_37)))]))=='.')) { ((((size).data[((unsigned int)((((int)(0))-var_37)))])) = ' '); }; };
			((j) = (13+(((int)(ceil((((double)((((((int)(0))-1)+1)-13)))/((double)(1))))))*1)));
		};
		printf(((char*)((*(&((__insieme_type_1){" Number of random numbers generated: %13s\n"}))).data)), ((size)).data);
		((verified) = 0);
		((np) = (1<<(25-16)));
		vranlc(0, (&((__insieme_type_3){&((dum).data[((unsigned int)(0))])})), (((dum).data[((unsigned int)(1))])), (&((__insieme_type_3){&((dum).data[((unsigned int)(2))])})));
		((((dum).data[((unsigned int)(0))])) = randlc((&((__insieme_type_3){&((dum).data[((unsigned int)(1))])})), (((dum).data[((unsigned int)(2))]))));
		{
			for(int var_69 = 0; var_69 < (2*(1<<16)); var_69 += 1)  { ((((*(&((__GLOBAL__).x))).data[((unsigned int)(var_69))])) = (((double)(0))-1.0e99)); };
			((i) = (0+(((int)(ceil((((double)(((2*(1<<16))-0)))/((double)(1))))))*1)));
		};
		((Mops) = log(sqrt(fabs((((1.0>1.0))?(1.0):(1.0))))));
		timer_clear(1);
		timer_clear(2);
		timer_clear(3);
		timer_start(1);
		vranlc(0, (&((__insieme_type_3){&t1})), 1220703125.0, (&((__GLOBAL__).x)));
		((t1) = 1220703125.0);
		{
			for(int var_86 = 1; var_86 < ((16+1)+1); var_86 += 1)  { ((t2) = randlc((&((__insieme_type_3){&t1})), (t1))); };
			((i) = (1+(((int)(ceil((((double)((((16+1)+1)-1)))/((double)(1))))))*1)));
		};
		((an) = (t1));
		((tt) = 271828183.0);
		((gc) = 0.0);
		((sx) = 0.0);
		((sy) = 0.0);
		{
			for(int var_88 = 0; var_88 < ((10-1)+1); var_88 += 1)  { ((((*(&((__GLOBAL__).q))).data[((unsigned int)(var_88))])) = 0.0); };
			((i) = (0+(((int)(ceil((((double)((((10-1)+1)-0)))/((double)(1))))))*1)));
		};
		((k_offset) = (((int)(0))-1));
		{
			double t1 = 0.0;
			double t2 = 0.0;
			double t3 = 0.0;
			double t4 = 0.0;
			double x1 = 0.0;
			double x2 = 0.0;
			int kk = 0;
			int i = 0;
			int ik = 0;
			int l = 0;
			__insieme_type_4 qq;
			{
				for(int var_101 = 0; var_101 < 10; var_101 += 1)  { ((((qq).data[((unsigned int)(var_101))])) = 0.0); };
				((i) = (0+(((int)(ceil((((double)((10-0)))/((double)(1))))))*1)));
			};
			{
				for(int var_116 = 1; var_116 < ((np)+1); var_116 += 1) {
					((kk) = ((k_offset)+var_116));
					((t1) = 271828183.0);
					((t2) = (an));
					{
						for(int var_103 = 1; var_103 < (100+1); var_103 += 1) {
							((ik) = ((kk)/2));
							if(((2*(ik))!=(kk))) { ((t3) = randlc((&((__insieme_type_3){&t1})), (t2))); };
							if(((ik)==0)) { break; };
							((t3) = randlc((&((__insieme_type_3){&t2})), (t2)));
							((kk) = (ik));
						};
						((i) = (1+(((int)(ceil((((double)(((100+1)-1)))/((double)(1))))))*1)));
					};
					if((0==1)) { timer_start(3); };
					vranlc((2*(1<<16)), (&((__insieme_type_3){&t1})), 1220703125.0, (&((__insieme_type_3){(*(&((__GLOBAL__)._x))).data})));
					if((0==1)) { timer_stop(3); };
					if((0==1)) { timer_start(2); };
					{
						for(int var_114 = 0; var_114 < (1<<16); var_114 += 1) {
							((x1) = ((2.0*(((*(&((__GLOBAL__).x))).data[((unsigned int)((2*var_114)))])))-1.0));
							((x2) = ((2.0*(((*(&((__GLOBAL__).x))).data[((unsigned int)(((2*var_114)+1)))])))-1.0));
							((t1) = (((x1)*(x1))+((x2)*(x2))));
							if(((t1)<=1.0)){
								((t2) = sqrt((((((double)(0))-2.0)*log((t1)))/(t1))));
								((t3) = ((x1)*(t2)));
								((t4) = ((x2)*(t2)));
								((l) = ((int)((((fabs((t3))>fabs((t4))))?(fabs((t3))):(fabs((t4)))))));
								((((qq).data[((unsigned int)((l)))])) = ((((qq).data[((unsigned int)((l)))]))+1.0));
								((sx) = ((sx)+(t3)));
								((sy) = ((sy)+(t4)));
							};
						};
						((i) = (0+(((int)(ceil((((double)(((1<<16)-0)))/((double)(1))))))*1)));
					};
					if((0==1)) { timer_stop(2); };
				};
				((k) = (1+(((int)(ceil((((double)((((np)+1)-1)))/((double)(1))))))*1)));
			};
			 { {
				for(int var_118 = 0; var_118 < ((10-1)+1); var_118 += 1)  { ((((*(&((__GLOBAL__).q))).data[((unsigned int)(var_118))])) = ((((*(&((__GLOBAL__).q))).data[((unsigned int)(var_118))]))+(((qq).data[((unsigned int)(var_118))])))); };
				((i) = (0+(((int)(ceil((((double)((((10-1)+1)-0)))/((double)(1))))))*1)));
			}; };
		};
		{
			for(int var_120 = 0; var_120 < ((10-1)+1); var_120 += 1)  { ((gc) = ((gc)+(((*(&((__GLOBAL__).q))).data[((unsigned int)(var_120))])))); };
			((i) = (0+(((int)(ceil((((double)((((10-1)+1)-0)))/((double)(1))))))*1)));
		};
		timer_stop(1);
		((tm) = timer_read(1));
		((nit) = 0);
		if((25==24)) { if(((fabs((((sx)-(((double)(0))-3.247834652034740e3))/(sx)))<=1.0e-8)&&(fabs((((sy)-(((double)(0))-6.958407078382297e3))/(sy)))<=1.0e-8))) { ((verified) = 1); }; } else  { if((25==25)) { if(((fabs((((sx)-(((double)(0))-2.863319731645753e3))/(sx)))<=1.0e-8)&&(fabs((((sy)-(((double)(0))-6.320053679109499e3))/(sy)))<=1.0e-8))) { ((verified) = 1); }; } else  { if((25==28)) { if(((fabs((((sx)-(((double)(0))-4.295875165629892e3))/(sx)))<=1.0e-8)&&(fabs((((sy)-(((double)(0))-1.580732573678431e4))/(sy)))<=1.0e-8))) { ((verified) = 1); }; } else  { if((25==30)) { if(((fabs((((sx)-4.033815542441498e4)/(sx)))<=1.0e-8)&&(fabs((((sy)-(((double)(0))-2.660669192809235e4))/(sy)))<=1.0e-8))) { ((verified) = 1); }; } else  { if((25==32)) { if(((fabs((((sx)-4.764367927995374e4)/(sx)))<=1.0e-8)&&(fabs((((sy)-(((double)(0))-8.084072988043731e4))/(sy)))<=1.0e-8))) { ((verified) = 1); }; }; }; }; }; };
		((Mops) = ((pow(2.0, ((double)((25+1))))/(tm))/1000000.0));
		printf(((char*)((*(&((__insieme_type_1){"EP Benchmark Results: \nCPU Time = %10.4f\nN = 2^%5d\nNo. Gaussian Pairs = %15.0f\nSums = %25.15e %25.15e\nCounts:\n"}))).data)), 0.0, 25, (gc), (sx), (sy));
		{
			for(int var_135 = 0; var_135 < ((10-1)+1); var_135 += 1)  { printf(((char*)((*(&((__insieme_type_1){"%3d %15.0f\n"}))).data)), var_135, (((*(&((__GLOBAL__).q))).data[((unsigned int)(var_135))]))); };
			((i) = (0+(((int)(ceil((((double)((((10-1)+1)-0)))/((double)(1))))))*1)));
		};
		c_print_results(&((__insieme_type_1){"EP"}), 'W', (25+1), 0, 0, (nit), (nthreads), (tm), (Mops), &((__insieme_type_1){"Random numbers generated"}), (verified), &((__insieme_type_1){"2.3"}), &((__insieme_type_1){"03 Dec 2010"}), &((__insieme_type_1){"cc"}), &((__insieme_type_1){"cc"}), &((__insieme_type_1){"-lm"}), &((__insieme_type_1){"-I../common"}), &((__insieme_type_1){"-O3 "}), &((__insieme_type_1){"-lm"}), &((__insieme_type_1){"randdp"}));
		if((0==1)){
			printf(((char*)((*(&((__insieme_type_1){"Total time:     %f"}))).data)), timer_read(1));
			printf(((char*)((*(&((__insieme_type_1){"Gaussian pairs: %f"}))).data)), timer_read(2));
			printf(((char*)((*(&((__insieme_type_1){"Random numbers: %f"}))).data)), timer_read(3));
		};
	}
	// ----  end of actual code body  ----
	
}

