// --- Generated Inspire Code ---
#include <alloca.h>
#include <stddef.h>
#include <runtime.h>
#define bool int
#define true 1
#define false 0
#define null 0

// start code fragment :: type_declaration_Settings //
struct Settings { 
    unsigned int numSources;
    int x;
    int y;
    double scale;
    double dt;
    double friction;
    double height;
    double abortVelocity;
    unsigned int minSteps;
    unsigned long maxSteps;
};

// start code fragment :: vector_type_declaration of __insieme_type_1 <=> vector<real<8>,2> //
typedef struct ___insieme_type_1 { 
    double data[2];
} __insieme_type_1;

// A constructor initializing a vector of the type __insieme_type_1 uniformly
static inline __insieme_type_1 __insieme_type_1_init_uniform(double value) {
	__insieme_type_1 res;
	for (int i=0; i<2;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: type_declaration_Source //
struct Source { 
    int type;
    __insieme_type_1 pos;
    double mult;
    double size;
};

// start code fragment :: vector_type_declaration of __insieme_type_5 <=> vector<char,4096> //
typedef struct ___insieme_type_5 { 
    char data[4096];
} __insieme_type_5;

// A constructor initializing a vector of the type __insieme_type_5 uniformly
static inline __insieme_type_5 __insieme_type_5_init_uniform(char value) {
	__insieme_type_5 res;
	for (int i=0; i<4096;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: Prototype for external function: fopen ... type: ((ref<array<char,1>>,ref<array<char,1>>)->ref<array<rec '_IO_FILE.{'_IO_FILE=struct<_flags:int<4>,_IO_read_ptr:ref<array<char,1>>,_IO_read_end:ref<array<char,1>>,_IO_read_base:ref<array<char,1>>,_IO_write_base:ref<array<char,1>>,_IO_write_ptr:ref<array<char,1>>,_IO_write_end:ref<array<char,1>>,_IO_buf_base:ref<array<char,1>>,_IO_buf_end:ref<array<char,1>>,_IO_save_base:ref<array<char,1>>,_IO_backup_base:ref<array<char,1>>,_IO_save_end:ref<array<char,1>>,_markers:ref<array<'_IO_marker,1>>,_chain:ref<array<'_IO_FILE,1>>,_fileno:int<4>,_flags2:int<4>,_old_offset:int<8>,_cur_column:uint<2>,_vtable_offset:char,_shortbuf:vector<char,1>,_lock:anyRef,_offset:int<8>,__pad1:anyRef,__pad2:anyRef,__pad3:anyRef,__pad4:anyRef,__pad5:uint<8>,_mode:int<4>,_unused2:vector<char,20>>, '_IO_marker=struct<_next:ref<array<'_IO_marker,1>>,_sbuf:ref<array<'_IO_FILE,1>>,_pos:int<4>>},1>>) //
struct FILE* fopen(char*, char*);
static struct FILE* fopen_wrap(void* _closure, char* var_133, char* var_134) { return fopen(var_133, var_134); }

// start code fragment :: Prototype for external function: printf ... type: ((ref<array<char,1>>,var_list)->int<4>) //
int printf(char*, ...);

// start code fragment :: Prototype for external function: exit ... type: ((int<4>)->unit) //
void exit(int);
static void exit_wrap(void* _closure, int var_135) { exit(var_135); }

// start code fragment :: Prototype for external function: fread ... type: ((anyRef,uint<8>,uint<8>,ref<array<rec '_IO_FILE.{'_IO_FILE=struct<_flags:int<4>,_IO_read_ptr:ref<array<char,1>>,_IO_read_end:ref<array<char,1>>,_IO_read_base:ref<array<char,1>>,_IO_write_base:ref<array<char,1>>,_IO_write_ptr:ref<array<char,1>>,_IO_write_end:ref<array<char,1>>,_IO_buf_base:ref<array<char,1>>,_IO_buf_end:ref<array<char,1>>,_IO_save_base:ref<array<char,1>>,_IO_backup_base:ref<array<char,1>>,_IO_save_end:ref<array<char,1>>,_markers:ref<array<'_IO_marker,1>>,_chain:ref<array<'_IO_FILE,1>>,_fileno:int<4>,_flags2:int<4>,_old_offset:int<8>,_cur_column:uint<2>,_vtable_offset:char,_shortbuf:vector<char,1>,_lock:anyRef,_offset:int<8>,__pad1:anyRef,__pad2:anyRef,__pad3:anyRef,__pad4:anyRef,__pad5:uint<8>,_mode:int<4>,_unused2:vector<char,20>>, '_IO_marker=struct<_next:ref<array<'_IO_marker,1>>,_sbuf:ref<array<'_IO_FILE,1>>,_pos:int<4>>},1>>)->uint<8>) //
unsigned long fread(void*, unsigned long, unsigned long, struct FILE*);
static unsigned long fread_wrap(void* _closure, void* var_136, unsigned long var_137, unsigned long var_138, struct FILE* var_139) { return fread(var_136, var_137, var_138, var_139); }

// start code fragment :: Prototype for external function: fclose ... type: ((ref<array<rec '_IO_FILE.{'_IO_FILE=struct<_flags:int<4>,_IO_read_ptr:ref<array<char,1>>,_IO_read_end:ref<array<char,1>>,_IO_read_base:ref<array<char,1>>,_IO_write_base:ref<array<char,1>>,_IO_write_ptr:ref<array<char,1>>,_IO_write_end:ref<array<char,1>>,_IO_buf_base:ref<array<char,1>>,_IO_buf_end:ref<array<char,1>>,_IO_save_base:ref<array<char,1>>,_IO_backup_base:ref<array<char,1>>,_IO_save_end:ref<array<char,1>>,_markers:ref<array<'_IO_marker,1>>,_chain:ref<array<'_IO_FILE,1>>,_fileno:int<4>,_flags2:int<4>,_old_offset:int<8>,_cur_column:uint<2>,_vtable_offset:char,_shortbuf:vector<char,1>,_lock:anyRef,_offset:int<8>,__pad1:anyRef,__pad2:anyRef,__pad3:anyRef,__pad4:anyRef,__pad5:uint<8>,_mode:int<4>,_unused2:vector<char,20>>, '_IO_marker=struct<_next:ref<array<'_IO_marker,1>>,_sbuf:ref<array<'_IO_FILE,1>>,_pos:int<4>>},1>>)->int<4>) //
int fclose(struct FILE*);
static int fclose_wrap(void* _closure, struct FILE* var_140) { return fclose(var_140); }

// start code fragment :: Prototype for external function: strtok ... type: ((ref<array<char,1>>,ref<array<char,1>>)->ref<array<char,1>>) //
char* strtok(char*, char*);
static char* strtok_wrap(void* _closure, char* var_141, char* var_142) { return strtok(var_141, var_142); }

// start code fragment :: Prototype for external function: strchr ... type: ((ref<array<char,1>>,int<4>)->ref<array<char,1>>) //
char* strchr(char*, int);
static char* strchr_wrap(void* _closure, char* var_143, int var_144) { return strchr(var_143, var_144); }

// start code fragment :: Prototype for external function: atoi ... type: ((ref<array<char,1>>)->int<4>) //
static int atoi_wrap(void* _closure, char* var_145) { return atoi(var_145); }

// start code fragment :: Prototype for external function: atof ... type: ((ref<array<char,1>>)->real<8>) //
double atof(char*);
static double atof_wrap(void* _closure, char* var_146) { return atof(var_146); }

// start code fragment :: Prototype for external function: atol ... type: ((ref<array<char,1>>)->int<8>) //
long atol(char*);
static long atol_wrap(void* _closure, char* var_147) { return atol(var_147); }

// start code fragment :: Definition of readSettings ... type: ((ref<array<char,1>>)->struct<numSources:uint<4>,x:int<4>,y:int<4>,scale:real<8>,dt:real<8>,friction:real<8>,height:real<8>,abortVelocity:real<8>,minSteps:uint<4>,maxSteps:uint<8>>) //
struct Settings readSettings(char* line){
	struct Settings settings;
	char* token = strtok(line, " ,");
	((*(&((settings).numSources))) = ((unsigned int)(atoi((token)))));
	((token) = strtok(0, " ,"));
	((*(&((settings).x))) = atoi((token)));
	((token) = strtok(0, " ,"));
	((*(&((settings).y))) = atoi((token)));
	((token) = strtok(0, " ,"));
	((*(&((settings).scale))) = atof((token)));
	((token) = strtok(0, " ,"));
	((*(&((settings).dt))) = atof((token)));
	((token) = strtok(0, " ,"));
	((*(&((settings).friction))) = atof((token)));
	((token) = strtok(0, " ,"));
	((*(&((settings).height))) = atof((token)));
	((token) = strtok(0, " ,"));
	((*(&((settings).abortVelocity))) = atof((token)));
	((token) = strtok(0, " ,"));
	((*(&((settings).minSteps))) = ((unsigned int)(atoi((token)))));
	((token) = strtok(0, " ,"));
	((*(&((settings).maxSteps))) = ((unsigned long)(atol((token)))));
	return (settings);
}
static struct Settings readSettings_wrap(void* _closure, char* line) { return readSettings(line); }

// start code fragment :: Prototype for external function: strcmp ... type: ((ref<array<char,1>>,ref<array<char,1>>)->int<4>) //
int strcmp(char*, char*);
static int strcmp_wrap(void* _closure, char* var_148, char* var_149) { return strcmp(var_148, var_149); }

// start code fragment :: Definition of readSource ... type: ((ref<array<char,1>>)->struct<type:int<4>,pos:vector<real<8>,2>,mult:real<8>,size:real<8>>) //
struct Source readSource(char* line){
	struct Source src;
	char* token = strtok(line, " ,");
	if((strcmp((token), "Linear")==0)) { ((*(&((src).type))) = 0); } else  { ((*(&((src).type))) = 1); };
	((token) = strtok(0, " ,"));
	((((*(&((src).pos))).data[((unsigned int)(0))])) = atof((token)));
	((token) = strtok(0, " ,"));
	((((*(&((src).pos))).data[((unsigned int)(1))])) = atof((token)));
	((token) = strtok(0, " ,"));
	((*(&((src).mult))) = atof((token)));
	((token) = strtok(0, " ,"));
	((*(&((src).size))) = atof((token)));
	return (src);
}
static struct Source readSource_wrap(void* _closure, char* line) { return readSource(line); }

// start code fragment :: vector_type_declaration of __insieme_type_6 <=> vector<struct<type:int<4>,pos:vector<real<8>,2>,mult:real<8>,size:real<8>>,4> //
typedef struct ___insieme_type_6 { 
    struct Source data[4];
} __insieme_type_6;

// A constructor initializing a vector of the type __insieme_type_6 uniformly
static inline __insieme_type_6 __insieme_type_6_init_uniform(struct Source value) {
	__insieme_type_6 res;
	for (int i=0; i<4;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: type_declaration_Image //
struct Image { 
    unsigned int** data;
    int x;
    int y;
};

// start code fragment :: Definition of create_image ... type: ((int<4>,int<4>)->struct<data:ref<array<ref<array<uint<4>,1>>,1>>,x:int<4>,y:int<4>>) //
struct Image create_image(int x, int y){
	unsigned int* block = (((unsigned int*){malloc(sizeof(unsigned int*)*(((sizeof(unsigned int)*((unsigned long)(x)))*((unsigned long)(y)))/sizeof(unsigned int)))}));
	unsigned int** index = (((unsigned int**){malloc(sizeof(unsigned int**)*((sizeof(unsigned int*)*((unsigned long)(x)))/sizeof(unsigned int*)))}));
	for(int var_15 = 0; var_15 < x; var_15 += 1)  { ((((index)[((unsigned int)(var_15))])) = (&((block)[((unsigned int)((var_15*x)))]))); };
	return ((struct Image){(index),
		x,
		y
	});
}
static struct Image create_image_wrap(void* _closure, int x, int y) { return create_image(x, y); }

// start code fragment :: type_declaration_Trace //
struct Trace { 
    unsigned int target;
    unsigned long numSteps;
};

// start code fragment :: Prototype for external function: sqrt ... type: ((real<8>)->real<8>) //
double sqrt(double);
static double sqrt_wrap(void* _closure, double var_150) { return sqrt(var_150); }

// start code fragment :: Definition of __insieme_supp_7 ... type: ((ref<vector<real<8>,2>>,ref<vector<real<8>,2>>)->unit) //
void __insieme_supp_7(__insieme_type_1* var_45, __insieme_type_1* var_46){
	((((*var_46).data[((unsigned int)(0))])) = (((*var_45).data[((unsigned int)(0))])));
	((((*var_46).data[((unsigned int)(1))])) = (((*var_45).data[((unsigned int)(1))])));
}
static void __insieme_supp_7_wrap(void* _closure, __insieme_type_1* var_45, __insieme_type_1* var_46) { __insieme_supp_7(var_45, var_46); }

// start code fragment :: Definition of __insieme_supp_8 ... type: ((ref<vector<real<8>,2>>,ref<vector<real<8>,2>>)->unit) //
void __insieme_supp_8(__insieme_type_1* var_48, __insieme_type_1* var_49){
	((((*var_48).data[((unsigned int)(0))])) = (((*var_49).data[((unsigned int)(0))])));
	((((*var_48).data[((unsigned int)(1))])) = (((*var_49).data[((unsigned int)(1))])));
}
static void __insieme_supp_8_wrap(void* _closure, __insieme_type_1* var_48, __insieme_type_1* var_49) { __insieme_supp_8(var_48, var_49); }

// start code fragment :: Definition of getTarget ... type: ((real<8>,real<8>,ref<array<struct<type:int<4>,pos:vector<real<8>,2>,mult:real<8>,size:real<8>>,1>>,uint<4>,real<8>,real<8>,real<8>,uint<4>,uint<8>,real<8>)->struct<target:uint<4>,numSteps:uint<8>>) //
struct Trace getTarget(double i, double j, struct Source* sources, unsigned int num_sources, double dt, double friction, double height, unsigned int min_steps, unsigned long max_steps, double abortVelocity){
	__insieme_type_1 pos = ((__insieme_type_1){{i, j}});
	__insieme_type_1 vel = ((__insieme_type_1){{((double)(0)), ((double)(0))}});
	__insieme_type_1 acc = ((__insieme_type_1){{((double)(0)), ((double)(0))}});
	__insieme_type_1 acc_new = ((__insieme_type_1){{((double)(0)), ((double)(0))}});
	__insieme_type_1 acc_old = ((__insieme_type_1){{((double)(0)), ((double)(0))}});
	double sqrt_dt = sqrt(dt);
	for(unsigned long var_51 = ((unsigned long)(0)); var_51 < max_steps; var_51 += 1) {
		((((pos).data[((unsigned int)(0))])) = ((((pos).data[((unsigned int)(0))]))+(((((vel).data[((unsigned int)(0))]))*dt)+((sqrt_dt)*(((2.0/3.0)*(((acc).data[((unsigned int)(0))])))-((1.0/6.0)*(((acc_old).data[((unsigned int)(0))]))))))));
		((((pos).data[((unsigned int)(1))])) = ((((pos).data[((unsigned int)(1))]))+(((((vel).data[((unsigned int)(1))]))*dt)+((sqrt_dt)*(((2.0/3.0)*(((acc).data[((unsigned int)(1))])))-((1.0/6.0)*(((acc_old).data[((unsigned int)(1))]))))))));
		((((acc_new).data[((unsigned int)(0))])) = ((double)(0)));
		((((acc_new).data[((unsigned int)(1))])) = ((double)(0)));
		for(unsigned int var_44 = ((unsigned int)(0)); var_44 < num_sources; var_44 += 1) {
			struct Source* cur = (&(sources[var_44]));
			__insieme_type_1 r = ((__insieme_type_1){{((((pos).data[((unsigned int)(0))]))-(((*(&((((cur)[0])).pos))).data[((unsigned int)(0))]))), ((((pos).data[((unsigned int)(1))]))-(((*(&((((cur)[0])).pos))).data[((unsigned int)(1))])))}});
			if((((unsigned int)((*(&((((cur)[0])).type)))))==((unsigned int)(0)))){
				((((acc_new).data[((unsigned int)(0))])) = ((((acc_new).data[((unsigned int)(0))]))-((*(&((((cur)[0])).mult)))*(((r).data[((unsigned int)(0))])))));
				((((acc_new).data[((unsigned int)(1))])) = ((((acc_new).data[((unsigned int)(1))]))-((*(&((((cur)[0])).mult)))*(((r).data[((unsigned int)(1))])))));
			} else {
				double dist = sqrt((((((((pos).data[((unsigned int)(0))]))-(((*(&((((cur)[0])).pos))).data[((unsigned int)(0))])))*((((pos).data[((unsigned int)(0))]))-(((*(&((((cur)[0])).pos))).data[((unsigned int)(0))]))))+(((((pos).data[((unsigned int)(1))]))-(((*(&((((cur)[0])).pos))).data[((unsigned int)(1))])))*((((pos).data[((unsigned int)(1))]))-(((*(&((((cur)[0])).pos))).data[((unsigned int)(1))])))))+(height*height)));
				((((acc_new).data[((unsigned int)(0))])) = ((((acc_new).data[((unsigned int)(0))]))-(((*(&((((cur)[0])).mult)))/(((dist)*(dist))*(dist)))*(((r).data[((unsigned int)(0))])))));
				((((acc_new).data[((unsigned int)(1))])) = ((((acc_new).data[((unsigned int)(1))]))-(((*(&((((cur)[0])).mult)))/(((dist)*(dist))*(dist)))*(((r).data[((unsigned int)(1))])))));
			};
			if((((var_51>((unsigned long)(min_steps)))&&(sqrt((((((r).data[((unsigned int)(0))]))*(((r).data[((unsigned int)(0))])))+((((r).data[((unsigned int)(1))]))*(((r).data[((unsigned int)(1))])))))<(*(&((((cur)[0])).size)))))&&(sqrt((((((vel).data[((unsigned int)(0))]))*(((vel).data[((unsigned int)(0))])))+((((vel).data[((unsigned int)(1))]))*(((vel).data[((unsigned int)(1))])))))<abortVelocity))) { return ((struct Trace){var_44,
				var_51
			}); };
		};
		((((acc_new).data[((unsigned int)(0))])) = ((((acc_new).data[((unsigned int)(0))]))-((((vel).data[((unsigned int)(0))]))*friction)));
		((((acc_new).data[((unsigned int)(1))])) = ((((acc_new).data[((unsigned int)(1))]))-((((vel).data[((unsigned int)(1))]))*friction)));
		((((vel).data[((unsigned int)(0))])) = ((((vel).data[((unsigned int)(0))]))+(dt*((((1.0/3.0)*(((acc_new).data[((unsigned int)(0))])))+((5.0/6.0)*(((acc).data[((unsigned int)(0))]))))-((1.0/6.0)*(((acc_old).data[((unsigned int)(0))])))))));
		((((vel).data[((unsigned int)(1))])) = ((((vel).data[((unsigned int)(1))]))+(dt*((((1.0/3.0)*(((acc_new).data[((unsigned int)(1))])))+((5.0/6.0)*(((acc).data[((unsigned int)(1))]))))-((1.0/6.0)*(((acc_old).data[((unsigned int)(1))])))))));
		__insieme_supp_7(&acc, &acc_old);
		__insieme_supp_8(&acc, &acc_new);
	};
	return ((struct Trace){num_sources,
		max_steps
	});
}
static struct Trace getTarget_wrap(void* _closure, double i, double j, struct Source* sources, unsigned int num_sources, double dt, double friction, double height, unsigned int min_steps, unsigned long max_steps, double abortVelocity) { return getTarget(i, j, sources, num_sources, dt, friction, height, min_steps, max_steps, abortVelocity); }

// start code fragment :: Definition of print_target_image_ASCII ... type: ((struct<data:ref<array<ref<array<uint<4>,1>>,1>>,x:int<4>,y:int<4>>,uint<4>)->unit) //
void print_target_image_ASCII(struct Image image, unsigned int sources) { for(int var_8 = 0; var_8 < (image.x); var_8 += 1) {
	for(int var_7 = 0; var_7 < (image.y); var_7 += 1)  { if(((image.data)[((unsigned int)(var_8))][((unsigned int)(var_7))]==((unsigned int)(0)))) { printf(" ", 0); } else  { if(((image.data)[((unsigned int)(var_8))][((unsigned int)(var_7))]==sources)) { printf("X", 0); } else  { printf("%c", ((((unsigned int)(((int)('A'))))+(image.data)[((unsigned int)(var_8))][((unsigned int)(var_7))])-((unsigned int)(1)))); }; }; };
	printf("\n", 0);
}; }
static void print_target_image_ASCII_wrap(void* _closure, struct Image image, unsigned int sources) { print_target_image_ASCII(image, sources); }

// start code fragment :: vector_type_declaration of __insieme_type_9 <=> vector<uint<1>,2> //
typedef struct ___insieme_type_9 { 
    unsigned char data[2];
} __insieme_type_9;

// A constructor initializing a vector of the type __insieme_type_9 uniformly
static inline __insieme_type_9 __insieme_type_9_init_uniform(unsigned char value) {
	__insieme_type_9 res;
	for (int i=0; i<2;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: type_declaration_bmp_magic //
struct bmp_magic { 
    __insieme_type_9 magic;
};

// start code fragment :: Prototype for external function: fwrite ... type: ((anyRef,uint<8>,uint<8>,ref<array<rec '_IO_FILE.{'_IO_FILE=struct<_flags:int<4>,_IO_read_ptr:ref<array<char,1>>,_IO_read_end:ref<array<char,1>>,_IO_read_base:ref<array<char,1>>,_IO_write_base:ref<array<char,1>>,_IO_write_ptr:ref<array<char,1>>,_IO_write_end:ref<array<char,1>>,_IO_buf_base:ref<array<char,1>>,_IO_buf_end:ref<array<char,1>>,_IO_save_base:ref<array<char,1>>,_IO_backup_base:ref<array<char,1>>,_IO_save_end:ref<array<char,1>>,_markers:ref<array<'_IO_marker,1>>,_chain:ref<array<'_IO_FILE,1>>,_fileno:int<4>,_flags2:int<4>,_old_offset:int<8>,_cur_column:uint<2>,_vtable_offset:char,_shortbuf:vector<char,1>,_lock:anyRef,_offset:int<8>,__pad1:anyRef,__pad2:anyRef,__pad3:anyRef,__pad4:anyRef,__pad5:uint<8>,_mode:int<4>,_unused2:vector<char,20>>, '_IO_marker=struct<_next:ref<array<'_IO_marker,1>>,_sbuf:ref<array<'_IO_FILE,1>>,_pos:int<4>>},1>>)->uint<8>) //
unsigned long fwrite(void*, unsigned long, unsigned long, struct FILE*);
static unsigned long fwrite_wrap(void* _closure, void* var_151, unsigned long var_152, unsigned long var_153, struct FILE* var_154) { return fwrite(var_151, var_152, var_153, var_154); }

// start code fragment :: type_declaration_bmp_header //
struct bmp_header { 
    unsigned int filesz;
    unsigned short creator1;
    unsigned short creator2;
    unsigned int bmp_offset;
};

// start code fragment :: type_declaration_bmp_info_header //
struct bmp_info_header { 
    unsigned int header_sz;
    int width;
    int height;
    unsigned short nplanes;
    unsigned short bitspp;
    unsigned int compress_type;
    unsigned int bmp_bytesz;
    int hres;
    int vres;
    unsigned int ncolors;
    unsigned int nimpcolors;
};

// start code fragment :: type_declaration_Color //
struct Color { 
    unsigned char r;
    unsigned char g;
    unsigned char b;
};

// start code fragment :: Definition of getColor ... type: ((uint<4>,uint<4>,uint<8>,uint<8>)->struct<r:uint<1>,g:uint<1>,b:uint<1>>) //
struct Color getColor(unsigned int target, unsigned int distance, unsigned long minSteps, unsigned long maxSteps){
	struct Color color;
	{
		int var_66 = ((int)(target));
		switch(var_66) {
		case ((unsigned int)(0)):
			((color) = ((struct Color){((unsigned char)(255)),
				((unsigned char)(255)),
				((unsigned char)(255))
			})); break;
		case ((unsigned int)(1)):
			((color) = ((struct Color){((unsigned char)(255)),
				((unsigned char)(0)),
				((unsigned char)(0))
			})); break;
		case ((unsigned int)(2)):
			((color) = ((struct Color){((unsigned char)(0)),
				((unsigned char)(255)),
				((unsigned char)(0))
			})); break;
		case ((unsigned int)(3)):
			((color) = ((struct Color){((unsigned char)(0)),
				((unsigned char)(0)),
				((unsigned char)(255))
			})); break;
		case ((unsigned int)(4)):
			((color) = ((struct Color){((unsigned char)(255)),
				((unsigned char)(255)),
				((unsigned char)(0))
			})); break;
		case ((unsigned int)(5)):
			((color) = ((struct Color){((unsigned char)(0)),
				((unsigned char)(255)),
				((unsigned char)(255))
			})); break;
		case ((unsigned int)(6)):
			((color) = ((struct Color){((unsigned char)(255)),
				((unsigned char)(0)),
				((unsigned char)(255))
			})); break;
		};
	};
	double factor = (1.0-(((double)((((unsigned long)(distance))-minSteps)))/((double)((maxSteps-minSteps)))));
	((*(&((color).r))) = ((unsigned char)((((double)(((int)((*(&((color).r)))))))*(factor)))));
	((*(&((color).g))) = ((unsigned char)((((double)(((int)((*(&((color).g)))))))*(factor)))));
	((*(&((color).b))) = ((unsigned char)((((double)(((int)((*(&((color).b)))))))*(factor)))));
	return (color);
}
static struct Color getColor_wrap(void* _closure, unsigned int target, unsigned int distance, unsigned long minSteps, unsigned long maxSteps) { return getColor(target, distance, minSteps, maxSteps); }

// start code fragment :: Definition of write_image ... type: ((struct<data:ref<array<ref<array<uint<4>,1>>,1>>,x:int<4>,y:int<4>>,struct<data:ref<array<ref<array<uint<4>,1>>,1>>,x:int<4>,y:int<4>>,ref<array<char,1>>,uint<8>,uint<8>)->unit) //
void write_image(struct Image target, struct Image dist, char* filename, unsigned long minSteps, unsigned long maxSteps){
	struct FILE* out = fopen(filename, "wb");
	if((!(!((out)==0)))){
		printf("Error opening output file!\n", 0);
		return;
	};
	struct bmp_magic magic = ((struct bmp_magic){((__insieme_type_9){{((unsigned char)(0x42)), ((unsigned char)(0x4D))}})
	});
	fwrite((void*)(&magic), sizeof(struct bmp_magic), ((unsigned long)(1)), (out));
	struct bmp_header header;
	((*(&((header).bmp_offset))) = ((unsigned int)(((sizeof(struct bmp_magic)+sizeof(struct bmp_header))+sizeof(struct bmp_info_header)))));
	((*(&((header).filesz))) = ((unsigned int)((((unsigned long)((*(&((header).bmp_offset)))))+((sizeof(struct Color)*((unsigned long)((target.x))))*((unsigned long)((target.y))))))));
	((*(&((header).creator1))) = ((unsigned short)(0)));
	((*(&((header).creator2))) = ((unsigned short)(0)));
	fwrite((void*)(&header), sizeof(struct bmp_header), ((unsigned long)(1)), (out));
	struct bmp_info_header info;
	((*(&((info).header_sz))) = ((unsigned int)(40)));
	((*(&((info).width))) = (target.x));
	((*(&((info).height))) = (target.y));
	((*(&((info).nplanes))) = ((unsigned short)(1)));
	((*(&((info).bitspp))) = ((unsigned short)(24)));
	((*(&((info).compress_type))) = ((unsigned int)(0)));
	((*(&((info).bmp_bytesz))) = ((unsigned int)(0)));
	((*(&((info).hres))) = 1000);
	((*(&((info).vres))) = 1000);
	((*(&((info).ncolors))) = ((unsigned int)(0)));
	((*(&((info).nimpcolors))) = ((unsigned int)(0)));
	fwrite((void*)(&info), sizeof(struct bmp_info_header), ((unsigned long)(1)), (out));
	for(int var_84 = 0; var_84 < (target.x); var_84 += 1) {
		for(int var_81 = 0; var_81 < (target.y); var_81 += 1) {
			struct Color color = getColor((target.data)[((unsigned int)(var_84))][((unsigned int)(var_81))], (dist.data)[((unsigned int)(var_84))][((unsigned int)(var_81))], minSteps, maxSteps);
			fwrite((void*)(&color), sizeof(struct Color), ((unsigned long)(1)), (out));
		};
		char pad = ((char)(0));
		int c = (3*(target.y));
		while((((c)%4)!=0)) {
			fwrite((void*)(&pad), ((unsigned long)(1)), ((unsigned long)(1)), (out));
			((c)++);
		};
	};
	fclose((out));
}
static void write_image_wrap(void* _closure, struct Image target, struct Image dist, char* filename, unsigned long minSteps, unsigned long maxSteps) { write_image(target, dist, filename, minSteps, maxSteps); }

// start code fragment :: Definition of delete_image ... type: ((ref<array<struct<data:ref<array<ref<array<uint<4>,1>>,1>>,x:int<4>,y:int<4>>,1>>)->unit) //
void delete_image(struct Image* image){
	free((((*(&(((image[0])).data)))[((unsigned int)(0))])));
	free((*(&(((image[0])).data))));
}
static void delete_image_wrap(void* _closure, struct Image* image) { delete_image(image); }

// start code fragment :: Definition of main ... type: ((int<4>,ref<array<ref<array<char,1>>,1>>)->int<4>) //
int main(int argc, char** argv){
	struct Settings settings = ((struct Settings){((unsigned int)(4)),
		60,
		60,
		800.0,
		0.01,
		0.01,
		0.3,
		0.01,
		((unsigned int)(400)),
		((unsigned long)(100000))
	});
	struct Source* sources;
	if((argc>1)){
		struct FILE* fp;
		__insieme_type_5 file;
		((fp) = fopen(((argv[((unsigned int)(1))])), "r"));
		if(((fp) == 0)){
			printf("Cannot open file.\n", 0);
			exit(1);
		};
		fread((void*)((char*)((*(&file)).data)), ((unsigned long)(1)), ((unsigned long)((512*8))), (fp));
		fclose((fp));
		char* line = strtok((((char*){(file).data})), "\n\r");
		while((((int)((((line)[((unsigned int)(0))]))))==35))  { ((line) = strtok(0, "\n\r")); };
		char* next = strchr((line), 0);
		((settings) = readSettings((line)));
		((sources) = (((struct Source*){malloc(sizeof(struct Source*)*(((unsigned long)((*(&((settings).numSources)))))/sizeof(struct Source)))})));
		{
			int i = 0;
			while((((unsigned int)((i)))<(*(&((settings).numSources))))) {
				((line) = strtok((&((next)[((unsigned int)(1))])), "\n\r"));
				((next) = strchr((line), 0));
				if((((int)((((line)[((unsigned int)(0))]))))!=35)) { ((((sources)[((unsigned int)(((i)++)))])) = readSource((line))); };
			};
		};
	} else  { ((sources) = ((((__insieme_type_6){{((struct Source){0,
		((__insieme_type_1){{((double)(0)), ((double)(0))}}),
		0.01,
		0.02
	}), ((struct Source){1,
		((__insieme_type_1){{((double)(1)), ((double)(0))}}),
		0.08,
		0.02
	}), ((struct Source){1,
		((__insieme_type_1){{(((double)(0))-0.5), 0.866025404}}),
		0.08,
		0.02
	}), ((struct Source){1,
		((__insieme_type_1){{(((double)(0))-0.5), (((double)(0))-0.866025404)}}),
		0.08,
		0.02
	})}})).data)); };
	unsigned int num_sources = (*(&((settings).numSources)));
	int x = (*(&((settings).x)));
	int y = (*(&((settings).y)));
	double scale = (*(&((settings).scale)));
	double dt = (*(&((settings).dt)));
	double friction = (*(&((settings).friction)));
	double height = (*(&((settings).height)));
	unsigned int min_steps = (*(&((settings).minSteps)));
	unsigned long max_steps = (*(&((settings).maxSteps)));
	double abortVelocity = (*(&((settings).abortVelocity)));
	struct Image image = create_image((x), (y));
	struct Image dist = create_image((x), (y));
	 { for(int var_113 = 0; var_113 < (x); var_113 += 1)  { for(int var_112 = 0; var_112 < (y); var_112 += 1) {
		double curX = (((((double)(0))-1.0)+((((double)(var_113))/((double)(((x)-1))))*2.0))*(scale));
		double curY = (((((double)(0))-1.0)+((((double)(var_112))/((double)(((y)-1))))*2.0))*(scale));
		struct Trace res = getTarget((curX), (curY), (sources), (num_sources), (dt), (friction), (height), (min_steps), (max_steps), (abortVelocity));
		((((((*(&((image).data)))[((unsigned int)(var_113))]))[((unsigned int)(var_112))])) = (*(&((res).target))));
		((((((*(&((dist).data)))[((unsigned int)(var_113))]))[((unsigned int)(var_112))])) = ((unsigned int)((*(&((res).numSteps))))));
	}; }; };
	unsigned long maxSteps = ((unsigned long)(0));
	unsigned long minSteps = (max_steps);
	for(int var_131 = 0; var_131 < (x); var_131 += 1)  { for(int var_130 = 0; var_130 < (y); var_130 += 1) {
		((maxSteps) = (((((unsigned long)((((((*(&((dist).data)))[((unsigned int)(var_131))]))[((unsigned int)(var_130))]))))>(maxSteps)))?(((unsigned long)((((((*(&((dist).data)))[((unsigned int)((var_131)))]))[((unsigned int)((var_130)))]))))):((maxSteps))));
		((minSteps) = (((((unsigned long)((((((*(&((dist).data)))[((unsigned int)(var_131))]))[((unsigned int)(var_130))]))))<(minSteps)))?(((unsigned long)((((((*(&((dist).data)))[((unsigned int)((var_131)))]))[((unsigned int)((var_130)))]))))):((minSteps))));
	}; };
	printf("Number of steps calculated: %llu .. %llu\n", (minSteps), (maxSteps));
	print_target_image_ASCII((image), (num_sources));
	write_image((image), (dist), "out.bmp", (minSteps), (maxSteps));
	delete_image((&image));
	delete_image((&dist));
}
static int main_wrap(void* _closure, int argc, char** argv) { return main(argc, argv); }
