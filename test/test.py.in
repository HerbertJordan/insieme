import os, subprocess, shlex, sys, shutil, time


# define the gcc compiler to be used
#CC = "gcc -pedantic-errors -Wall"
CC = "gcc -fshow-column -Wall -Wl,--no-as-needed"

# the location of the insieme compiler
INSIEMEC='${CMAKE_BINARY_DIR}/code/driver/main'

#
# GCC = gcc comparison version
# SMP = simple backend
# SEQ = the sequential backend
# RUN = the runtime backend
#

#
# Figure out command to compute version of Code
#
INSIEME_VERSION="\"\\\"${insieme_version}\\\"\""

USE_SMP = 0
USE_SEQ = 0
USE_RUN = 1
USE_OCL = 0

# compiler flags
SRC_DIR = "${CMAKE_SOURCE_DIR}"
INSIEME_FLAGS = "--std=c99 -I."
CFLAGS_GCC = "-pipe -O3 --std=c99 -I."
CFLAGS_SMP = "-pipe -O3 --std=c99 -I. -I{0}/code/simple_backend/include/insieme/simple_backend/runtime".format(SRC_DIR)
CFLAGS_SEQ = "-pipe -O3 --std=c99 -I."
CFLAGS_RUN = "-pipe -O3 --std=gnu99 -I. -I{0}/code/runtime/include -D_XOPEN_SOURCE=700 -D_GNU_SOURCE -DINSIEME_VERSION={1}".format(SRC_DIR, INSIEME_VERSION)
CFLAGS_OCL = "-pipe -O3 --std=gnu99 -I. -I{0}/code/runtime/include -D_XOPEN_SOURCE=700 -DUSE_OPENCL=ON -D_GNU_SOURCE -DINSIEME_VERSION={1}".format(SRC_DIR, INSIEME_VERSION)

# linker flags
LDFLAGS_GCC = "-lm -lpthread -lrt"
LDFLAGS_SMP = "-lm -lpthread -linsieme_simple_backend_runtime -L${CMAKE_BINARY_DIR}/code/simple_backend"
LDFLAGS_SEQ = "-lm"
LDFLAGS_RUN = "-lm -lpthread -ldl -lrt"
LDFLAGS_OCL = "-lm -lpthread -ldl -lrt -lOpenCL"


doChecks 		= 1
runOcl 		= 0
printErr 		= 0
verbose 		= 0
mockRun 		= 0 # only output command strings, don't actually run them
force 		= 0 # forces the test script to build and run test cases even when ref-files match
cleanRef 		= 0 # removes individual reference files before running tests

class bcolors:
	HEADER = '\033[95m'
	OKBLUE = '\033[94m'
	OKGREEN = '\033[92m'
	WARNING = '\033[93m'
	FAIL = '\033[91m'
	DEBUG = '\033[37m'
	ENDC = '\033[0m'

	def disable(self):
		self.HEADER = ''
		self.OKBLUE = ''
		self.OKGREEN = ''
		self.WARNING = ''
		self.FAIL = ''
		self.ENDC = ''

def run_cmd(cmd):
	start = time.time()

	res = None

	if mockRun:
		sys.stdout.write("\n" + bcolors.OKGREEN  + cmd  + bcolors.ENDC + "\n")
	else:
		# run process ...
		pid = subprocess.Popen( cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, shell=True)

		# waits for process and collects everything send to stdout/stderr
		res = pid.communicate()[0]
		elapsed = time.time() - start
		sys.stderr.write("[{0:.4f} secs]\n".format(elapsed) )

		if verbose:
			sys.stderr.write(bcolors.DEBUG)
			sys.stderr.write("@------------------ start output --------------------\n")
			sys.stderr.write("Executed command: " + cmd + "\n")
			sys.stderr.write("@----------------------------------------------------\n")
			sys.stderr.write(str(res))
			sys.stderr.write("@------------------- end output ---------------------\n")
			sys.stderr.write(bcolors.ENDC)

		# determine information to be included within the result
		if pid.returncode == 0:
			return None;

	return res

# Wrapper for os.system calls to enable mock run
def run_prog(cmd):
	if mockRun:
		sys.stdout.write("\n" + bcolors.OKGREEN  + cmd  + bcolors.ENDC + "\n")
		return 0
	return os.system(cmd)

def check_for_error(test_case, ret):
	if ret is not None:
		sys.stderr.write(bcolors.FAIL + '@ {0}: [FAILED]'.format(test_case) + bcolors.ENDC + '\n')
		sys.stderr.write(bcolors.FAIL + "@------------------ start cause --------------------" + bcolors.ENDC + "\n")

		if verbose:
			# print the entire output
			sys.stderr.write(ret)
		else:
			# print only first 15 lines
			lines = ret.splitlines();
			for i in range(min(len(lines), 15)):
				sys.stderr.write( str(lines[i]) )
				sys.stderr.write("\n")

			if len(lines) > 15:
				sys.stderr.write("\n   -- output truncated - run with --verbose to see full output -- \n\n")

		sys.stderr.write(bcolors.FAIL + "@------------------- end cause ---------------------" + bcolors.ENDC + "\n\n")

	return ret

def remove_if_exist(file_name):
	if os.path.exists(file_name) :
		os.remove(file_name)

def check_diff(test_case_name, ref, test):
	refFile = ref + ".tmp"
	testFile = test + ".tmp"
	os.system("sort {0} > {1}".format(ref, refFile))
	os.system("sort {0} > {1}".format(test, testFile))
	ret = run_cmd("diff {0} {1}".format(refFile, testFile))
	remove_if_exist(refFile)
	remove_if_exist(testFile)
	return not check_for_error(test_case_name, ret)

def ocl_check_diff(test_case_name, ref, test):
	refFile = ref + ".tmp"
	testFile = test + ".tmp"
	os.system("tail -1 {0} > {1}".format(ref, refFile))
	os.system("tail -1 {0} > {1}".format(test, testFile))
	ret = run_cmd("diff {0} {1}".format(refFile, testFile))
	remove_if_exist(refFile)
	remove_if_exist(testFile)
	return not check_for_error(test_case_name, ret)
	

def run_test_case(test_case_name, home_folder):
	sys.stderr.write("#-----------------------------------------------------\n")
	sys.stderr.write("# {0}/{1}  ".format(home_folder, test_case_name))

	path = home_folder + "/" + test_case_name
	save_path = os.getcwd()

	if not os.path.isdir(path):
		sys.stderr.write(bcolors.FAIL + " --- NO SUCH TEST CASE!!" + bcolors.ENDC + "\n")
		return 1

	sys.stderr.write("\n");

	# name of the file contaning the reference IR for the current test
	refIr   = test_case_name + '.ir.ref'
	# name of the file containing the generated IR for the case test
	testIr  = test_case_name + '.ir'
	# name of the file containing the reference C output for the current test
	refSMP  = test_case_name + '.insieme.smp.c.ref'
	refSEQ  = test_case_name + '.insieme.seq.c.ref'
	refRUN  = test_case_name + '.insieme.run.c.ref'
	refOCL  = test_case_name + '.insieme.ocl.c.ref'

	# name of the file containing the generated C output for the current test
	testSMP = test_case_name + '.insieme.smp.c'
	testSEQ = test_case_name + '.insieme.seq.c'
	testRUN = test_case_name + '.insieme.run.c'
	testOCL = test_case_name + '.insieme.ocl.c'

	# name of the file containing the reference dot dump of the CFG
	refCfg  = test_case_name + '.cfg.ref'
	# name of the file containing the generated dot dump of the CFG
	testCfg  = test_case_name + '.cfg'
	# name of the file containing the generated XML dump
	testXML  = test_case_name + '.xml'

	try:
		inputs = test_case_name + '.c'
		if os.path.exists(path + '/inputs.data'):
			inputs = " ".join([x.strip() for x in open(path + '/inputs.data').read().split(',')])

		insiemeFlags = ''
		if os.path.exists(path + '/insieme.flags'):
			insiemeFlags = " ".join([x.strip() for x in open(path + '/insieme.flags').read().format(**{'SRC_DIR': SRC_DIR}).split(',')])

		gccFlagsRef = ''
		if os.path.exists(path + '/ref-gcc.flags'):
			gccFlagsRef = " ".join([x.strip() for x in open(path + '/ref-gcc.flags').read().format(**{'SRC_DIR': SRC_DIR}).split(',')])

		gccFlagsTest = ''
		if os.path.exists(path + '/test-gcc.flags'):
			gccFlagsTest = " ".join([x.strip() for x in open(path + '/test-gcc.flags').read().format(**{'SRC_DIR': SRC_DIR}).split(',')])

		os.chdir(path)

		# clear reference files if requested
		if cleanRef :
			remove_if_exist(refIr)
			remove_if_exist(refCfg)
			if USE_SMP:
				remove_if_exist(refSMP)
			if USE_SEQ:
				remove_if_exist(refSEQ)
			if USE_RUN:
				remove_if_exist(refRUN)
			if USE_OCL:
				remove_if_exist(refOCL)

		# RUN insieme, check semantic and generate CFG / XML and IR dump
		if doChecks :
			sys.stderr.write(" * Running Compiler Checks...            ")
			sys.stderr.flush()

			command_str = "{INSIEMEC} {INSIEME_FLAGS} {INPUTS} --dump-ir={IR_DUMP} --dump-cfg {CFG_DUMP} --dump-xml {XML_DUMP} --col-wrap=120 -S {FLAGS}".format(
							**{'INSIEMEC': INSIEMEC, 'INSIEME_FLAGS':INSIEME_FLAGS, 'INPUTS': inputs, 'IR_DUMP': testIr,
							   'FLAGS': insiemeFlags, 'CFG_DUMP': testCfg, 'XML_DUMP' : testXML})

			ret = run_cmd( command_str )
			if check_for_error(test_case_name, ret):
				return 1

		# run non-cl tests
		if(test_case_name != "ocl_kernel" and test_case_name != "openCore"):

			if USE_SMP:
				# RUN insieme to generate simple-backend output code
				sys.stderr.write(" * Running Compiler => SMP ...           ")
				sys.stderr.flush()
				ret = run_cmd( "{INSIEMEC} {INSIEME_FLAGS} {FLAGS} {INPUTS} -b pthread -o {OUTPUT}".format(
								**{'INSIEMEC': INSIEMEC, 'INSIEME_FLAGS':INSIEME_FLAGS, 'FLAGS': insiemeFlags, 'INPUTS': inputs, 'OUTPUT': testSMP}))
				if check_for_error(test_case_name, ret):
					return 1

			if USE_SEQ:
				sys.stderr.write(" * Running Compiler => SEQ...            ")
				sys.stderr.flush()
				ret = run_cmd( "{INSIEMEC} {INSIEME_FLAGS} {FLAGS} {INPUTS} -b sequential -o {OUTPUT}".format(
								**{'INSIEMEC': INSIEMEC, 'INSIEME_FLAGS':INSIEME_FLAGS, 'FLAGS': insiemeFlags, 'INPUTS': inputs, 'OUTPUT': testSEQ}))
				if check_for_error(test_case_name, ret):
					return 1

			if USE_RUN:
				sys.stderr.write(" * Running Compiler => RUN...            ")
				sys.stderr.flush()
				ret = run_cmd( "{INSIEMEC} {INSIEME_FLAGS} {FLAGS} {INPUTS} -b runtime -o {OUTPUT}".format(
								**{'INSIEMEC': INSIEMEC, 'INSIEME_FLAGS':INSIEME_FLAGS, 'FLAGS': insiemeFlags, 'INPUTS': inputs, 'OUTPUT': testRUN}))
				if check_for_error(test_case_name, ret):
					return 1

			if USE_OCL:
				sys.stderr.write(" * Running Compiler => OCL...            ")
				sys.stderr.flush()
				ret = run_cmd( "{INSIEMEC} {INSIEME_FLAGS} {FLAGS} {INPUTS} -b ocl -o {OUTPUT}".format(
								**{'INSIEMEC': INSIEMEC, 'INSIEME_FLAGS':INSIEME_FLAGS, 'FLAGS': insiemeFlags, 'INPUTS': inputs, 'OUTPUT': testOCL}))
				if check_for_error(test_case_name, ret):
					return 1


			runTests = force or mockRun

			if not mockRun:
				sys.stderr.write(" * -> " + bcolors.OKGREEN  +"Success." + bcolors.ENDC + "\n")

				# verify results
				if not os.path.exists(refIr) and os.path.exists(testIr):
				  shutil.copyfile(testIr, refIr)
				  runTests = 1 # Reference is not there, we have to run the test to make sure the translation was correct


				sys.stderr.write(" * Comparing generated IR...             ")
				if check_diff(test_case_name, refIr, testIr):
					sys.stderr.write(" * -> " + bcolors.OKGREEN  +"Success." + bcolors.ENDC + "\n")
				else:
					sys.stderr.write(" * -> " + bcolors.WARNING  +"Different!" + bcolors.ENDC + "\n")
					runTests = 1 # => file comparison failed, but program might still be OK

				if not os.path.exists(refCfg) and os.path.exists(testCfg):
					shutil.copyfile(testCfg, refCfg)
					runTests = 1 # Reference is not there, we have to run the test to make sure the translation was correct

				sys.stderr.write(" * Comparing generated CFG...            ")
				if check_diff(test_case_name, refCfg, testCfg):
					sys.stderr.write(" * -> " + bcolors.OKGREEN  +"Success." + bcolors.ENDC + "\n")
				else:
					sys.stderr.write(" * -> " + bcolors.WARNING  +"Different!" + bcolors.ENDC + "\n")
					runTests = 1 # => file comparison failed, but program might still be OK

				if USE_SMP:
					if not os.path.exists(refSMP) and os.path.exists(testSMP):
						runTests = 1 # Reference is not there, we have to run the test to make sure the translation was correct
					else:
						sys.stderr.write(" * Comparing generated SMP output...     ")
						if check_diff(test_case_name, refSMP, testSMP):
							sys.stderr.write(" * -> " + bcolors.OKGREEN  +"Success." + bcolors.ENDC + "\n")
						else:
							sys.stderr.write(" * -> " + bcolors.WARNING  +"Different!" + bcolors.ENDC + "\n")
							runTests = 1 # => file comparison failed, but program might still be OK

				if USE_SEQ:
					if not os.path.exists(refSEQ) and os.path.exists(testSEQ):
						runTests = 1 # Reference is not there, we have to run the test to make sure the translation was correct
					else:
						sys.stderr.write(" * Comparing generated SEQ output...     ")
						if check_diff(test_case_name, refSEQ, testSEQ):
							sys.stderr.write(" * -> " + bcolors.OKGREEN  +"Success." + bcolors.ENDC + "\n")
						else:
							sys.stderr.write(" * -> " + bcolors.WARNING  +"Different!" + bcolors.ENDC + "\n")
							runTests = 1 # => file comparison failed, but program might still be OK

				if USE_RUN:
					if not os.path.exists(refRUN) and os.path.exists(testRUN):
						runTests = 1 # Reference is not there, we have to run the test to make sure the translation was correct
					else:
						sys.stderr.write(" * Comparing generated RUN output...     ")
						if check_diff(test_case_name, refRUN, testRUN):
							sys.stderr.write(" * -> " + bcolors.OKGREEN  +"Success." + bcolors.ENDC + "\n")
						else:
							sys.stderr.write(" * -> " + bcolors.WARNING  +"Different!" + bcolors.ENDC + "\n")
							runTests = 1 # => file comparison failed, but program might still be OK

				if USE_OCL:
					if not os.path.exists(refOCL) and os.path.exists(testOCL):
						runTests = 1 # Reference is not there, we have to run the test to make sure the translation was correct
					else:
						sys.stderr.write(" * Comparing generated OCL output...     ")
						if check_diff(test_case_name, refRUN, testOCL):
							sys.stderr.write(" * -> " + bcolors.OKGREEN  +"Success." + bcolors.ENDC + "\n")
						else:
							sys.stderr.write(" * -> " + bcolors.WARNING  +"Different!" + bcolors.ENDC + "\n")
							runTests = 1 # => file comparison failed, but program might still be OK


			# test whether executables are missing within #bin directory
			ref_exec = test_case_name + '.ref'
			test_smp_exec = test_case_name + '.smp.test'
			test_seq_exec = test_case_name + '.seq.test'
			test_run_exec = test_case_name + '.run.test'
			test_ocl_exec = test_case_name + '.ocl.test'
			if not runTests and os.path.exists("../#bin/"):
				if  ((not os.path.exists("../#bin/" + ref_exec)) or
					 (USE_SMP and not os.path.exists("../#bin/" + test_smp_exec)) or
					 (USE_SEQ and not os.path.exists("../#bin/" + test_seq_exec)) or
					 (USE_RUN and not os.path.exists("../#bin/" + test_run_exec)) or
					 (USE_OCL and not os.path.exists("../#bin/" + test_ocl_exec))) :
					runTests = 1 # => ensure that all binaries are present within #bin

			if runTests:

				# file containing the output of the reference program
				ref_out = "ref.out"
				# file containing the output of the test program
				test_smp_out = "smp.test.out"
				test_seq_out = "seq.test.out"
				test_run_out = "run.test.out"
				test_ocl_out = "ocl.test.out"

				sys.stderr.write(" * Compiling C input...                  ")
				sys.stderr.flush()

				if check_for_error(test_case_name, run_cmd( "{CC} {CFLAGS} -o {OUTPUT} {INPUTS} {LDFLAGS} {GCCFLAGS}".format(
									**{'CC':CC, 'CFLAGS':CFLAGS_GCC, 'INPUTS':inputs, 'OUTPUT':ref_exec, 'LDFLAGS':LDFLAGS_GCC, 'GCCFLAGS':gccFlagsRef})
								)) : return 1

				if USE_SMP:
					sys.stderr.write(" * Compiling generated SMP output...     ")
					sys.stderr.flush()

					if check_for_error(test_case_name, run_cmd( "{CC} {CFLAGS} -o {OUTPUT} {INPUTS} {LDFLAGS} {GCCFLAGS}".format(
										**{'CC':CC, 'CFLAGS':CFLAGS_SMP, 'INPUTS':testSMP, 'OUTPUT':test_smp_exec, 'LDFLAGS':LDFLAGS_SMP, 'GCCFLAGS':gccFlagsTest})
									)) : return 1

				if USE_SEQ:
					sys.stderr.write(" * Compiling generated SEQ output...     ")
					sys.stderr.flush()

					if check_for_error(test_case_name, run_cmd( "{CC} {CFLAGS} -o {OUTPUT} {INPUTS} {LDFLAGS} {GCCFLAGS}".format(
										**{'CC':CC, 'CFLAGS':CFLAGS_SEQ, 'INPUTS':testSEQ, 'OUTPUT':test_seq_exec, 'LDFLAGS':LDFLAGS_SEQ, 'GCCFLAGS':gccFlagsTest})
									)) : return 1

				if USE_RUN:
					sys.stderr.write(" * Compiling generated RUN output...     ")
					sys.stderr.flush()

					if check_for_error(test_case_name, run_cmd( "{CC} {CFLAGS} -o {OUTPUT} {INPUTS} {LDFLAGS} {GCCFLAGS}".format(
										**{'CC':CC, 'CFLAGS':CFLAGS_RUN, 'INPUTS':testRUN, 'OUTPUT':test_run_exec, 'LDFLAGS':LDFLAGS_RUN, 'GCCFLAGS':gccFlagsTest})
									)) : return 1

				if USE_OCL:
					sys.stderr.write(" * Compiling generated OCL output...     ")
					sys.stderr.flush()

					if check_for_error(test_case_name, run_cmd( "{CC} {CFLAGS} -o {OUTPUT} {INPUTS} {LDFLAGS} {GCCFLAGS}".format(
										**{'CC':CC, 'CFLAGS':CFLAGS_OCL, 'INPUTS':testOCL, 'OUTPUT':test_ocl_exec, 'LDFLAGS':LDFLAGS_OCL, 'GCCFLAGS':gccFlagsTest})
									)) : return 1

				if not mockRun:
					sys.stderr.write(" * -> " + bcolors.OKGREEN  +"Success." + bcolors.ENDC + "\n")


				input_args = None
				if os.path.exists("prog.input"):
					input_args = open("prog.input").read().strip()

				sys.stderr.write(" * Running input program...              ")
				sys.stderr.flush()

				start = time.time()
				cmd = input_args.format(**{'PATH':'./', 'EXEC':ref_exec}) if input_args else ref_exec
				exitValue = run_prog("./{0} > {1}".format(cmd, ref_out)) >> 8

				if not mockRun:
					if exitValue != 0:
						sys.stderr.write(bcolors.FAIL + '[FAILED - {0}]'.format(exitValue) + bcolors.ENDC + '\n');
						return 1

					sys.stderr.write("[{0:.4f} secs]\n".format(time.time() - start))

				if USE_SMP:
					sys.stderr.write(" * Running SMP program...                ")
					sys.stderr.flush()

					ldPath = os.getenv("LD_LIBRARY_PATH", "");
					os.putenv("LD_LIBRARY_PATH", ldPath + ":${CMAKE_BINARY_DIR}/code/simple_backend");
					cmd = input_args.format(**{'PATH':'./', 'EXEC':test_smp_exec}) if input_args else test_smp_exec
					start = time.time()
					exitValue = run_prog("./{0} > {1} 2> /dev/null".format(cmd, test_smp_out)) >> 8;
					if not mockRun:
						if exitValue != 0:
							if exitValue == 139:
								sys.stderr.write(bcolors.FAIL + '[FAILED - SegFault]' + bcolors.ENDC + '\n');
							else:
								sys.stderr.write(bcolors.FAIL + '[FAILED - {0}]'.format(exitValue) + bcolors.ENDC + '\n');
							return 1

						sys.stderr.write("[{0:.4f} secs]\n".format(time.time() - start))
					os.putenv("LD_LIBRARY_PATH", ldPath);

				if USE_SEQ:
					sys.stderr.write(" * Running SEQ program...                ")
					sys.stderr.flush()

					cmd = input_args.format(**{'PATH':'./', 'EXEC':test_seq_exec}) if input_args else test_seq_exec
					start = time.time()
					exitValue = run_prog("./{0} > {1} 2> /dev/null".format(cmd, test_seq_out)) >> 8;
					if not mockRun:
						if exitValue != 0:
							if exitValue == 139:
								sys.stderr.write(bcolors.FAIL + '[FAILED - SegFault]' + bcolors.ENDC + '\n');
							else:
								sys.stderr.write(bcolors.FAIL + '[FAILED - {0}]'.format(exitValue) + bcolors.ENDC + '\n');
							return 1

						sys.stderr.write("[{0:.4f} secs]\n".format(time.time() - start))

				if USE_RUN:
					sys.stderr.write(" * Running RUN program...                ")
					sys.stderr.flush()

					ldPath = os.getenv("LD_LIBRARY_PATH", "");
					os.putenv("LD_LIBRARY_PATH", ldPath + ":${CMAKE_BINARY_DIR}/code/runtime/pmlib");
					cmd = input_args.format(**{'PATH':'./', 'EXEC':test_run_exec}) if input_args else test_run_exec
					start = time.time()
					exitValue = run_prog("./{0} > {1} 2> /dev/null".format(cmd, test_run_out)) >> 8;
					if not mockRun:
						if exitValue != 0:
							if exitValue == 139:
								sys.stderr.write(bcolors.FAIL + '[FAILED - SegFault]' + bcolors.ENDC + '\n');
							else:
								sys.stderr.write(bcolors.FAIL + '[FAILED - {0}]'.format(exitValue) + bcolors.ENDC + '\n');
							return 1

						sys.stderr.write("[{0:.4f} secs]\n".format(time.time() - start))
					os.putenv("LD_LIBRARY_PATH", ldPath);

				if USE_OCL:
					sys.stderr.write(" * Running OCL program...                ")
					sys.stderr.flush()

					cmd = input_args.format(**{'PATH':'./', 'EXEC':test_ocl_exec}) if input_args else test_ocl_exec
					start = time.time()
					exitValue = run_prog("./{0} > {1} 2> /dev/null".format(cmd, test_ocl_out)) >> 8;
					if not mockRun:
						if exitValue != 0:
							if exitValue == 139:
								sys.stderr.write(bcolors.FAIL + '[FAILED - SegFault]' + bcolors.ENDC + '\n');
							else:
								sys.stderr.write(bcolors.FAIL + '[FAILED - {0}]'.format(exitValue) + bcolors.ENDC + '\n');
							return 1

						sys.stderr.write("[{0:.4f} secs]\n".format(time.time() - start))

				if not mockRun:
					sys.stderr.write(" * -> " + bcolors.OKGREEN  +"Success." + bcolors.ENDC + "\n")


					# ---------------------------- Checking Outputs ----------------------------

					if USE_SMP:
						sys.stderr.write(" * Checking SMP program output...        ")
						if not check_diff(test_case_name, ref_out, test_smp_out):
							return 1

					if USE_SEQ:
						sys.stderr.write(" * Checking SEQ program output...        ")
						if not check_diff(test_case_name, ref_out, test_seq_out):
							return 1

					if USE_RUN:
						sys.stderr.write(" * Checking RUN program output...        ")
						if not check_diff(test_case_name, ref_out, test_run_out):
							return 1

					if USE_OCL:
						sys.stderr.write(" * Checking OCL program output...        ")
						if not ocl_check_diff(test_case_name, ref_out, test_ocl_out):
							return 1

					sys.stderr.write(" * -> " + bcolors.OKGREEN  + "Success." + bcolors.ENDC + "\n")

					# if the test is successful move the executable in the ../#bin directory for further benchmarking
					if os.path.exists("../#bin/"):
						if os.path.exists("../#bin/" + ref_exec):
							os.remove("../#bin/" + ref_exec)
						shutil.move(ref_exec, "../#bin/")

						if USE_SMP:
							if os.path.exists("../#bin/" + test_smp_exec):
								os.remove("../#bin/" + test_smp_exec)
							shutil.move(test_smp_exec, "../#bin/")

						if USE_SEQ:
							if os.path.exists("../#bin/" + test_seq_exec):
								os.remove("../#bin/" + test_seq_exec)
							shutil.move(test_seq_exec, "../#bin/")

						if USE_RUN:
							if os.path.exists("../#bin/" + test_run_exec):
								os.remove("../#bin/" + test_run_exec)
							shutil.move(test_run_exec, "../#bin/")
						if USE_OCL:
							if os.path.exists("../#bin/" + test_ocl_exec):
								os.remove("../#bin/" + test_ocl_exec)
							shutil.move(test_ocl_exec, "../#bin/")
					os.remove(ref_out)
					if USE_SMP:
						os.remove(test_smp_out)
					if USE_SEQ:
						os.remove(test_seq_out)
					if USE_RUN:
						os.remove(test_run_out)
					if USE_OCL:
						os.remove(test_ocl_out)

					# update reference file if necessary
					# IR references
					if os.path.exists(testIr):
						shutil.copyfile(testIr, refIr)
					if os.path.exists(testCfg):
						shutil.copyfile(testCfg, refCfg)
					if os.path.exists(testSMP):
						shutil.copyfile(testSMP, refSMP)
					if os.path.exists(testSEQ):
						shutil.copyfile(testSEQ, refSEQ)
					if os.path.exists(testRUN):
						shutil.copyfile(testRUN, refRUN)
					if os.path.exists(testOCL):
						shutil.copyfile(testOCL, refOCL)


		else:  # it is an ocl test
			if mockRun:
				sys.stdout.write("ERROR: Mock runs not supported for OpenCL")
				sys.exit(-1)

			sys.stderr.write(" * Running Compiler => OCL ...          ")
			ret = run_cmd( "{INSIEMEC} {INSIEME_FLAGS} {FLAGS} {INPUTS} -b ocl -o {OUTPUT}".format(
							**{'INSIEMEC': INSIEMEC, 'INSIEME_FLAGS':INSIEME_FLAGS, 'FLAGS': insiemeFlags, 'INPUTS': inputs, 'OUTPUT': testSMP}))
			if check_for_error(test_case_name, ret):
				return 1


			if runOcl:
				sys.stderr.write(" * Compiling OpenCL host program...     ")

				ret = run_cmd( "{CC} -O3 {CFLAGS} -o host runTestKernels.c {LDFLAGS} {GCCFLAGS}".format(
									**{'CC':CC, 'CFLAGS':CFLAGS_GCC, 'LDFLAGS':os.path.expandvars(LDFLAGS_GCC), 'GCCFLAGS':os.path.expandvars(gccFlagsRef)})
								)
				if(ret != None) :
					sys.stderr.write("Failed to build OpenCL host program:\n" + ret + "\n")

					if check_for_error(test_case_name, ret):
						return 1

				sys.stderr.write(" * -> " + bcolors.OKGREEN  +"Success." + bcolors.ENDC + "\n")

				sys.stderr.write(" * Running input program...             ")

				ref_out = "ref.out"
				start = time.time()

				os.system("./host ocl_kernel.c > {0}".format( ref_out))
				sys.stderr.write(" [{0:.4f} secs]\n".format(time.time() - start))
				sys.stderr.write(" * Running output program...            ")

				test_out = "test.out"
				start = time.time()

				os.system("./host ocl_kernel.insieme.smp.c > {0}".format( test_out))
				sys.stderr.write(" [{0:.4f} secs]\n".format(time.time() - start))

				sys.stderr.write(" * Checking generated program output... ")
				if not check_diff(test_case_name, ref_out, test_out):
					return 1
				sys.stderr.write(" * -> " + bcolors.OKGREEN  + "Success." + bcolors.ENDC + "\n")
				map(lambda x : os.remove(x), [testIr, testSMP, ref_out, test_out])

		sys.stderr.write(bcolors.OKGREEN + "@ [SUCCESS]" + bcolors.ENDC + "\n")
#'''
#	except:
#		sys.str ("Error: " + sys.exc_info()[0])

	finally:
		os.chdir(save_path)

	return 0

def runIt( abortOnFail, basedir, tests ) :
	passed = []
	failed = []
#	sys.stderr.write("@@ Running from base folder: {0} @@\n".format(basedir))
	for cur in tests :
		head, tail = os.path.split(cur)
		if os.path.exists(basedir + "/" + cur + "/test.cfg") :
			subtest = [cur + "/" + test_case for test_case in open(cur + '/test.cfg').read().split('\n') if len(test_case) > 0 and not test_case.startswith('#')]
			subFailed, subPassed = runIt(abortOnFail, basedir, subtest)
			failed += [ name for name in subFailed ]
			passed += [ name for name in subPassed ]

		elif len(head) != 0 and head != tail:
			if run_test_case(tail, basedir + "/" + head) :
				failed.append(cur)
			else :
				passed.append(cur)

		elif len(failed) == 0 :
			if run_test_case(cur, basedir) :
				failed.append(cur)
				if ( abortOnFail ) :
					return failed, passed
			else :
				passed.append(cur)

	return failed, passed


def main():
	os.chdir('${CMAKE_CURRENT_SOURCE_DIR}/test/')

	abortOnFail = False;

	#check flags
	global USE_SEQ
	global USE_RUN
	global USE_OCL

	for arg in sys.argv[1:] :
		if(arg == "--runOpenCL") :
			global runOcl
			runOcl = 1
			sys.argv.remove(arg)
		elif(arg == "--printErrors") :
			global printErr
			printErr = 1
			sys.argv.remove(arg)
		elif(arg == "--mockRun") :
			global mockRun
			mockRun = 1
			sys.argv.remove(arg)
		elif(arg == "--noChecks") :
			global doChecks
			doChecks = 0
			sys.argv.remove(arg)			
		elif arg == "--clean" :
			for test in [test_case for test_case in open('test.cfg').read().split('\n') if len(test_case) > 0 and not test_case.startswith('#')]:
				os.system( "rm -f ${CMAKE_CURRENT_SOURCE_DIR}/test/{0}/*.ref".format(test) )
			sys.argv.remove(arg)
		elif(arg == "--verbose") :
			global verbose
			# global INSIEMEC
			verbose = 1
			# INSIEMEC = INSIEMEC + " -S"
			sys.argv.remove(arg)
		elif(arg == "--abortOnFail") :
			abortOnFail = True
			sys.argv.remove(arg)
		elif(arg == "-f") :
			global force
			force = 1
			sys.argv.remove(arg)
		elif(arg == "-c") :
			global cleanRef
			cleanRef = 1
			sys.argv.remove(arg)
		elif(arg == "-seq") :
			USE_SEQ = 1
			USE_RUN = 0
			USE_OCL = 0
			sys.argv.remove(arg)
		elif(arg == "-run") :
			USE_SEQ = 0
			USE_RUN = 1
			USE_OCL = 0
			sys.argv.remove(arg)
		elif(arg == "-ocl") :
			USE_SEQ = 0
			USE_RUN = 0
			USE_OCL = 1
			sys.argv.remove(arg)
		elif(arg == "-full") :
			USE_SEQ = 1
			USE_RUN = 1
			USE_OCL = 0
			sys.argv.remove(arg)
		elif(arg.startswith("-")) :
			sys.stdout.write("ERROR: unknown argument: " + arg + "\n")
			# print valid argument info
			sys.exit(-1)

	tests = []
	if len(sys.argv) > 1:
		# run the specified tests only
		tests = sys.argv[1:]
	elif USE_OCL == 1:
		
		# read test cases from test.cfg file
		tests = [ "ocl/" + test_case for test_case in open('ocl/test.cfg').read().split('\n') if len(test_case) > 0 and not test_case.startswith('#')]

	elif os.path.exists('./test.cfg'):
		# read test cases from test.cfg file
		tests = [test_case for test_case in open('test.cfg').read().split('\n') if len(test_case) > 0 and not test_case.startswith('#')]
	else:
		tests = [x for x in os.listdir(".") if os.path.isdir(os.path.join('./', x)) and not x.startswith('#')]
		tests.sort() # sort the test cases by name

	failed, passed = runIt( abortOnFail, ".", tests )

	# failed = filter(lambda x: run_test_case(x), tests)

	if not mockRun:
		# print summary
		sys.stderr.write("###############################\n")
		sys.stderr.write("#          Summary            #\n")
		sys.stderr.write("#-----------------------------#\n")
		sys.stderr.write("# Total number of tests: {0:4} #\n".format( len(passed) + len(failed) ))
		sys.stderr.write("# -> SUCCEEDED: {0:13} #\n".format(len(passed)))
		sys.stderr.write("# -> FAILED:    {0:13} #\n".format(len(failed)))

		for test in failed:
			sys.stderr.write("#    - {0:22} #\n".format(test))

		sys.stderr.write("###############################\n")

	return  os._exit(len(failed));

if __name__ == "__main__":
    sys.exit(main())

