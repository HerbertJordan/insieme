import os, subprocess, shlex, sys, shutil, time


# define the gcc compiler to be used
#CC = "gcc -pedantic-errors -Wall"
CC = "gcc -fshow-column -Wall"

# the location of the insieme compiler
INSIEMEC='${CMAKE_BINARY_DIR}/code/driver/main'

#
# GCC = gcc comparison version
# SBE = simple backend
# RBE = real backend
#

USE_SBE = 1
USE_RBE = 0

# compiler flags
INSIEME_FLAGS = "--std=c99 -I."
CFLAGS_GCC = "-O3 -g --std=c99 -I."
CFLAGS_SBE = "-O3 -g --std=c99 -I. -I${CMAKE_SOURCE_DIR}/code/simple_backend/include/insieme/simple_backend/runtime"
CFLAGS_RBE = "-O0 -g --std=c99 -I. -I${CMAKE_SOURCE_DIR}/code/runtime/include -D_XOPEN_SOURCE=700 -D_GNU_SOURCE"


# linker flags
LDFLAGS_GCC = "-lm -lpthread"
LDFLAGS_SBE = "-lm -lpthread -linsieme_simple_backend_runtime -L${CMAKE_BINARY_DIR}/code/simple_backend"
LDFLAGS_RBE = "-lm -lpthread -ldl -lrt"


runOcl = 0
printErr = 0
verbose = 0

class bcolors:
	HEADER = '\033[95m'
	OKBLUE = '\033[94m'
	OKGREEN = '\033[92m'
	WARNING = '\033[93m'
	FAIL = '\033[91m'
	DEBUG = '\033[37m'
	ENDC = '\033[0m'
	
	def disable(self):
		self.HEADER = ''
		self.OKBLUE = ''
		self.OKGREEN = ''
		self.WARNING = ''
		self.FAIL = ''
		self.ENDC = ''

def run_cmd(cmd):
	start = time.time()

	# run process ...
	pid = subprocess.Popen( shlex.split(cmd), stdout=subprocess.PIPE, stderr=subprocess.STDOUT)

	# waits for process and collects everything send to stdout/stderr	
	res = pid.communicate()[0]
	elapsed = time.time() - start
	sys.stderr.write(" [{0:.4f} secs]\n".format(elapsed) )

	if verbose:
		sys.stderr.write(bcolors.DEBUG)
		sys.stderr.write("@------------------ start output --------------------\n")
		sys.stderr.write("Executed command: " + cmd + "\n")
		sys.stderr.write("@----------------------------------------------------\n")
		sys.stderr.write(str(res))
		sys.stderr.write("@------------------- end output ---------------------\n")
		sys.stderr.write(bcolors.ENDC)

	# determine information to be included within the result
	if pid.returncode == 0:
		return None;

	return res

def check_for_error(test_case, ret):
	if ret is not None:
		sys.stderr.write(bcolors.FAIL + '@ {0}: [FAILED]'.format(test_case) + bcolors.ENDC + '\n')
		sys.stderr.write(bcolors.FAIL + "@------------------ start cause --------------------" + bcolors.ENDC + "\n")

		if verbose:
			# print the entire output
			sys.stderr.write(ret)
		else:
			# print only first 15 lines
			lines = ret.splitlines();
			for i in range(min(len(lines), 15)):
				sys.stderr.write( str(lines[i]) )
				sys.stderr.write("\n")

			if len(lines) > 15:
				sys.stderr.write("\n   -- output truncated - run with --verbose to see full output -- \n\n")

		sys.stderr.write(bcolors.FAIL + "@------------------- end cause ---------------------" + bcolors.ENDC + "\n\n")

	return ret
    
def check_diff(test_case_name, ref, test):
	ret = run_cmd("diff {0} {1}".format(ref, test))
	return not check_for_error(test_case_name, ret)

def run_test_case(test_case_name): 
	sys.stderr.write("#-----------------------------------------------------\n")
	sys.stderr.write("# {0}\n".format(test_case_name))

	# name of the file contaning the reference IR for the current test
	refIr   = test_case_name + '.ir.ref'
	# name of the file containing the generated IR for the case test
	testIr  = test_case_name + '.ir'
	# name of the file containing the reference C output for the current test
	refSBE  = test_case_name + '.insieme.sbe.c.ref'
	# name of the file containing the reference C output for the current test
	refRBE  = test_case_name + '.insieme.rbe.c.ref'
	# name of the file containing the SBE generated C output for the current test
	testSBE = test_case_name + '.insieme.sbe.c'
	# name of the file containing the RBE generated C output for the current test
	testRBE = test_case_name + '.insieme.rbe.c'
	# name of the file containing the reference dot dump of the CFG
	refCfg  = test_case_name + '.cfg.ref'
	# name of the file containing the generated dot dump of the CFG
	testCfg  = test_case_name + '.cfg'
	# name of the file containing the generated XML dump
	testXML  = test_case_name + '.xml'
	
	try: 
		inputs = test_case_name + '.c'
		if os.path.exists(test_case_name + '/inputs.data'):
			inputs = " ".join([x.strip() for x in open(test_case_name + '/inputs.data').read().split(',')])

		insiemeFlags = ''
		if os.path.exists(test_case_name + '/insieme.flags'):
			insiemeFlags = " ".join([x.strip() for x in open(test_case_name + '/insieme.flags').read().split(',')])

		gccFlagsRef = ''
		if os.path.exists(test_case_name + '/ref-gcc.flags'):
			gccFlagsRef = " ".join([x.strip() for x in open(test_case_name + '/ref-gcc.flags').read().split(',')])

		gccFlagsTest = ''
		if os.path.exists(test_case_name + '/test-gcc.flags'):
			gccFlagsTest = " ".join([x.strip() for x in open(test_case_name + '/test-gcc.flags').read().split(',')])

		os.chdir(test_case_name)
		# RUN insieme to generate the IR dump and C output

		# RUN insieme, check semantic and generate CFG / XML and IR dump
		sys.stderr.write(" * Running Compiler Checks...           ")
		ret = run_cmd( "{INSIEMEC} {INSIEME_FLAGS} {INPUTS} --dump-ir={IR_DUMP} --dump-cfg {CFG_DUMP} --dump-xml {XML_DUMP} --col-wrap=120 -S {FLAGS}".format(
						**{'INSIEMEC': INSIEMEC, 'INSIEME_FLAGS':INSIEME_FLAGS, 'INPUTS': inputs, 'IR_DUMP': testIr, 
						   'FLAGS': insiemeFlags, 'CFG_DUMP': testCfg, 'XML_DUMP' : testXML})) 
		if check_for_error(test_case_name, ret):
			return 1

		# run non-cl tests
		if(test_case_name != "ocl_kernel"):

			if USE_SBE:
				# RUN insieme to generate simple-backend output code
				sys.stderr.write(" * Running Compiler => SBE ...          ")
				ret = run_cmd( "{INSIEMEC} {INSIEME_FLAGS} {FLAGS} {INPUTS} -b pthread -o {OUTPUT}".format(
								**{'INSIEMEC': INSIEMEC, 'INSIEME_FLAGS':INSIEME_FLAGS, 'FLAGS': insiemeFlags, 'INPUTS': inputs, 'OUTPUT': testSBE})) 
				if check_for_error(test_case_name, ret):
					return 1		  

			if USE_RBE:
				sys.stderr.write(" * Running Compiler => RBE ...          ")
				ret = run_cmd( "{INSIEMEC} {INSIEME_FLAGS} {FLAGS} {INPUTS} -b runtime -o {OUTPUT}".format(
								**{'INSIEMEC': INSIEMEC, 'INSIEME_FLAGS':INSIEME_FLAGS, 'FLAGS': insiemeFlags, 'INPUTS': inputs, 'OUTPUT': testRBE})) 
				if check_for_error(test_case_name, ret):
					return 1
			  
			sys.stderr.write(" * -> " + bcolors.OKGREEN  +"Success." + bcolors.ENDC + "\n")


			# verify results
			runTests = 0
			if not os.path.exists(refIr) and os.path.exists(testIr):
			  shutil.copyfile(testIr, refIr)
			  runTests = 1 # Reference is not there, we have to run the test to make sure the translation was correct


			sys.stderr.write(" * Comparing generated IR...            ")
			if check_diff(test_case_name, refIr, testIr):
				sys.stderr.write(" * -> " + bcolors.OKGREEN  +"Success." + bcolors.ENDC + "\n")
			else:
				sys.stderr.write(" * -> " + bcolors.WARNING  +"Different!" + bcolors.ENDC + "\n")
				runTests = 1 # => file comparison failed, but program might still be OK

			if not os.path.exists(refCfg) and os.path.exists(testCfg):
				shutil.copyfile(testCfg, refCfg)
				runTests = 1 # Reference is not there, we have to run the test to make sure the translation was correct

			sys.stderr.write(" * Comparing generated CFG...           ")
			if check_diff(test_case_name, refCfg, testCfg):
				sys.stderr.write(" * -> " + bcolors.OKGREEN  +"Success." + bcolors.ENDC + "\n")
			else:
				sys.stderr.write(" * -> " + bcolors.WARNING  +"Different!" + bcolors.ENDC + "\n")
				runTests = 1 # => file comparison failed, but program might still be OK

			if USE_SBE:
				if not os.path.exists(refSBE) and os.path.exists(testSBE):
					runTests = 1 # Reference is not there, we have to run the test to make sure the translation was correct
				else:
					sys.stderr.write(" * Comparing generated SBE output...    ")
					if check_diff(test_case_name, refSBE, testSBE):
						sys.stderr.write(" * -> " + bcolors.OKGREEN  +"Success." + bcolors.ENDC + "\n")
					else:
						sys.stderr.write(" * -> " + bcolors.WARNING  +"Different!" + bcolors.ENDC + "\n")
						runTests = 1 # => file comparison failed, but program might still be OK
			
			if USE_RBE:
				if not os.path.exists(refRBE) and os.path.exists(testRBE):
					runTests = 1 # Reference is not there, we have to run the test to make sure the translation was correct
				else:
					sys.stderr.write(" * Comparing generated RBE output...    ")
					if check_diff(test_case_name, refRBE, testRBE):
						sys.stderr.write(" * -> " + bcolors.OKGREEN  +"Success." + bcolors.ENDC + "\n")
					else:
						sys.stderr.write(" * -> " + bcolors.WARNING  +"Different!" + bcolors.ENDC + "\n")
						runTests = 1 # => file comparison failed, but program might still be OK

			
			# test whether executables are missing within #bin directory
			ref_exec = test_case_name + '.ref'
			test_sbe_exec = test_case_name + '.sbe.test'
			test_rbe_exec = test_case_name + '.rbe.test'
			if not runTests and os.path.exists("../#bin/"):
				if  ((not os.path.exists("../#bin/" + ref_exec)) or 
					 (USE_SBE and not os.path.exists("../#bin/" + test_sbe_exec)) or 
					 (USE_RBE and not os.path.exists("../#bin/" + test_rbe_exec))) :
					runTests = 1 # => ensure that all binaries are present within #bin

			if runTests:

				# file containing the output of the reference program
				ref_out = "ref.out"
				# file containing the output of the test program
				test_sbe_out = "sbe.test.out"
				test_rbe_out = "rbe.test.out"

				sys.stderr.write(" * Compiling C input...                 ")
				if check_for_error(test_case_name, run_cmd( "{CC} {CFLAGS} -o {OUTPUT} {INPUTS} {LDFLAGS} {GCCFLAGS}".format(
									**{'CC':CC, 'CFLAGS':CFLAGS_GCC, 'INPUTS':inputs, 'OUTPUT':ref_exec, 'LDFLAGS':LDFLAGS_GCC, 'GCCFLAGS':gccFlagsRef})  
								)) : return 1

				if USE_SBE:
					sys.stderr.write(" * Compiling generated SBE output...    ")
					if check_for_error(test_case_name, run_cmd( "{CC} {CFLAGS} -o {OUTPUT} {INPUTS} {LDFLAGS} {GCCFLAGS}".format(
										**{'CC':CC, 'CFLAGS':CFLAGS_SBE, 'INPUTS':testSBE, 'OUTPUT':test_sbe_exec, 'LDFLAGS':LDFLAGS_SBE, 'GCCFLAGS':gccFlagsTest})
									)) : return 1

				if USE_RBE:
					sys.stderr.write(" * Compiling generated RBE output...    ")
					if check_for_error(test_case_name, run_cmd( "{CC} {CFLAGS} -o {OUTPUT} {INPUTS} {LDFLAGS} {GCCFLAGS}".format(
										**{'CC':CC, 'CFLAGS':CFLAGS_RBE, 'INPUTS':testRBE, 'OUTPUT':test_rbe_exec, 'LDFLAGS':LDFLAGS_RBE, 'GCCFLAGS':gccFlagsTest})
									)) : return 1

				sys.stderr.write(" * -> " + bcolors.OKGREEN  +"Success." + bcolors.ENDC + "\n")


				sys.stderr.write(" * Running input program...              ")
				start = time.time()
				exitValue = os.system("./{0} > {1}".format(ref_exec, ref_out)) >> 8
				if exitValue != 0:
					sys.stderr.write(bcolors.FAIL + '[FAILED - {0}]'.format(exitValue) + bcolors.ENDC + '\n');
					return 1

				sys.stderr.write("[{0:.4f} secs]\n".format(time.time() - start))
			
				if USE_SBE:
					sys.stderr.write(" * Running SBE program...                ")
					ldPath = os.getenv("LD_LIBRARY_PATH", "");
					os.putenv("LD_LIBRARY_PATH", ldPath + ":${CMAKE_BINARY_DIR}/code/simple_backend");
					start = time.time()
					exitValue = os.system("./{0} > {1} 2> /dev/null".format(test_sbe_exec, test_sbe_out)) >> 8;
					if exitValue != 0:
						if exitValue == 139:
							sys.stderr.write(bcolors.FAIL + '[FAILED - SegFault]' + bcolors.ENDC + '\n');
						else:
							sys.stderr.write(bcolors.FAIL + '[FAILED - {0}]'.format(exitValue) + bcolors.ENDC + '\n');
						return 1
				
					sys.stderr.write("[{0:.4f} secs]\n".format(time.time() - start))
					os.putenv("LD_LIBRARY_PATH", ldPath);

				if USE_RBE:
					sys.stderr.write(" * Running RBE program...                ")
					start = time.time()
					exitValue = os.system("./{0} > {1} 2> /dev/null".format(test_rbe_exec, test_rbe_out)) >> 8;
					if exitValue != 0:
						if exitValue == 139:
							sys.stderr.write(bcolors.FAIL + '[FAILED - SegFault]' + bcolors.ENDC + '\n');
						else:
							sys.stderr.write(bcolors.FAIL + '[FAILED - {0}]'.format(exitValue) + bcolors.ENDC + '\n');
						return 1
				
					sys.stderr.write("[{0:.4f} secs]\n".format(time.time() - start))

				sys.stderr.write(" * -> " + bcolors.OKGREEN  +"Success." + bcolors.ENDC + "\n")


				# ---------------------------- Checking Outputs ----------------------------

				if USE_SBE:
					sys.stderr.write(" * Checking SBE program output...       ")
					if not check_diff(test_case_name, ref_out, test_sbe_out):
						return 1

				if USE_RBE:
					sys.stderr.write(" * Checking RBE program output...       ")
					if not check_diff(test_case_name, ref_out, test_rbe_out):
						return 1

				sys.stderr.write(" * -> " + bcolors.OKGREEN  + "Success." + bcolors.ENDC + "\n")

				# if the test is successful move the executable in the ../#bin directory for further benchmarking
				if os.path.exists("../#bin/"):
					if os.path.exists("../#bin/" + ref_exec):
						os.remove("../#bin/" + ref_exec)
					shutil.move(ref_exec, "../#bin/")
			
					if USE_SBE:
						if os.path.exists("../#bin/" + test_sbe_exec):
							os.remove("../#bin/" + test_sbe_exec)
						shutil.move(test_sbe_exec, "../#bin/")

					if USE_RBE:
						if os.path.exists("../#bin/" + test_rbe_exec):
							os.remove("../#bin/" + test_rbe_exec)
						shutil.move(test_rbe_exec, "../#bin/")
			
				os.remove(ref_out)
				if USE_SBE:
					os.remove(test_sbe_out)
				if USE_RBE: 
					os.remove(test_rbe_out)

				# update reference file if necessary
				if not os.path.exists(refSBE) and os.path.exists(testSBE):
					shutil.copyfile(testSBE, refSBE)
				if not os.path.exists(refRBE) and os.path.exists(testRBE):
					shutil.copyfile(testRBE, refRBE)

			
		else:  # it is an ocl test

			sys.stderr.write(" * Running Compiler => OCL ...          ")
			ret = run_cmd( "{INSIEMEC} {INSIEME_FLAGS} {FLAGS} {INPUTS} -b ocl -o {OUTPUT}".format(
							**{'INSIEMEC': INSIEMEC, 'INSIEME_FLAGS':INSIEME_FLAGS, 'FLAGS': insiemeFlags, 'INPUTS': inputs, 'OUTPUT': testSBE})) 
			if check_for_error(test_case_name, ret):
				return 1		  


			if runOcl:
				sys.stderr.write(" * Compiling OpenCL host program...     ")

				ret = run_cmd( "{CC} -O3 {CFLAGS} -o host runTestKernels.c {LDFLAGS} {GCCFLAGS}".format(
									**{'CC':CC, 'CFLAGS':CFLAGS_GCC, 'LDFLAGS':os.path.expandvars(LDFLAGS_GCC), 'GCCFLAGS':os.path.expandvars(gccFlagsRef)})  
								)
				if(ret != None) :
					sys.stderr.write("Failed to build OpenCL host program:\n" + ret + "\n")
				
					if check_for_error(test_case_name, ret):
						return 1
		
				sys.stderr.write(" * -> " + bcolors.OKGREEN  +"Success." + bcolors.ENDC + "\n")

				sys.stderr.write(" * Running input program...             ")
			
				ref_out = "ref.out"
				start = time.time()

				os.system("./host ocl_kernel.c > {0}".format( ref_out))
				sys.stderr.write(" [{0:.4f} secs]\n".format(time.time() - start))
				sys.stderr.write(" * Running output program...            ")

				test_out = "test.out"	
				start = time.time()

				os.system("./host ocl_kernel.insieme.sbe.c > {0}".format( test_out))
				sys.stderr.write(" [{0:.4f} secs]\n".format(time.time() - start))

				sys.stderr.write(" * Checking generated program output... ")
				if not check_diff(test_case_name, ref_out, test_out):
					return 1
				sys.stderr.write(" * -> " + bcolors.OKGREEN  + "Success." + bcolors.ENDC + "\n")
				map(lambda x : os.remove(x), [testIr, testC, ref_out, test_out])
		
		sys.stderr.write(bcolors.OKGREEN + "@ [SUCCESS]" + bcolors.ENDC + "\n")
#'''
#	except: 
#		sys.str ("Error: " + sys.exc_info()[0])

	finally:
		os.chdir("../")

	return 0

def main():
	os.chdir('${CMAKE_CURRENT_SOURCE_DIR}/test/')

	abortOnFail = False;

	#check for opencl flag
	global USE_SBE
	global USE_RBE

	for arg in sys.argv[1:] :
		if(arg == "--runOpenCL") :
			global runOcl
			runOcl = 1
			sys.argv.remove(arg)
		if(arg == "--printErrors") :
			global printErr
			printErr = 1
			sys.argv.remove(arg)
		if arg == "--clean" :
			for test in [test_case for test_case in open('test.cfg').read().split('\n') if len(test_case) > 0 and not test_case.startswith('#')]:
				os.system( "rm -f ${CMAKE_CURRENT_SOURCE_DIR}/test/{0}/*.ref".format(test) )
			sys.argv.remove(arg)
		if(arg == "--verbose") :
			global verbose
			# global INSIEMEC
			verbose = 1
			# INSIEMEC = INSIEMEC + " -S"
			sys.argv.remove(arg)
		if(arg == "--abortOnFail") :
			abortOnFail = True
			sys.argv.remove(arg)
		if(arg == "--sbe") :
			USE_SBE = 1
			USE_RBE = 0
			sys.argv.remove(arg)
		if(arg == "--rbe") :
			USE_SBE = 0
			USE_RBE = 1
			sys.argv.remove(arg)
		if(arg == "--all") :
			USE_SBE = 1
			USE_RBE = 1
			sys.argv.remove(arg)


	tests = []
	if len(sys.argv) > 1:		
		# run the specified tests only
		tests = sys.argv[1:]
	elif os.path.exists('./test.cfg'):
		# read test cases from test.cfg file
		tests = [test_case for test_case in open('test.cfg').read().split('\n') if len(test_case) > 0 and not test_case.startswith('#')]
	else:
		tests = [x for x in os.listdir(".") if os.path.isdir(os.path.join('./', x)) and not x.startswith('#')]
		tests.sort() # sort the test cases by name
			
	passed = []
	failed = []
	for cur in tests :
		if len(failed) == 0 or (not abortOnFail) :
			if run_test_case(cur) :
				failed.append(cur)
			else :
				passed.append(cur)

	# failed = filter(lambda x: run_test_case(x), tests)
	
	# print summary
	sys.stderr.write("###############################\n")
	sys.stderr.write("#          Summary            #\n")
	sys.stderr.write("#-----------------------------#\n")
	sys.stderr.write("# Total number of tests: {0:4} #\n".format( len(passed) + len(failed) ))
	sys.stderr.write("# -> SUCCEEDED: {0:13} #\n".format(len(passed)))
	sys.stderr.write("# -> FAILED:    {0:13} #\n".format(len(failed)))

	for test in failed:
		sys.stderr.write("#    - {0:22} #\n".format(test))

	sys.stderr.write("###############################\n")
	
	return  os._exit(len(failed));

if __name__ == "__main__":
    sys.exit(main())
       
