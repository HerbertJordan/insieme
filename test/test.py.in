import os, subprocess, shlex, sys, shutil, time

INSIEMEC='${CMAKE_BINARY_DIR}/code/driver/main'
CFLAGS = "--std=c99 -I. -I${CMAKE_SOURCE_DIR}/code/simple_backend/include/insieme/simple_backend/runtime"
LDFLAGS_ORG = "-lm -lpthread -g"
LDFLAGS_RES = "-lm -lpthread -g -linsieme_simple_backend_runtime -L${CMAKE_BINARY_DIR}/code/simple_backend"
#CC = "gcc -pedantic-errors -Wall"
CC = "gcc"
runOcl = 0
printErr = 0
verbose = 0

class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    DEBUG = '\033[37m'
    ENDC = '\033[0m'

    def disable(self):
        self.HEADER = ''
        self.OKBLUE = ''
        self.OKGREEN = ''
        self.WARNING = ''
        self.FAIL = ''
        self.ENDC = ''

def run_cmd(cmd):
	start = time.time()

	# run process ...
	pid = subprocess.Popen( shlex.split(cmd), stdout=subprocess.PIPE, stderr=subprocess.STDOUT)

	# waits for process and collects everything send to stdout/stderr	
	res = pid.communicate()[0]
	elapsed = time.time() - start
	sys.stderr.write(" [{0:.4f} secs]\n".format(elapsed) )

	if verbose:
		sys.stderr.write(bcolors.DEBUG)
        	sys.stderr.write("@------------------ start output --------------------\n")
		sys.stderr.write("Executed command: " + cmd + "\n")
        	sys.stderr.write("@----------------------------------------------------\n")
		sys.stderr.write(res)
        	sys.stderr.write("@------------------- end output ---------------------\n")
		sys.stderr.write(bcolors.ENDC)

	# determine information to be included within the result
	if pid.returncode == 0:
		return None;

	return res

def check_for_error(test_case, ret):
    if ret is not None:
        sys.stderr.write(bcolors.FAIL + '@ {0}: [FAILED]'.format(test_case) + bcolors.ENDC + '\n')
        sys.stderr.write(bcolors.FAIL + "@------------------ start cause --------------------" + bcolors.ENDC + "\n")
        sys.stderr.write(ret)
        sys.stderr.write(bcolors.FAIL + "@------------------- end cause ---------------------" + bcolors.ENDC + "\n\n")
        return True
    return False
    
def check_diff(test_case_name, ref, test):
    ret = run_cmd("diff {0} {1}".format(ref, test))
    return not check_for_error(test_case_name, ret)

def run_test_case(test_case_name): 
	sys.stderr.write("#-----------------------------------------------------\n")
	sys.stderr.write("# {0}\n".format(test_case_name))

	# name of the file contaning the reference IR for the current test
	refIr   = test_case_name + '.ir.ref'
	# name of the file containing the generated IR for the case test
	testIr  = test_case_name + '.ir'
	# name of the file containing the reference C output for the current test
	refC    = test_case_name + '.insieme.c.ref'
	# name of the file containing the generated C output for the current test
	testC   = test_case_name + '.insieme.c'
	# name of the file containing the reference dot dump of the CFG
	refCfg  = test_case_name + '.cfg.ref'
	# name of the file containing the generated dot dump of the CFG
	testCfg  = test_case_name + '.cfg'


	inputs = test_case_name + '.c'
	if os.path.exists(test_case_name + '/inputs.data'):
		inputs = " ".join([x.strip() for x in open(test_case_name + '/inputs.data').read().split(',')])

	insiemeFlags = ''
	if os.path.exists(test_case_name + '/insieme.flags'):
		insiemeFlags = " ".join([x.strip() for x in open(test_case_name + '/insieme.flags').read().split(',')])

	gccFlagsRef = ''
	if os.path.exists(test_case_name + '/ref-gcc.flags'):
		gccFlagsRef = " ".join([x.strip() for x in open(test_case_name + '/ref-gcc.flags').read().split(',')])

	gccFlagsTest = ''
	if os.path.exists(test_case_name + '/test-gcc.flags'):
		gccFlagsTest = " ".join([x.strip() for x in open(test_case_name + '/test-gcc.flags').read().split(',')])

	sys.stderr.write(" * Running Insieme Compiler...          ")	  		
	os.chdir(test_case_name)
	# RUN insieme to generate the IR dump and C output
	ret = run_cmd( "{INSIEMEC} {CFLAGS} {INPUTS} --dump-ir={IR_DUMP} --dump-cfg {CFG_DUMP} -o {C_DUMP} {FLAGS}".format(
						**{'INSIEMEC': INSIEMEC, 'CFLAGS':CFLAGS, 'INPUTS': inputs, 'IR_DUMP': testIr, 'C_DUMP': testC, 
						   'FLAGS': insiemeFlags, 'CFG_DUMP': testCfg}) 
				 )
	if check_for_error(test_case_name, ret):
		os.chdir("../")
		return 1

	runTests = 0
	if (not os.path.exists(refIr)) and os.path.exists(testIr):
	  shutil.copyfile(testIr, refIr)
	  runTests = 1 # Reference is not there, we have to run the test to make sure the translation was correct
	  
	sys.stderr.write(" * -> " + bcolors.OKGREEN  +"Success." + bcolors.ENDC + "\n")

	sys.stderr.write(" * Comparing generated IR...            ")
	if check_diff(test_case_name, refIr, testIr):
		sys.stderr.write(" * -> " + bcolors.OKGREEN  +"Success." + bcolors.ENDC + "\n")
	else:
		sys.stderr.write(" * -> " + bcolors.WARNING  +"Different!" + bcolors.ENDC + "\n")
		runTests = 1 # => file comparison failed, but program might still be OK

	if not os.path.exists(refCfg) and os.path.exists(testCfg):
	  shutil.copyfile(testCfg, refCfg)
	  runTests = 1 # Reference is not there, we have to run the test to make sure the translation was correct

	sys.stderr.write(" * Comparing generated CFG...            ")
	if check_diff(test_case_name, refCfg, testCfg):
		sys.stderr.write(" * -> " + bcolors.OKGREEN  +"Success." + bcolors.ENDC + "\n")
	else:
		sys.stderr.write(" * -> " + bcolors.WARNING  +"Different!" + bcolors.ENDC + "\n")
		runTests = 1 # => file comparison failed, but program might still be OK

	if not os.path.exists(refC) and os.path.exists(testC):
	  shutil.copyfile(testC, refC)
	  runTests = 1 # Reference is not there, we have to run the test to make sure the translation was correct
	  
	sys.stderr.write(" * Comparing generated C output...      ")
	if check_diff(test_case_name, refC, testC):
		sys.stderr.write(" * -> " + bcolors.OKGREEN  +"Success." + bcolors.ENDC + "\n")
	else:
		sys.stderr.write(" * -> " + bcolors.WARNING  +"Different!" + bcolors.ENDC + "\n")
		runTests = 1 # => file comparison failed, but program might still be OK
	
	# test whether executables are missing within #bin directory
	ref_exec = test_case_name + '.ref'
	test_exec = test_case_name + '.test'
	if not runTests and os.path.exists("../#bin/"):
		if not os.path.exists("../#bin/" + ref_exec) or not os.path.exists("../#bin/" + test_exec):
			runTests = 1 # => ensure that all binaries are present within #bin

	if runTests & (test_case_name != "ocl_kernel"):

		# file containing the output of the reference program
		ref_out = "ref.out"
		# file containing the output of the test program
		test_out = "test.out"

		sys.stderr.write(" * Compiling C input...                 ")
		ret = run_cmd( "{CC} -O3 {CFLAGS} -o {OUTPUT} {INPUTS} {LDFLAGS} {GCCFLAGS}".format(
							**{'CC':CC, 'CFLAGS':CFLAGS, 'INPUTS':inputs, 'OUTPUT':ref_exec, 'LDFLAGS':LDFLAGS_ORG, 'GCCFLAGS':gccFlagsRef})  
						)

		sys.stderr.write(" * Compiling generated C output...      ")
		ret = run_cmd( "{CC} -O3 {CFLAGS} -o {OUTPUT} {INPUTS} {LDFLAGS} {GCCFLAGS}".format(
							**{'CC':CC, 'CFLAGS':CFLAGS, 'INPUTS':testC, 'OUTPUT':test_exec, 'LDFLAGS':LDFLAGS_RES, 'GCCFLAGS':gccFlagsTest})
						)
		if check_for_error(test_case_name, ret):
			os.chdir("../")
			return 1
		sys.stderr.write(" * -> " + bcolors.OKGREEN  +"Success." + bcolors.ENDC + "\n")

		sys.stderr.write(" * Running input program...             ")
		start = time.time()
		os.system("./{0} > {1}".format(ref_exec, ref_out))
		sys.stderr.write(" [{0:.4f} secs]\n".format(time.time() - start))
		
		sys.stderr.write(" * Running output program...            ")
		ldPath = os.getenv("LD_LIBRARY_PATH", "");
		os.putenv("LD_LIBRARY_PATH", ldPath + ":${CMAKE_BINARY_DIR}/code/simple_backend");
		start = time.time()
		os.system("./{0} > {1}".format(test_exec, test_out))
		sys.stderr.write(" [{0:.4f} secs]\n".format(time.time() - start))
		os.putenv("LD_LIBRARY_PATH", ldPath);

		sys.stderr.write(" * Checking generated program output... ")
		if not check_diff(test_case_name, ref_out, test_out):
			os.chdir("../")
			return 1
		sys.stderr.write(" * -> " + bcolors.OKGREEN  + "Success." + bcolors.ENDC + "\n")

		# if the test is successful move the executable in the ../#bin directory for further benchmarking
		if os.path.exists("../#bin/"):
			if os.path.exists("../#bin/" + ref_exec):
				os.remove("../#bin/" + ref_exec)
			shutil.move(ref_exec, "../#bin/")
		
			if os.path.exists("../#bin/" + test_exec):
				os.remove("../#bin/" + test_exec)
			shutil.move(test_exec, "../#bin/")
		
		# map(lambda x : os.remove(x), [testIr, testC, ref_out, test_out])
		map(lambda x : os.remove(x), [ref_out, test_out])

	if runOcl & (test_case_name == "ocl_kernel"):
		sys.stderr.write(" * Compiling OpenCL host program...                 ")

	        ret = run_cmd( "{CC} -O3 {CFLAGS} -o host runTestKernels.c {LDFLAGS} {GCCFLAGS}".format(
							**{'CC':CC, 'CFLAGS':CFLAGS, 'LDFLAGS':os.path.expandvars(LDFLAGS_ORG), 'GCCFLAGS':os.path.expandvars(gccFlagsRef)})  
						)
		if(ret != None) :
			sys.stderr.write("Failed to build OpenCL host program:\n" + ret + "\n")
		    
                if check_for_error(test_case_name, ret):
                        os.chdir("../")
                        return 1
 	
                sys.stderr.write(" * -> " + bcolors.OKGREEN  +"Success." + bcolors.ENDC + "\n")

                sys.stderr.write(" * Running input program...             ")
		
		ref_out = "ref.out"
                start = time.time()

		os.system("./host ocl_kernel.c > {0}".format( ref_out))

                sys.stderr.write(" [{0:.4f} secs]\n".format(time.time() - start))

		sys.stderr.write(" * Running output program...            ")

		test_out = "test.out"	
                start = time.time()

		os.system("./host ocl_kernel.insieme.c > {0}".format( test_out))

                sys.stderr.write(" [{0:.4f} secs]\n".format(time.time() - start))

                sys.stderr.write(" * Checking generated program output... ")
                if not check_diff(test_case_name, ref_out, test_out):
                        os.chdir("../")
                        return 1
                sys.stderr.write(" * -> " + bcolors.OKGREEN  + "Success." + bcolors.ENDC + "\n")

		map(lambda x : os.remove(x), [testIr, testC, ref_out, test_out])

	
	sys.stderr.write(bcolors.OKGREEN + "@ [SUCCESS]" + bcolors.ENDC + "\n")

	os.chdir("../")
	return 0

def main():
	os.chdir('${CMAKE_CURRENT_SOURCE_DIR}/test/')

	abortOnFail = False;

	#check for opencl flag
	for arg in sys.argv[1:] :
		if(arg == "--runOpenCL") :
			global runOcl
			runOcl = 1
			sys.argv.remove(arg)
		if(arg == "--printErrors") :
			global printErr
			printErr = 1
			sys.argv.remove(arg)
		if arg == "--clean" :
			for test in [test_case for test_case in open('test.cfg').read().split('\n') if len(test_case) > 0 and not test_case.startswith('#')]:
				os.system( "rm -f ${CMAKE_CURRENT_SOURCE_DIR}/test/{0}/*.ref".format(test) )
			sys.argv.remove(arg)
		if(arg == "--verbose") :
			global verbose
			global INSIEMEC
			verbose = 1
			INSIEMEC = INSIEMEC + " -S"
			sys.argv.remove(arg)
		if(arg == "--abortOnFail") :
			abortOnFail = True
			sys.argv.remove(arg)

	tests = []
	if len(sys.argv) > 1:		
		# run the specified tests only
		tests = sys.argv[1:]
	elif os.path.exists('./test.cfg'):
		# read test cases from test.cfg file
		tests = [test_case for test_case in open('test.cfg').read().split('\n') if len(test_case) > 0 and not test_case.startswith('#')]
	else:
		tests = [x for x in os.listdir(".") if os.path.isdir(os.path.join('./', x)) and not x.startswith('#')]
		tests.sort() # sort the test cases by name
			
	passed = []
	failed = []
	for cur in tests :
		if len(failed) == 0 or (not abortOnFail) :
			if run_test_case(cur) :
				failed.append(cur)
			else :
				passed.append(cur)

	# failed = filter(lambda x: run_test_case(x), tests)
	
	# print summary
	sys.stderr.write("###############################\n")
	sys.stderr.write("#          Summary            #\n")
	sys.stderr.write("#-----------------------------#\n")
	sys.stderr.write("# Total number of tests: {0:4} #\n".format( len(passed) + len(failed) ))
	sys.stderr.write("# -> SUCCEEDED: {0:13} #\n".format(len(passed)))
	sys.stderr.write("# -> FAILED:    {0:13} #\n".format(len(failed)))

	for test in failed:
		sys.stderr.write("#    - {0:22} #\n".format(test))

	sys.stderr.write("###############################\n")
	
	return  os._exit(len(failed));

if __name__ == "__main__":
    sys.exit(main())
       
