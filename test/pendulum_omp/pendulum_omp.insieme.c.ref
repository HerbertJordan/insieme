// --- Generated Inspire Code ---
#include <alloca.h>
#include <stddef.h>
#include <stdlib.h>
#include <runtime.h>
#define bool int
#define true 1
#define false 0
#define null 0

// start code fragment :: vector_type_declaration of __insieme_type_4 <=> vector<real<8>,2> //
typedef struct ___insieme_type_4 { 
    double data[2];
} __insieme_type_4;

// A constructor initializing a vector of the type __insieme_type_4 uniformly
static inline __insieme_type_4 __insieme_type_4_init_uniform(double value) {
	__insieme_type_4 res;
	for (int i=0; i<2;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: type_declaration_Source //
struct Source { 
    int type;
    __insieme_type_4 pos;
    double mult;
    double size;
};

// start code fragment :: vector_type_declaration of __insieme_type_3 <=> vector<struct<type:int<4>,pos:vector<real<8>,2>,mult:real<8>,size:real<8>>,4> //
typedef struct ___insieme_type_3 { 
    struct Source data[4];
} __insieme_type_3;

// A constructor initializing a vector of the type __insieme_type_3 uniformly
static inline __insieme_type_3 __insieme_type_3_init_uniform(struct Source value) {
	__insieme_type_3 res;
	for (int i=0; i<4;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: array type definition of __insieme_type_7 <=> array<uint<4>,1> //
typedef struct ___insieme_type_7 { 
    unsigned int* data;
} __insieme_type_7;

// start code fragment :: array type definition of __insieme_type_6 <=> array<array<uint<4>,1>,1> //
typedef struct ___insieme_type_6 { 
    __insieme_type_7* data;
} __insieme_type_6;

// start code fragment :: type_declaration_Image //
struct Image { 
    __insieme_type_6 data;
    int x;
    int y;
};

// start code fragment :: New operator for type ref<array<uint<4>,1>> //
static inline __insieme_type_7* _ref_new___insieme_type_9(__insieme_type_7 value) {
    __insieme_type_7* res = malloc(sizeof(__insieme_type_7));
    *res = value;
    return res;
}


// start code fragment :: array type utils of __insieme_type_7 <=> array<uint<4>,1> //
// A constructor for the array type __insieme_type_7
static inline __insieme_type_7 __insieme_type_7_ctr(unsigned s1) {
    return ((__insieme_type_7){malloc(sizeof(unsigned int)*s1)});
}

// start code fragment :: New operator for type ref<array<array<uint<4>,1>,1>> //
static inline __insieme_type_6* _ref_new___insieme_type_10(__insieme_type_6 value) {
    __insieme_type_6* res = malloc(sizeof(__insieme_type_6));
    *res = value;
    return res;
}


// start code fragment :: array type utils of __insieme_type_6 <=> array<array<uint<4>,1>,1> //
// A constructor for the array type __insieme_type_6
static inline __insieme_type_6 __insieme_type_6_ctr(unsigned s1) {
    return ((__insieme_type_6){malloc(sizeof(__insieme_type_7)*s1)});
}

// start code fragment :: Definition of create_image ... type: ((int<4>,int<4>)->struct<data:array<array<uint<4>,1>,1>,x:int<4>,y:int<4>>) //
struct Image create_image(int x, int y){
	__insieme_type_7* block = _ref_new___insieme_type_9((__insieme_type_7_ctr((((sizeof(unsigned int)*((unsigned long)(x)))*((unsigned long)(y)))/sizeof(unsigned int)))));
	__insieme_type_6* index = _ref_new___insieme_type_10((__insieme_type_6_ctr(((sizeof(__insieme_type_7)*((unsigned long)(x)))/sizeof(__insieme_type_7)))));
	for(int var_6 = 0; var_6 < x; var_6 += 1)  { ((((*index).data[((unsigned int)(var_6))])) = (*(&((__insieme_type_7){&((*block).data[((unsigned int)((var_6*x)))])})))); };
	return ((struct Image){(*index),
		x,
		y
	});
}
static struct Image create_image_wrap(void* _closure, int x, int y) { return create_image(x, y); }

// start code fragment :: struct for job __insieme_job_11 //
struct __insieme_job_11 { 
	unsigned structSize;
	unsigned min, max;
	void (*fun)(isbr_JobArgs*);
	// ---- additional captured variables -----
	int* var_106;
	double* var_107;
	unsigned int* var_108;
	double* var_109;
	int* var_110;
	struct Image* var_111;
	double* var_112;
	unsigned int* var_113;
	unsigned int* var_114;
	struct Image* var_115;
	double* var_116;
	double* var_117;
	__insieme_type_3* var_118;
};

// start code fragment :: Definitions for function type: __insieme_funType_12 //
//
// -------------------- Begin of constructs for function type (()->unit)---------------------
// Base-struct of describing closures of type __insieme_funType_12 <-> (()->unit)
typedef struct ___insieme_funType_12 { 
    void(*call)(void*);
} __insieme_funType_12;

// Type safe function for invoking closures of type __insieme_funType_12
static inline void __insieme_funType_12_call(__insieme_funType_12* closure) {  closure->call(closure); }

// A constructor for closures wrapping pure functions of type (()->unit)
static inline __insieme_funType_12* __insieme_funType_12_ctr(__insieme_funType_12* target, void(*call)(void*)) {
	*target = (__insieme_funType_12){call};
	return target;
}
// ----------------------- end of constructs for function (()->unit)-----------------------

// start code fragment :: Definitions for function type: __insieme_funType_14 //
//
// -------------------- Begin of constructs for function type ((ref<int<4>>,ref<real<8>>,ref<uint<4>>,ref<real<8>>,ref<int<4>>,ref<struct<data:array<array<uint<4>,1>,1>,x:int<4>,y:int<4>>>,ref<real<8>>,ref<uint<4>>,ref<uint<4>>,ref<struct<data:array<array<uint<4>,1>,1>,x:int<4>,y:int<4>>>,ref<real<8>>,ref<real<8>>,ref<vector<struct<type:int<4>,pos:vector<real<8>,2>,mult:real<8>,size:real<8>>,4>>)->unit)---------------------
// Base-struct of describing closures of type __insieme_funType_14 <-> ((ref<int<4>>,ref<real<8>>,ref<uint<4>>,ref<real<8>>,ref<int<4>>,ref<struct<data:array<array<uint<4>,1>,1>,x:int<4>,y:int<4>>>,ref<real<8>>,ref<uint<4>>,ref<uint<4>>,ref<struct<data:array<array<uint<4>,1>,1>,x:int<4>,y:int<4>>>,ref<real<8>>,ref<real<8>>,ref<vector<struct<type:int<4>,pos:vector<real<8>,2>,mult:real<8>,size:real<8>>,4>>)->unit)
typedef struct ___insieme_funType_14 { 
    void(*call)(void*, int*, double*, unsigned int*, double*, int*, struct Image*, double*, unsigned int*, unsigned int*, struct Image*, double*, double*, __insieme_type_3*);
} __insieme_funType_14;

// Type safe function for invoking closures of type __insieme_funType_14
static inline void __insieme_funType_14_call(__insieme_funType_14* closure, int* p1, double* p2, unsigned int* p3, double* p4, int* p5, struct Image* p6, double* p7, unsigned int* p8, unsigned int* p9, struct Image* p10, double* p11, double* p12, __insieme_type_3* p13) {  closure->call(closure, p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13); }

// A constructor for closures wrapping pure functions of type ((ref<int<4>>,ref<real<8>>,ref<uint<4>>,ref<real<8>>,ref<int<4>>,ref<struct<data:array<array<uint<4>,1>,1>,x:int<4>,y:int<4>>>,ref<real<8>>,ref<uint<4>>,ref<uint<4>>,ref<struct<data:array<array<uint<4>,1>,1>,x:int<4>,y:int<4>>>,ref<real<8>>,ref<real<8>>,ref<vector<struct<type:int<4>,pos:vector<real<8>,2>,mult:real<8>,size:real<8>>,4>>)->unit)
static inline __insieme_funType_14* __insieme_funType_14_ctr(__insieme_funType_14* target, void(*call)(void*, int*, double*, unsigned int*, double*, int*, struct Image*, double*, unsigned int*, unsigned int*, struct Image*, double*, double*, __insieme_type_3*)) {
	*target = (__insieme_funType_14){call};
	return target;
}
// ----------------------- end of constructs for function ((ref<int<4>>,ref<real<8>>,ref<uint<4>>,ref<real<8>>,ref<int<4>>,ref<struct<data:array<array<uint<4>,1>,1>,x:int<4>,y:int<4>>>,ref<real<8>>,ref<uint<4>>,ref<uint<4>>,ref<struct<data:array<array<uint<4>,1>,1>,x:int<4>,y:int<4>>>,ref<real<8>>,ref<real<8>>,ref<vector<struct<type:int<4>,pos:vector<real<8>,2>,mult:real<8>,size:real<8>>,4>>)->unit)-----------------------

// start code fragment :: Definition of __insieme_closure_13 ... type: (()->unit) //
// -- Begin - Closure Constructs ------------------------------------------------------------
// struct definition a closure of type (()->unit)
typedef struct ___insieme_closure_13 {
    void(*call)(void*);
    __insieme_funType_14* nested;
    int* c1;
    double* c2;
    unsigned int* c3;
    double* c4;
    int* c5;
    struct Image* c6;
    double* c7;
    unsigned int* c8;
    unsigned int* c9;
    struct Image* c10;
    double* c11;
    double* c12;
    __insieme_type_3* c13;
} __insieme_closure_13;

static inline void __insieme_closure_13_bind(__insieme_closure_13* closure) {  closure->nested->call(closure->nested, closure->c1,closure->c2,closure->c3,closure->c4,closure->c5,closure->c6,closure->c7,closure->c8,closure->c9,closure->c10,closure->c11,closure->c12,closure->c13); }

static inline __insieme_closure_13* __insieme_closure_13_ctr(__insieme_closure_13* closure, __insieme_funType_14* nested, int* c1, double* c2, unsigned int* c3, double* c4, int* c5, struct Image* c6, double* c7, unsigned int* c8, unsigned int* c9, struct Image* c10, double* c11, double* c12, __insieme_type_3* c13) {
    *closure = (__insieme_closure_13){&__insieme_closure_13_bind, nested, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13};
    return closure;
}
// -- End - Closure Constructs --------------------------------------------------------------

// start code fragment :: capture-struct for pfor-body __insieme_pfor_body_16_fun //
struct __insieme_pfor_body_16_fun_capture {
	double* var_78;
	double* var_81;
	struct Image* var_76;
	unsigned int* var_80;
	unsigned int* var_85;
	double* var_86;
	struct Image* var_77;
	unsigned int* var_79;
	int* var_88;
	__insieme_type_3* var_84;
	double* var_83;
	int* var_87;
	double* var_82;
};

// start code fragment :: type_declaration_Trace //
struct Trace { 
    unsigned int target;
    unsigned int numSteps;
};

// start code fragment :: array type definition of __insieme_type_19 <=> array<struct<type:int<4>,pos:vector<real<8>,2>,mult:real<8>,size:real<8>>,1> //
typedef struct ___insieme_type_19 { 
    struct Source* data;
} __insieme_type_19;

// start code fragment :: Prototype for external function: sqrt ... type: ((real<8>)->real<8>) //
double sqrt(double);
static double sqrt_wrap(void* _closure, double var_133) { return sqrt(var_133); }

// start code fragment :: Definition of __insieme_supp_22 ... type: ((ref<vector<real<8>,2>>,ref<vector<real<8>,2>>)->unit) //
void __insieme_supp_22(__insieme_type_4* var_45, __insieme_type_4* var_46){
	((((*var_46).data[((unsigned int)(0))])) = (((*var_45).data[((unsigned int)(0))])));
	((((*var_46).data[((unsigned int)(1))])) = (((*var_45).data[((unsigned int)(1))])));
}
static void __insieme_supp_22_wrap(void* _closure, __insieme_type_4* var_45, __insieme_type_4* var_46) { __insieme_supp_22(var_45, var_46); }

// start code fragment :: Definition of __insieme_supp_23 ... type: ((ref<vector<real<8>,2>>,ref<vector<real<8>,2>>)->unit) //
void __insieme_supp_23(__insieme_type_4* var_48, __insieme_type_4* var_49){
	((((*var_48).data[((unsigned int)(0))])) = (((*var_49).data[((unsigned int)(0))])));
	((((*var_48).data[((unsigned int)(1))])) = (((*var_49).data[((unsigned int)(1))])));
}
static void __insieme_supp_23_wrap(void* _closure, __insieme_type_4* var_48, __insieme_type_4* var_49) { __insieme_supp_23(var_48, var_49); }

// start code fragment :: Definition of getTarget ... type: ((real<8>,real<8>,ref<array<struct<type:int<4>,pos:vector<real<8>,2>,mult:real<8>,size:real<8>>,1>>,uint<4>,real<8>,real<8>,real<8>,uint<4>,uint<4>,real<8>)->struct<target:uint<4>,numSteps:uint<4>>) //
struct Trace getTarget(double i, double j, __insieme_type_19* sources, unsigned int num_sources, double dt, double friction, double height, unsigned int min_steps, unsigned int max_steps, double abortVelocity){
	__insieme_type_4 pos = ((__insieme_type_4){{i, j}});
	__insieme_type_4 vel = ((__insieme_type_4){{((double)(0)), ((double)(0))}});
	__insieme_type_4 acc = ((__insieme_type_4){{((double)(0)), ((double)(0))}});
	__insieme_type_4 acc_new = ((__insieme_type_4){{((double)(0)), ((double)(0))}});
	__insieme_type_4 acc_old = ((__insieme_type_4){{((double)(0)), ((double)(0))}});
	double sqrt_dt = sqrt(dt);
	for(unsigned int var_51 = ((unsigned int)(0)); var_51 < max_steps; var_51 += 1) {
		((((pos).data[((unsigned int)(0))])) = ((((pos).data[((unsigned int)(0))]))+(((((vel).data[((unsigned int)(0))]))*dt)+((sqrt_dt)*(((2.0/3.0)*(((acc).data[((unsigned int)(0))])))-((1.0/6.0)*(((acc_old).data[((unsigned int)(0))]))))))));
		((((pos).data[((unsigned int)(1))])) = ((((pos).data[((unsigned int)(1))]))+(((((vel).data[((unsigned int)(1))]))*dt)+((sqrt_dt)*(((2.0/3.0)*(((acc).data[((unsigned int)(1))])))-((1.0/6.0)*(((acc_old).data[((unsigned int)(1))]))))))));
		((((acc_new).data[((unsigned int)(0))])) = ((double)(0)));
		((((acc_new).data[((unsigned int)(1))])) = ((double)(0)));
		for(unsigned int var_44 = ((unsigned int)(0)); var_44 < num_sources; var_44 += 1) {
			__insieme_type_19 cur = *(&((__insieme_type_19){&((*sources).data[((unsigned int)(var_44))])}));
			__insieme_type_4 r = ((__insieme_type_4){{((((pos).data[((unsigned int)(0))]))-(((*(&((((cur).data[0])).pos))).data[((unsigned int)(0))]))), ((((pos).data[((unsigned int)(1))]))-(((*(&((((cur).data[0])).pos))).data[((unsigned int)(1))])))}});
			if(((*(&((((cur).data[0])).type)))==((int)(((unsigned int)(0)))))){
				((((acc_new).data[((unsigned int)(0))])) = ((((acc_new).data[((unsigned int)(0))]))-((*(&((((cur).data[0])).mult)))*(((r).data[((unsigned int)(0))])))));
				((((acc_new).data[((unsigned int)(1))])) = ((((acc_new).data[((unsigned int)(1))]))-((*(&((((cur).data[0])).mult)))*(((r).data[((unsigned int)(1))])))));
			} else {
				double dist = sqrt((((((((pos).data[((unsigned int)(0))]))-(((*(&((((cur).data[0])).pos))).data[((unsigned int)(0))])))*((((pos).data[((unsigned int)(0))]))-(((*(&((((cur).data[0])).pos))).data[((unsigned int)(0))]))))+(((((pos).data[((unsigned int)(1))]))-(((*(&((((cur).data[0])).pos))).data[((unsigned int)(1))])))*((((pos).data[((unsigned int)(1))]))-(((*(&((((cur).data[0])).pos))).data[((unsigned int)(1))])))))+(height*height)));
				((((acc_new).data[((unsigned int)(0))])) = ((((acc_new).data[((unsigned int)(0))]))-(((*(&((((cur).data[0])).mult)))/(((dist)*(dist))*(dist)))*(((r).data[((unsigned int)(0))])))));
				((((acc_new).data[((unsigned int)(1))])) = ((((acc_new).data[((unsigned int)(1))]))-(((*(&((((cur).data[0])).mult)))/(((dist)*(dist))*(dist)))*(((r).data[((unsigned int)(1))])))));
			};
			if((((var_51>min_steps)&&(sqrt((((((r).data[((unsigned int)(0))]))*(((r).data[((unsigned int)(0))])))+((((r).data[((unsigned int)(1))]))*(((r).data[((unsigned int)(1))])))))<(*(&((((cur).data[0])).size)))))&&(sqrt((((((vel).data[((unsigned int)(0))]))*(((vel).data[((unsigned int)(0))])))+((((vel).data[((unsigned int)(1))]))*(((vel).data[((unsigned int)(1))])))))<abortVelocity))) { return ((struct Trace){var_44,
				var_51
			}); };
		};
		((((acc_new).data[((unsigned int)(0))])) = ((((acc_new).data[((unsigned int)(0))]))-((((vel).data[((unsigned int)(0))]))*friction)));
		((((acc_new).data[((unsigned int)(1))])) = ((((acc_new).data[((unsigned int)(1))]))-((((vel).data[((unsigned int)(1))]))*friction)));
		((((vel).data[((unsigned int)(0))])) = ((((vel).data[((unsigned int)(0))]))+(dt*((((1.0/3.0)*(((acc_new).data[((unsigned int)(0))])))+((5.0/6.0)*(((acc).data[((unsigned int)(0))]))))-((1.0/6.0)*(((acc_old).data[((unsigned int)(0))])))))));
		((((vel).data[((unsigned int)(1))])) = ((((vel).data[((unsigned int)(1))]))+(dt*((((1.0/3.0)*(((acc_new).data[((unsigned int)(1))])))+((5.0/6.0)*(((acc).data[((unsigned int)(1))]))))-((1.0/6.0)*(((acc_old).data[((unsigned int)(1))])))))));
		__insieme_supp_22(&acc, &acc_old);
		__insieme_supp_23(&acc, &acc_new);
	};
	return ((struct Trace){(num_sources+((unsigned int)(1))),
		max_steps
	});
}
static struct Trace getTarget_wrap(void* _closure, double i, double j, __insieme_type_19* sources, unsigned int num_sources, double dt, double friction, double height, unsigned int min_steps, unsigned int max_steps, double abortVelocity) { return getTarget(i, j, sources, num_sources, dt, friction, height, min_steps, max_steps, abortVelocity); }

// start code fragment :: Definition of __insieme_supp_17 ... type: ((ref<real<8>>,ref<real<8>>,ref<struct<data:array<array<uint<4>,1>,1>,x:int<4>,y:int<4>>>,ref<uint<4>>,ref<uint<4>>,ref<real<8>>,ref<struct<data:array<array<uint<4>,1>,1>,x:int<4>,y:int<4>>>,ref<uint<4>>,ref<int<4>>,ref<vector<struct<type:int<4>,pos:vector<real<8>,2>,mult:real<8>,size:real<8>>,4>>,ref<real<8>>,ref<int<4>>,ref<real<8>>,int<4>)->unit) //
void __insieme_supp_17(double* var_102, double* var_99, struct Image* var_104, unsigned int* var_100, unsigned int* var_95, double* var_94, struct Image* var_103, unsigned int* var_101, int* var_92, __insieme_type_3* var_96, double* var_97, int* var_93, double* var_98, int var_91) { for(int var_73 = 0; var_73 < (*var_93); var_73 += 1) {
	double curX = (((((double)(0))-1.0)+((((double)(var_91))/((double)(((*var_92)-1))))*2.0))*(*var_94));
	double curY = (((((double)(0))-1.0)+((((double)(var_73))/((double)(((*var_93)-1))))*2.0))*(*var_94));
	struct Trace res = getTarget((curX), (curY), (&((__insieme_type_19){(*var_96).data})), (*var_95), (*var_97), (*var_98), (*var_99), (*var_100), (*var_101), (*var_102));
	((((((*(&((*var_103).data))).data[((unsigned int)(var_91))])).data[((unsigned int)(var_73))])) = (*(&((res).target))));
	((((((*(&((*var_104).data))).data[((unsigned int)(var_91))])).data[((unsigned int)(var_73))])) = (*(&((res).numSteps))));
}; }
static void __insieme_supp_17_wrap(void* _closure, double* var_102, double* var_99, struct Image* var_104, unsigned int* var_100, unsigned int* var_95, double* var_94, struct Image* var_103, unsigned int* var_101, int* var_92, __insieme_type_3* var_96, double* var_97, int* var_93, double* var_98, int var_91) { __insieme_supp_17(var_102, var_99, var_104, var_100, var_95, var_94, var_103, var_101, var_92, var_96, var_97, var_93, var_98, var_91); }

// start code fragment :: function for pfor-body __insieme_pfor_body_16_fun //
void __insieme_pfor_body_16_fun(const isbr_PForRange range) {
	// ----- captured variables -----
	double* var_119 = ((struct __insieme_pfor_body_16_fun_capture*)(range.context))->var_78;
	double* var_120 = ((struct __insieme_pfor_body_16_fun_capture*)(range.context))->var_81;
	struct Image* var_121 = ((struct __insieme_pfor_body_16_fun_capture*)(range.context))->var_76;
	unsigned int* var_122 = ((struct __insieme_pfor_body_16_fun_capture*)(range.context))->var_80;
	unsigned int* var_123 = ((struct __insieme_pfor_body_16_fun_capture*)(range.context))->var_85;
	double* var_124 = ((struct __insieme_pfor_body_16_fun_capture*)(range.context))->var_86;
	struct Image* var_125 = ((struct __insieme_pfor_body_16_fun_capture*)(range.context))->var_77;
	unsigned int* var_126 = ((struct __insieme_pfor_body_16_fun_capture*)(range.context))->var_79;
	int* var_127 = ((struct __insieme_pfor_body_16_fun_capture*)(range.context))->var_88;
	__insieme_type_3* var_128 = ((struct __insieme_pfor_body_16_fun_capture*)(range.context))->var_84;
	double* var_129 = ((struct __insieme_pfor_body_16_fun_capture*)(range.context))->var_83;
	int* var_130 = ((struct __insieme_pfor_body_16_fun_capture*)(range.context))->var_87;
	double* var_131 = ((struct __insieme_pfor_body_16_fun_capture*)(range.context))->var_82;
	
	// ----- process iterations -----
	for(int __it = range.start; __it<range.end; __it+=range.step) {
		__insieme_supp_17(var_119, var_120, var_121, var_122, var_123, var_124, var_125, var_126, var_127, var_128, var_129, var_130, var_131, __it);
	}
	
}

// start code fragment :: Definition of __insieme_supp_15 ... type: ((ref<int<4>>,ref<real<8>>,ref<uint<4>>,ref<real<8>>,ref<int<4>>,ref<struct<data:array<array<uint<4>,1>,1>,x:int<4>,y:int<4>>>,ref<real<8>>,ref<uint<4>>,ref<uint<4>>,ref<struct<data:array<array<uint<4>,1>,1>,x:int<4>,y:int<4>>>,ref<real<8>>,ref<real<8>>,ref<vector<struct<type:int<4>,pos:vector<real<8>,2>,mult:real<8>,size:real<8>>,4>>)->unit) //
void __insieme_supp_15(int* var_87, double* var_78, unsigned int* var_80, double* var_82, int* var_88, struct Image* var_77, double* var_81, unsigned int* var_85, unsigned int* var_79, struct Image* var_76, double* var_83, double* var_86, __insieme_type_3* var_84) { {
	isbr_pfor(isbr_getThreadGroup(0),(isbr_PForRange){0, (*var_88), 1, &((struct __insieme_pfor_body_16_fun_capture){var_78, var_81, var_76, var_80, var_85, var_86, var_77, var_79, var_88, var_84, var_83, var_87, var_82})},&__insieme_pfor_body_16_fun);
	isbr_barrier(isbr_getThreadGroup(0));
}; }
static void __insieme_supp_15_wrap(void* _closure, int* var_87, double* var_78, unsigned int* var_80, double* var_82, int* var_88, struct Image* var_77, double* var_81, unsigned int* var_85, unsigned int* var_79, struct Image* var_76, double* var_83, double* var_86, __insieme_type_3* var_84) { __insieme_supp_15(var_87, var_78, var_80, var_82, var_88, var_77, var_81, var_85, var_79, var_76, var_83, var_86, var_84); }

// start code fragment :: function for job __insieme_job_11 //
void fun__insieme_job_11(isbr_JobArgs* args) {
	// ----------- Unpacking local scope variables ----------
	// ---------- Unpacking auto-captured variables ---------
	int* var_106 = ((struct __insieme_job_11*)args)->var_106;
	double* var_107 = ((struct __insieme_job_11*)args)->var_107;
	unsigned int* var_108 = ((struct __insieme_job_11*)args)->var_108;
	double* var_109 = ((struct __insieme_job_11*)args)->var_109;
	int* var_110 = ((struct __insieme_job_11*)args)->var_110;
	struct Image* var_111 = ((struct __insieme_job_11*)args)->var_111;
	double* var_112 = ((struct __insieme_job_11*)args)->var_112;
	unsigned int* var_113 = ((struct __insieme_job_11*)args)->var_113;
	unsigned int* var_114 = ((struct __insieme_job_11*)args)->var_114;
	struct Image* var_115 = ((struct __insieme_job_11*)args)->var_115;
	double* var_116 = ((struct __insieme_job_11*)args)->var_116;
	double* var_117 = ((struct __insieme_job_11*)args)->var_117;
	__insieme_type_3* var_118 = ((struct __insieme_job_11*)args)->var_118;
	// ------------------ Processing Guards -----------------
	// ------------------ Default processing -----------------
	__insieme_funType_12_call((__insieme_funType_12*)__insieme_closure_13_ctr((__insieme_closure_13*)alloca(sizeof(__insieme_closure_13)),(__insieme_funType_14*)__insieme_funType_14_ctr((__insieme_funType_14*)alloca(sizeof(__insieme_funType_14)),&__insieme_supp_15_wrap), var_106, var_107, var_108, var_109, var_110, var_111, var_112, var_113, var_114, var_115, var_116, var_117, var_118));
}

// start code fragment :: array type definition of __insieme_type_24 <=> array<char,1> //
typedef struct ___insieme_type_24 { 
    char* data;
} __insieme_type_24;

// start code fragment :: Prototype for external function: printf ... type: ((ref<array<char,1>>,var_list)->int<4>) //
int printf(char*, ...);

// start code fragment :: Definition of print_target_image_ASCII ... type: ((struct<data:array<array<uint<4>,1>,1>,x:int<4>,y:int<4>>)->unit) //
void print_target_image_ASCII(struct Image image) { for(int var_15 = 0; var_15 < (image.x); var_15 += 1) {
	for(int var_14 = 0; var_14 < (image.y); var_14 += 1)  { {
		int var_13 = ((int)((image.data).data[((unsigned int)(var_15))].data[((unsigned int)(var_14))]));
		switch(var_13) {
		case ((unsigned int)(0)):
			printf(((char*)((*(&((__insieme_type_24){" "}))).data)), 0); break;
		case ((unsigned int)(1)):
			printf(((char*)((*(&((__insieme_type_24){"A"}))).data)), 0); break;
		case ((unsigned int)(2)):
			printf(((char*)((*(&((__insieme_type_24){"B"}))).data)), 0); break;
		case ((unsigned int)(3)):
			printf(((char*)((*(&((__insieme_type_24){"C"}))).data)), 0); break;
		case ((unsigned int)(4)):
			printf(((char*)((*(&((__insieme_type_24){"X"}))).data)), 0); break;
		};
	}; };
	printf(((char*)((*(&((__insieme_type_24){"\n"}))).data)), 0);
}; }
static void print_target_image_ASCII_wrap(void* _closure, struct Image image) { print_target_image_ASCII(image); }

// start code fragment :: array type definition of __insieme_type_26 <=> array<struct<data:array<array<uint<4>,1>,1>,x:int<4>,y:int<4>>,1> //
typedef struct ___insieme_type_26 { 
    struct Image* data;
} __insieme_type_26;

// start code fragment :: Definition of delete_image ... type: ((ref<array<struct<data:array<array<uint<4>,1>,1>,x:int<4>,y:int<4>>,1>>)->unit) //
void delete_image(__insieme_type_26* image){
	free((((*(&((((*image).data[0])).data))).data[((unsigned int)(0))])).data);
	free((*(&((((*image).data[0])).data))).data);
}
static void delete_image_wrap(void* _closure, __insieme_type_26* image) { delete_image(image); }

// start code fragment :: main function //
int main() {
	{
		int x = 12;
		int y = 12;
		((x) = ((int)(((y) = 60))));
		double scale = ((double)(800));
		double magSize = 0.02;
		double magPower = 0.08;
		unsigned int num_sources = ((unsigned int)(4));
		__insieme_type_3 sources = ((__insieme_type_3){{((struct Source){0,
			((__insieme_type_4){{((double)(0)), ((double)(0))}}),
			0.01,
			(magSize)
		}), ((struct Source){1,
			((__insieme_type_4){{((double)(1)), ((double)(0))}}),
			(magPower),
			(magSize)
		}), ((struct Source){1,
			((__insieme_type_4){{(((double)(0))-0.5), 0.866025404}}),
			(magPower),
			(magSize)
		}), ((struct Source){1,
			((__insieme_type_4){{(((double)(0))-0.5), (((double)(0))-0.866025404)}}),
			(magPower),
			(magSize)
		})}});
		double dt = 0.01;
		double friction = 0.01;
		double height = 0.3;
		unsigned int min_steps = ((unsigned int)(400));
		unsigned int max_steps = ((unsigned int)(100000));
		double abortVelocity = 0.01;
		struct Image image = create_image((x), (y));
		struct Image dist = create_image((x), (y));
		isbr_merge(isbr_parallel(memcpy(malloc(sizeof(struct __insieme_job_11)),&((struct __insieme_job_11){sizeof(struct __insieme_job_11),1,isbr_getMaxThreads(),&fun__insieme_job_11,&y,&abortVelocity,&min_steps,&friction,&x,&image,&height,&num_sources,&max_steps,&dist,&dt,&scale,&sources}),sizeof(struct __insieme_job_11))));
		print_target_image_ASCII((image));
		delete_image((&((__insieme_type_26){&image})));
		delete_image((&((__insieme_type_26){&dist})));
	};
}
