// --- Generated Inspire Code ---
#include <alloca.h>
#include <stddef.h>
#include <stdlib.h>
#include <runtime.h>
#define bool int
#define true 1
#define false 0
#define null 0
// --- Entry Point ---

// start code fragment :: type_declaration_dcomplex //
struct dcomplex { 
    double real;
    double imag;
};

// start code fragment :: type_declaration___insieme_globals //
struct __insieme_globals { 
    int fftblock;
    int fftblockpad;
    int(* dims)[3][3];
    int(* xstart)[3];
    int(* ystart)[3];
    int(* zstart)[3];
    int(* xend)[3];
    int(* yend)[3];
    int(* zend)[3];
    double(* ex)[50689];
    struct dcomplex(* u)[128];
    struct dcomplex(* sums)[7];
    int niter;
    struct dcomplex(* u0)[32][128][128];
    struct dcomplex(* pad1)[3];
    struct dcomplex(* u1)[32][128][128];
    struct dcomplex(* pad2)[3];
    struct dcomplex(* u2)[32][128][128];
    struct dcomplex(* pad3)[3];
    int(* indexmap)[32][128][128];
    double(* tmp)[32769];
    double(* start)[64];
    double(* elapsed)[64];
    int sec;
};

// start code fragment :: Definitions for function type: __insieme_funType_type_0 //
// Abstract prototype for lambdas of type __insieme_funType_type_0
struct __insieme_funType_type_0 { 
    void(*fun)(void*, int);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_0
void call__insieme_funType_type_0(struct __insieme_funType_type_0* lambda, int p1) { return lambda->fun(lambda, p1); }

// start code fragment :: Definitions for function type: __insieme_funType_type_1 //
// Abstract prototype for lambdas of type __insieme_funType_type_1
struct __insieme_funType_type_1 { 
    void(*fun)(void*, int);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: Definition of timer_clear //
void timer_clear(void* _capture, int n) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_13 = ((struct __insieme_funType_type_1*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		((((((((*var_13).elapsed))[0]))[((unsigned int)(n))])) = 0.0);
	}
}


// start code fragment :: Prototype for external function: ceil //
double ceil(double);

// start code fragment :: Definitions for function type: __insieme_funType_type_2 //
// Abstract prototype for lambdas of type __insieme_funType_type_2
struct __insieme_funType_type_2 { 
    void(*fun)(void*);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_2
void call__insieme_funType_type_2(struct __insieme_funType_type_2* lambda) { return lambda->fun(lambda); }

// start code fragment :: Definitions for function type: __insieme_funType_type_3 //
// Abstract prototype for lambdas of type __insieme_funType_type_3
struct __insieme_funType_type_3 { 
    void(*fun)(void*);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: Prototype for external function: printf //
int printf(char*, ...);

// start code fragment :: Definition of setup //
void setup(void* _capture) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_16 = ((struct __insieme_funType_type_3*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		int ierr = 0;
		int i = 0;
		int j = 0;
		int fstatus = 0;
		printf("\n\n NAS Parallel Benchmarks 2.3 OpenMP C version - FT Benchmark\n\n", 0);
		((((*var_16).niter)) = 6);
		printf(" Size                : %3dx%3dx%3d\n", 128, 128, 32);
		printf(" Iterations          :     %7d\n", (((*var_16).niter)));
		{
			for(int var_21 = 0; var_21 < 3; var_21 += 1) {
				((((((((*var_16).dims))[0]))[((unsigned int)((var_21)))][((unsigned int)(0))])) = 128);
				((((((((*var_16).dims))[0]))[((unsigned int)((var_21)))][((unsigned int)(1))])) = 128);
				((((((((*var_16).dims))[0]))[((unsigned int)((var_21)))][((unsigned int)(2))])) = 32);
			};
			((i) = (0+(((int)(ceil((((double)((3-0)))/((double)(1))))))*1)));
		};
		{
			for(int var_22 = 0; var_22 < 3; var_22 += 1) {
				((((((((*var_16).xstart))[0]))[((unsigned int)((var_22)))])) = 1);
				((((((((*var_16).xend))[0]))[((unsigned int)((var_22)))])) = 128);
				((((((((*var_16).ystart))[0]))[((unsigned int)((var_22)))])) = 1);
				((((((((*var_16).yend))[0]))[((unsigned int)((var_22)))])) = 128);
				((((((((*var_16).zstart))[0]))[((unsigned int)((var_22)))])) = 1);
				((((((((*var_16).zend))[0]))[((unsigned int)((var_22)))])) = 32);
			};
			((i) = (0+(((int)(ceil((((double)((3-0)))/((double)(1))))))*1)));
		};
		((((*var_16).fftblock)) = 16);
		((((*var_16).fftblockpad)) = 18);
		if(((((*var_16).fftblock))!=16)) {
			((((*var_16).fftblockpad)) = ((((*var_16).fftblock))+3));
		};
	}
}


// start code fragment :: Definitions for function type: __insieme_funType_type_4 //
// Abstract prototype for lambdas of type __insieme_funType_type_4
struct __insieme_funType_type_4 { 
    void(*fun)(void*, int(*)[128][128], int*);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_4
void call__insieme_funType_type_4(struct __insieme_funType_type_4* lambda, int(* p1)[128][128], int* p2) { return lambda->fun(lambda, p1,p2); }

// start code fragment :: Definitions for function type: __insieme_funType_type_5 //
// Abstract prototype for lambdas of type __insieme_funType_type_5
struct __insieme_funType_type_5 { 
    void(*fun)(void*, int(*)[128][128], int*);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: Prototype for external function: exp //
double exp(double);

// start code fragment :: Definition of compute_indexmap //
void compute_indexmap(void* _capture, int(* indexmap)[128][128], int* d) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_26 = ((struct __insieme_funType_type_5*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		int i = 0;
		int j = 0;
		int k = 0;
		int ii = 0;
		int ii2 = 0;
		int jj = 0;
		int ij2 = 0;
		int kk = 0;
		double ap = 0.0;
		{
			for(int var_38 = 0; var_38 < (((((((*var_26).dims))[0]))[((unsigned int)(2))][((unsigned int)(0))])); var_38 += 1) {
				((ii) = (((((((var_38)+1)+(((((((*var_26).xstart))[0]))[((unsigned int)(2))])))-2)+(128/2))%128)-(128/2)));
				((ii2) = ((ii)*(ii)));
				{
					for(int var_37 = 0; var_37 < (((((((*var_26).dims))[0]))[((unsigned int)(2))][((unsigned int)(1))])); var_37 += 1) {
						((jj) = (((((((var_37)+1)+(((((((*var_26).ystart))[0]))[((unsigned int)(2))])))-2)+(128/2))%128)-(128/2)));
						((ij2) = (((jj)*(jj))+(ii2)));
						{
							for(int var_36 = 0; var_36 < (((((((*var_26).dims))[0]))[((unsigned int)(2))][((unsigned int)(2))])); var_36 += 1) {
								((kk) = (((((((var_36)+1)+(((((((*var_26).zstart))[0]))[((unsigned int)(2))])))-2)+(32/2))%32)-(32/2)));
								(((((indexmap[((unsigned int)((var_36)))]))[((unsigned int)((var_37)))][((unsigned int)((var_38)))])) = (((kk)*(kk))+(ij2)));
							};
							((k) = (0+(((int)(ceil((((double)(((((((((*var_26).dims))[0]))[((unsigned int)(2))][((unsigned int)(2))]))-0)))/((double)(1))))))*1)));
						};
					};
					((j) = (0+(((int)(ceil((((double)(((((((((*var_26).dims))[0]))[((unsigned int)(2))][((unsigned int)(1))]))-0)))/((double)(1))))))*1)));
				};
			};
			((i) = (0+(((int)(ceil((((double)(((((((((*var_26).dims))[0]))[((unsigned int)(2))][((unsigned int)(0))]))-0)))/((double)(1))))))*1)));
		};
		{
			((ap) = ((((((double)(0))-4.0)*1.0e-6)*3.141592653589793238)*3.141592653589793238));
			((((((((*var_26).ex))[0]))[((unsigned int)(0))])) = 1.0);
			((((((((*var_26).ex))[0]))[((unsigned int)(1))])) = exp((ap)));
			{
				for(int var_39 = 2; var_39 < ((6*((((128*128)/4)+((128*128)/4))+((32*32)/4)))+1); var_39 += 1) {
					((((((((*var_26).ex))[0]))[((unsigned int)((var_39)))])) = ((((((((*var_26).ex))[0]))[((unsigned int)(((var_39)-1)))]))*(((((((*var_26).ex))[0]))[((unsigned int)(1))]))));
				};
				((i) = (2+(((int)(ceil((((double)((((6*((((128*128)/4)+((128*128)/4))+((32*32)/4)))+1)-2)))/((double)(1))))))*1)));
			};
		};
	}
}


// start code fragment :: Definitions for function type: __insieme_funType_type_6 //
// Abstract prototype for lambdas of type __insieme_funType_type_6
struct __insieme_funType_type_6 { 
    void(*fun)(void*, struct dcomplex(*)[128][128], int*);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_6
void call__insieme_funType_type_6(struct __insieme_funType_type_6* lambda, struct dcomplex(* p1)[128][128], int* p2) { return lambda->fun(lambda, p1,p2); }

// start code fragment :: Definitions for function type: __insieme_funType_type_7 //
// Abstract prototype for lambdas of type __insieme_funType_type_7
struct __insieme_funType_type_7 { 
    void(*fun)(void*, struct dcomplex(*)[128][128], int*);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: Definition of randlc //
double randlc(double* x, double a) {
	{
		double t1 = 0.0;
		double t2 = 0.0;
		double t3 = 0.0;
		double t4 = 0.0;
		double a1 = 0.0;
		double a2 = 0.0;
		double x1 = 0.0;
		double x2 = 0.0;
		double z = 0.0;
		((t1) = (((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*a));
		((a1) = ((double)(((int)((t1))))));
		((a2) = (a-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(a1))));
		((t1) = (((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((x[0]))));
		((x1) = ((double)(((int)((t1))))));
		((x2) = (((x[0]))-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(x1))));
		((t1) = (((a1)*(x2))+((a2)*(x1))));
		((t2) = ((double)(((int)((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*(t1)))))));
		((z) = ((t1)-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(t2))));
		((t3) = ((((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(z))+((a2)*(x2))));
		((t4) = ((double)(((int)(((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5))*(t3)))))));
		(((x[0])) = ((t3)-((((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0))*(t4))));
		return ((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5))*((x[0])));;
	}
}


// start code fragment :: Definition of ipow46 //
int ipow46(double a, int exponent, double* result) {
	{
		double dummy = 0.0;
		double q = 0.0;
		double r = 0.0;
		int n = 0;
		int n2 = 0;
		(((result[0])) = ((double)(1)));
		if((exponent==0)) return 0;;
		((q) = a);
		((r) = ((double)(1)));
		((n) = exponent);
		while(((n)>1)) {
			((n2) = ((n)/2));
			if((((n2)*2)==(n))) {
				((dummy) = randlc(&q, (q)));
				((n) = (n2));
			} else {
				((dummy) = randlc(&r, (q)));
				((n) = ((n)-1));
			};
		};
		((dummy) = randlc(&r, (q)));
		(((result[0])) = (r));
		return 0;;
	}
}


// start code fragment :: Definition of vranlc //
void vranlc(int n, double* x_seed, double a, double* y) {
	{
		int i = 0;
		double x = 0.0;
		double t1 = 0.0;
		double t2 = 0.0;
		double t3 = 0.0;
		double t4 = 0.0;
		double a1 = 0.0;
		double a2 = 0.0;
		double x1 = 0.0;
		double x2 = 0.0;
		double z = 0.0;
		((t1) = (((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*a));
		((a1) = ((double)(((int)((t1))))));
		((a2) = (a-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(a1))));
		((x) = ((x_seed[0])));
		{
			for(int var_88 = 1; var_88 < (n+1); var_88 += 1) {
				((t1) = (((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*(x)));
				((x1) = ((double)(((int)((t1))))));
				((x2) = ((x)-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(x1))));
				((t1) = (((a1)*(x2))+((a2)*(x1))));
				((t2) = ((double)(((int)((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*(t1)))))));
				((z) = ((t1)-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(t2))));
				((t3) = ((((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(z))+((a2)*(x2))));
				((t4) = ((double)(((int)(((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5))*(t3)))))));
				((x) = ((t3)-((((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0))*(t4))));
				(((y[((unsigned int)((var_88)))])) = ((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5))*(x)));
			};
			((i) = (1+(((int)(ceil((((double)(((n+1)-1)))/((double)(1))))))*1)));
		};
		(((x_seed[0])) = (x));
	}
}


// start code fragment :: Definition of compute_initial_conditions //
void compute_initial_conditions(void* _capture, struct dcomplex(* u0)[128][128], int* d) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_43 = ((struct __insieme_funType_type_7*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		int k = 0;
		double x0 = 0.0;
		double start = 0.0;
		double an = 0.0;
		double dummy = 0.0;
		int i = 0;
		int j = 0;
		int t = 0;
		((start) = 314159265.0);
		ipow46(1220703125.0, ((((((((((((*var_43).zstart))[0]))[((unsigned int)(0))]))-1)*2)*128)*128)+((((((((((*var_43).ystart))[0]))[((unsigned int)(0))]))-1)*2)*128)), &an);
		((dummy) = randlc(&start, (an)));
		ipow46(1220703125.0, ((2*128)*128), &an);
		{
			for(int var_92 = 0; var_92 < (((((((*var_43).dims))[0]))[((unsigned int)(0))][((unsigned int)(2))])); var_92 += 1) {
				((x0) = (start));
				vranlc(((2*128)*(((((((*var_43).dims))[0]))[((unsigned int)(0))][((unsigned int)(1))]))), &x0, 1220703125.0, (((((*var_43).tmp))[0])));
				((t) = 1);
				{
					for(int var_91 = 0; var_91 < (((((((*var_43).dims))[0]))[((unsigned int)(0))][((unsigned int)(1))])); var_91 += 1) {
						for(int var_90 = 0; var_90 < 128; var_90 += 1) {
							(((((((u0[((unsigned int)((var_92)))]))[((unsigned int)((var_91)))][((unsigned int)((var_90)))])).real)) = (((((((*var_43).tmp))[0]))[((unsigned int)(((t)++)))])));
							(((((((u0[((unsigned int)((var_92)))]))[((unsigned int)((var_91)))][((unsigned int)((var_90)))])).imag)) = (((((((*var_43).tmp))[0]))[((unsigned int)(((t)++)))])));
						};
						((i) = (0+(((int)(ceil((((double)((128-0)))/((double)(1))))))*1)));
					};
					((j) = (0+(((int)(ceil((((double)(((((((((*var_43).dims))[0]))[((unsigned int)(0))][((unsigned int)(1))]))-0)))/((double)(1))))))*1)));
				};
				if(((var_92)!=(((((((*var_43).dims))[0]))[((unsigned int)(0))][((unsigned int)(2))])))) {
					((dummy) = randlc(&start, (an)));
				};
			};
			((k) = (0+(((int)(ceil((((double)(((((((((*var_43).dims))[0]))[((unsigned int)(0))][((unsigned int)(2))]))-0)))/((double)(1))))))*1)));
		};
	}
}


// start code fragment :: Definition of ilog2 //
int ilog2(int n) {
	{
		int nn = 0;
		int lg = 0;
		if((n==1)) {
			return 0;;
		};
		((lg) = 1);
		((nn) = 2);
		while(((nn)<n)) {
			((nn) = ((nn)<<1));
			((lg)++);
		};
		return (lg);;
	}
}


// start code fragment :: Prototype for external function: cos //
double cos(double);

// start code fragment :: Prototype for external function: sin //
double sin(double);

// start code fragment :: Definition of fft_init //
void fft_init(void* _capture, int n) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_95 = ((struct __insieme_funType_type_1*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		int m = 0;
		int nu = 0;
		int ku = 0;
		int i = 0;
		int j = 0;
		int ln = 0;
		double t = 0.0;
		double ti = 0.0;
		((nu) = n);
		((m) = ilog2(n));
		((((((((((*var_95).u))[0]))[((unsigned int)(0))])).real)) = ((double)((m))));
		((((((((((*var_95).u))[0]))[((unsigned int)(0))])).imag)) = 0.0);
		((ku) = 1);
		((ln) = 1);
		{
			for(int var_109 = 1; var_109 < ((m)+1); var_109 += 1) {
				((t) = (3.141592653589793238/((double)((ln)))));
				{
					for(int var_108 = 0; var_108 < (((ln)-1)+1); var_108 += 1) {
						((ti) = (((double)((var_108)))*(t)));
						((((((((((*var_95).u))[0]))[((unsigned int)(((var_108)+(ku))))])).real)) = cos((ti)));
						((((((((((*var_95).u))[0]))[((unsigned int)(((var_108)+(ku))))])).imag)) = sin((ti)));
					};
					((i) = (0+(((int)(ceil((((double)(((((ln)-1)+1)-0)))/((double)(1))))))*1)));
				};
				((ku) = ((ku)+(ln)));
				((ln) = (2*(ln)));
			};
			((j) = (1+(((int)(ceil((((double)((((m)+1)-1)))/((double)(1))))))*1)));
		};
	}
}


// start code fragment :: Definitions for function type: __insieme_funType_type_8 //
// Abstract prototype for lambdas of type __insieme_funType_type_8
struct __insieme_funType_type_8 { 
    void(*fun)(void*, int, struct dcomplex(*)[128][128], struct dcomplex(*)[128][128]);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_8
void call__insieme_funType_type_8(struct __insieme_funType_type_8* lambda, int p1, struct dcomplex(* p2)[128][128], struct dcomplex(* p3)[128][128]) { return lambda->fun(lambda, p1,p2,p3); }

// start code fragment :: Definitions for function type: __insieme_funType_type_9 //
// Abstract prototype for lambdas of type __insieme_funType_type_9
struct __insieme_funType_type_9 { 
    void(*fun)(void*, int, struct dcomplex(*)[128][128], struct dcomplex(*)[128][128]);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: Definitions for function type: __insieme_funType_type_10 //
// Abstract prototype for lambdas of type __insieme_funType_type_10
struct __insieme_funType_type_10 { 
    void(*fun)(void*, int, int*, struct dcomplex(*)[128][128], struct dcomplex(*)[128][128], struct dcomplex(*)[18], struct dcomplex(*)[18]);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_10
void call__insieme_funType_type_10(struct __insieme_funType_type_10* lambda, int p1, int* p2, struct dcomplex(* p3)[128][128], struct dcomplex(* p4)[128][128], struct dcomplex(* p5)[18], struct dcomplex(* p6)[18]) { return lambda->fun(lambda, p1,p2,p3,p4,p5,p6); }

// start code fragment :: Definitions for function type: __insieme_funType_type_11 //
// Abstract prototype for lambdas of type __insieme_funType_type_11
struct __insieme_funType_type_11 { 
    void(*fun)(void*, int, int*, struct dcomplex(*)[128][128], struct dcomplex(*)[128][128], struct dcomplex(*)[18], struct dcomplex(*)[18]);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: Definitions for function type: __insieme_funType_type_12 //
// Abstract prototype for lambdas of type __insieme_funType_type_12
struct __insieme_funType_type_12 { 
    void(*fun)(void*, int, int, int, struct dcomplex(*)[18], struct dcomplex(*)[18]);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_12
void call__insieme_funType_type_12(struct __insieme_funType_type_12* lambda, int p1, int p2, int p3, struct dcomplex(* p4)[18], struct dcomplex(* p5)[18]) { return lambda->fun(lambda, p1,p2,p3,p4,p5); }

// start code fragment :: Definitions for function type: __insieme_funType_type_13 //
// Abstract prototype for lambdas of type __insieme_funType_type_13
struct __insieme_funType_type_13 { 
    void(*fun)(void*, int, int, int, struct dcomplex(*)[18], struct dcomplex(*)[18]);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: Prototype for external function: exit //
void exit(int);

// start code fragment :: Definition of fftz2 //
void fftz2(int is, int l, int m, int n, int ny, int ny1, struct dcomplex* u, struct dcomplex(* x)[18], struct dcomplex(* y)[18]) {
	{
		int k = 0;
		int n1 = 0;
		int li = 0;
		int lj = 0;
		int lk = 0;
		int ku = 0;
		int i = 0;
		int j = 0;
		int i11 = 0;
		int i12 = 0;
		int i21 = 0;
		int i22 = 0;
		struct dcomplex u1;
		struct dcomplex x11;
		struct dcomplex x21;
		((n1) = (n/2));
		if(((l-1)==0)) {
			((lk) = 1);
		} else {
			((lk) = (2<<((l-1)-1)));
		};
		if(((m-l)==0)) {
			((li) = 1);
		} else {
			((li) = (2<<((m-l)-1)));
		};
		((lj) = (2*(lk)));
		((ku) = (li));
		{
			for(int var_179 = 0; var_179 < (li); var_179 += 1) {
				((i11) = ((var_179)*(lk)));
				((i12) = ((i11)+(n1)));
				((i21) = ((var_179)*(lj)));
				((i22) = ((i21)+(lk)));
				if((is>=1)) {
					((((u1).real)) = ((((u[((unsigned int)(((ku)+(var_179))))])).real)));
					((((u1).imag)) = ((((u[((unsigned int)(((ku)+(var_179))))])).imag)));
				} else {
					((((u1).real)) = ((((u[((unsigned int)(((ku)+(var_179))))])).real)));
					((((u1).imag)) = (((double)(0))-((((u[((unsigned int)(((ku)+(var_179))))])).imag))));
				};
				{
					for(int var_178 = 0; var_178 < (lk); var_178 += 1) {
						{
							for(int var_177 = 0; var_177 < ny; var_177 += 1) {
								double x11real = 0.0;
								double x11imag = 0.0;
								double x21real = 0.0;
								double x21imag = 0.0;
								((x11real) = ((((((x[((unsigned int)(((i11)+(var_178))))]))[((unsigned int)((var_177)))])).real)));
								((x11imag) = ((((((x[((unsigned int)(((i11)+(var_178))))]))[((unsigned int)((var_177)))])).imag)));
								((x21real) = ((((((x[((unsigned int)(((i12)+(var_178))))]))[((unsigned int)((var_177)))])).real)));
								((x21imag) = ((((((x[((unsigned int)(((i12)+(var_178))))]))[((unsigned int)((var_177)))])).imag)));
								(((((((y[((unsigned int)(((i21)+(var_178))))]))[((unsigned int)((var_177)))])).real)) = ((x11real)+(x21real)));
								(((((((y[((unsigned int)(((i21)+(var_178))))]))[((unsigned int)((var_177)))])).imag)) = ((x11imag)+(x21imag)));
								(((((((y[((unsigned int)(((i22)+(var_178))))]))[((unsigned int)((var_177)))])).real)) = (((((u1).real))*((x11real)-(x21real)))-((((u1).imag))*((x11imag)-(x21imag)))));
								(((((((y[((unsigned int)(((i22)+(var_178))))]))[((unsigned int)((var_177)))])).imag)) = (((((u1).real))*((x11imag)-(x21imag)))+((((u1).imag))*((x11real)-(x21real)))));
							};
							((j) = (0+(((int)(ceil((((double)((ny-0)))/((double)(1))))))*1)));
						};
					};
					((k) = (0+(((int)(ceil((((double)(((lk)-0)))/((double)(1))))))*1)));
				};
			};
			((i) = (0+(((int)(ceil((((double)(((li)-0)))/((double)(1))))))*1)));
		};
	}
}


// start code fragment :: Definition of cfftz //
void cfftz(void* _capture, int is, int m, int n, struct dcomplex(* x)[18], struct dcomplex(* y)[18]) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_137 = ((struct __insieme_funType_type_13*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		int i = 0;
		int j = 0;
		int l = 0;
		int mx = 0;
		((mx) = ((int)((((((((((*var_137).u))[0]))[((unsigned int)(0))])).real)))));
		if(((((is!=1)&&(is!=(((int)(0))-1)))||(m<1))||(m>(mx)))) {
			printf("CFFTZ: Either U has not been initialized, or else\n", is, m, (mx));
			exit(1);
		};
		{
			for(int var_181 = 1; var_181 < (m+1); var_181 += 2) {
				fftz2(is, (var_181), m, n, (((*var_137).fftblock)), (((*var_137).fftblockpad)), (((((*var_137).u))[0])), x, y);
				if(((var_181)==m)) break;
				fftz2(is, ((var_181)+1), m, n, (((*var_137).fftblock)), (((*var_137).fftblockpad)), (((((*var_137).u))[0])), y, x);
			};
			((l) = (1+(((int)(ceil((((double)(((m+1)-1)))/((double)(2))))))*2)));
		};
		if(((m%2)==1)) {
			{
				for(int var_183 = 0; var_183 < n; var_183 += 1) {
					{
						for(int var_182 = 0; var_182 < (((*var_137).fftblock)); var_182 += 1) {
							(((((((x[((unsigned int)((var_183)))]))[((unsigned int)((var_182)))])).real)) = ((((((y[((unsigned int)((var_183)))]))[((unsigned int)((var_182)))])).real)));
							(((((((x[((unsigned int)((var_183)))]))[((unsigned int)((var_182)))])).imag)) = ((((((y[((unsigned int)((var_183)))]))[((unsigned int)((var_182)))])).imag)));
						};
						((i) = (0+(((int)(ceil((((double)(((((*var_137).fftblock))-0)))/((double)(1))))))*1)));
					};
				};
				((j) = (0+(((int)(ceil((((double)((n-0)))/((double)(1))))))*1)));
			};
		};
	}
}


// start code fragment :: Definition of cffts1 //
void cffts1(void* _capture, int is, int* d, struct dcomplex(* x)[128][128], struct dcomplex(* xout)[128][128], struct dcomplex(* y0)[18], struct dcomplex(* y1)[18]) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_123 = ((struct __insieme_funType_type_11*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		int logd[3];
		int i = 0;
		int j = 0;
		int k = 0;
		int jj = 0;
		{
			for(int var_129 = 0; var_129 < 3; var_129 += 1) {
				((((logd)[((unsigned int)((var_129)))])) = ilog2(((d[((unsigned int)((var_129)))]))));
			};
			((i) = (0+(((int)(ceil((((double)((3-0)))/((double)(1))))))*1)));
		};
		{
			for(int var_188 = 0; var_188 < ((d[((unsigned int)(2))])); var_188 += 1) {
				{
					for(int var_187 = 0; var_187 < ((((d[((unsigned int)(1))]))-(((*var_123).fftblock)))+1); var_187 += (((*var_123).fftblock))) {
						{
							for(int var_131 = 0; var_131 < (((*var_123).fftblock)); var_131 += 1) {
								{
									for(int var_130 = 0; var_130 < ((d[((unsigned int)(0))])); var_130 += 1) {
										(((((((y0[((unsigned int)((var_130)))]))[((unsigned int)((var_131)))])).real)) = ((((((x[((unsigned int)((var_188)))]))[((unsigned int)(((var_131)+(var_187))))][((unsigned int)((var_130)))])).real)));
										(((((((y0[((unsigned int)((var_130)))]))[((unsigned int)((var_131)))])).imag)) = ((((((x[((unsigned int)((var_188)))]))[((unsigned int)(((var_131)+(var_187))))][((unsigned int)((var_130)))])).imag)));
									};
									((i) = (0+(((int)(ceil((((double)((((d[((unsigned int)(0))]))-0)))/((double)(1))))))*1)));
								};
							};
							((j) = (0+(((int)(ceil((((double)(((((*var_123).fftblock))-0)))/((double)(1))))))*1)));
						};
						call__insieme_funType_type_12(((struct __insieme_funType_type_12*)(&((struct __insieme_funType_type_13){&cfftz, 0, var_123}))), is, (((logd)[((unsigned int)(0))])), ((d[((unsigned int)(0))])), y0, y1);
						{
							for(int var_186 = 0; var_186 < (((*var_123).fftblock)); var_186 += 1) {
								{
									for(int var_185 = 0; var_185 < ((d[((unsigned int)(0))])); var_185 += 1) {
										(((((((xout[((unsigned int)((var_188)))]))[((unsigned int)(((var_186)+(var_187))))][((unsigned int)((var_185)))])).real)) = ((((((y0[((unsigned int)((var_185)))]))[((unsigned int)((var_186)))])).real)));
										(((((((xout[((unsigned int)((var_188)))]))[((unsigned int)(((var_186)+(var_187))))][((unsigned int)((var_185)))])).imag)) = ((((((y0[((unsigned int)((var_185)))]))[((unsigned int)((var_186)))])).imag)));
									};
									((i) = (0+(((int)(ceil((((double)((((d[((unsigned int)(0))]))-0)))/((double)(1))))))*1)));
								};
							};
							((j) = (0+(((int)(ceil((((double)(((((*var_123).fftblock))-0)))/((double)(1))))))*1)));
						};
					};
					((jj) = (0+(((int)(ceil((((double)((((((d[((unsigned int)(1))]))-(((*var_123).fftblock)))+1)-0)))/((double)((((*var_123).fftblock))))))))*(((*var_123).fftblock)))));
				};
			};
			((k) = (0+(((int)(ceil((((double)((((d[((unsigned int)(2))]))-0)))/((double)(1))))))*1)));
		};
	}
}


// start code fragment :: Definition of cffts2 //
void cffts2(void* _capture, int is, int* d, struct dcomplex(* x)[128][128], struct dcomplex(* xout)[128][128], struct dcomplex(* y0)[18], struct dcomplex(* y1)[18]) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_196 = ((struct __insieme_funType_type_11*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		int logd[3];
		int i = 0;
		int j = 0;
		int k = 0;
		int ii = 0;
		{
			for(int var_202 = 0; var_202 < 3; var_202 += 1) {
				((((logd)[((unsigned int)((var_202)))])) = ilog2(((d[((unsigned int)((var_202)))]))));
			};
			((i) = (0+(((int)(ceil((((double)((3-0)))/((double)(1))))))*1)));
		};
		{
			for(int var_208 = 0; var_208 < ((d[((unsigned int)(2))])); var_208 += 1) {
				{
					for(int var_207 = 0; var_207 < ((((d[((unsigned int)(0))]))-(((*var_196).fftblock)))+1); var_207 += (((*var_196).fftblock))) {
						{
							for(int var_204 = 0; var_204 < ((d[((unsigned int)(1))])); var_204 += 1) {
								{
									for(int var_203 = 0; var_203 < (((*var_196).fftblock)); var_203 += 1) {
										(((((((y0[((unsigned int)((var_204)))]))[((unsigned int)((var_203)))])).real)) = ((((((x[((unsigned int)((var_208)))]))[((unsigned int)((var_204)))][((unsigned int)(((var_203)+(var_207))))])).real)));
										(((((((y0[((unsigned int)((var_204)))]))[((unsigned int)((var_203)))])).imag)) = ((((((x[((unsigned int)((var_208)))]))[((unsigned int)((var_204)))][((unsigned int)(((var_203)+(var_207))))])).imag)));
									};
									((i) = (0+(((int)(ceil((((double)(((((*var_196).fftblock))-0)))/((double)(1))))))*1)));
								};
							};
							((j) = (0+(((int)(ceil((((double)((((d[((unsigned int)(1))]))-0)))/((double)(1))))))*1)));
						};
						call__insieme_funType_type_12(((struct __insieme_funType_type_12*)(&((struct __insieme_funType_type_13){&cfftz, 0, var_196}))), is, (((logd)[((unsigned int)(1))])), ((d[((unsigned int)(1))])), y0, y1);
						{
							for(int var_206 = 0; var_206 < ((d[((unsigned int)(1))])); var_206 += 1) {
								{
									for(int var_205 = 0; var_205 < (((*var_196).fftblock)); var_205 += 1) {
										(((((((xout[((unsigned int)((var_208)))]))[((unsigned int)((var_206)))][((unsigned int)(((var_205)+(var_207))))])).real)) = ((((((y0[((unsigned int)((var_206)))]))[((unsigned int)((var_205)))])).real)));
										(((((((xout[((unsigned int)((var_208)))]))[((unsigned int)((var_206)))][((unsigned int)(((var_205)+(var_207))))])).imag)) = ((((((y0[((unsigned int)((var_206)))]))[((unsigned int)((var_205)))])).imag)));
									};
									((i) = (0+(((int)(ceil((((double)(((((*var_196).fftblock))-0)))/((double)(1))))))*1)));
								};
							};
							((j) = (0+(((int)(ceil((((double)((((d[((unsigned int)(1))]))-0)))/((double)(1))))))*1)));
						};
					};
					((ii) = (0+(((int)(ceil((((double)((((((d[((unsigned int)(0))]))-(((*var_196).fftblock)))+1)-0)))/((double)((((*var_196).fftblock))))))))*(((*var_196).fftblock)))));
				};
			};
			((k) = (0+(((int)(ceil((((double)((((d[((unsigned int)(2))]))-0)))/((double)(1))))))*1)));
		};
	}
}


// start code fragment :: Definition of cffts3 //
void cffts3(void* _capture, int is, int* d, struct dcomplex(* x)[128][128], struct dcomplex(* xout)[128][128], struct dcomplex(* y0)[18], struct dcomplex(* y1)[18]) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_216 = ((struct __insieme_funType_type_11*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		int logd[3];
		int i = 0;
		int j = 0;
		int k = 0;
		int ii = 0;
		{
			for(int var_222 = 0; var_222 < 3; var_222 += 1) {
				((((logd)[((unsigned int)((var_222)))])) = ilog2(((d[((unsigned int)((var_222)))]))));
			};
			((i) = (0+(((int)(ceil((((double)((3-0)))/((double)(1))))))*1)));
		};
		{
			for(int var_228 = 0; var_228 < ((d[((unsigned int)(1))])); var_228 += 1) {
				{
					for(int var_227 = 0; var_227 < ((((d[((unsigned int)(0))]))-(((*var_216).fftblock)))+1); var_227 += (((*var_216).fftblock))) {
						{
							for(int var_224 = 0; var_224 < ((d[((unsigned int)(2))])); var_224 += 1) {
								{
									for(int var_223 = 0; var_223 < (((*var_216).fftblock)); var_223 += 1) {
										(((((((y0[((unsigned int)((var_224)))]))[((unsigned int)((var_223)))])).real)) = ((((((x[((unsigned int)((var_224)))]))[((unsigned int)((var_228)))][((unsigned int)(((var_223)+(var_227))))])).real)));
										(((((((y0[((unsigned int)((var_224)))]))[((unsigned int)((var_223)))])).imag)) = ((((((x[((unsigned int)((var_224)))]))[((unsigned int)((var_228)))][((unsigned int)(((var_223)+(var_227))))])).imag)));
									};
									((i) = (0+(((int)(ceil((((double)(((((*var_216).fftblock))-0)))/((double)(1))))))*1)));
								};
							};
							((k) = (0+(((int)(ceil((((double)((((d[((unsigned int)(2))]))-0)))/((double)(1))))))*1)));
						};
						call__insieme_funType_type_12(((struct __insieme_funType_type_12*)(&((struct __insieme_funType_type_13){&cfftz, 0, var_216}))), is, (((logd)[((unsigned int)(2))])), ((d[((unsigned int)(2))])), y0, y1);
						{
							for(int var_226 = 0; var_226 < ((d[((unsigned int)(2))])); var_226 += 1) {
								{
									for(int var_225 = 0; var_225 < (((*var_216).fftblock)); var_225 += 1) {
										(((((((xout[((unsigned int)((var_226)))]))[((unsigned int)((var_228)))][((unsigned int)(((var_225)+(var_227))))])).real)) = ((((((y0[((unsigned int)((var_226)))]))[((unsigned int)((var_225)))])).real)));
										(((((((xout[((unsigned int)((var_226)))]))[((unsigned int)((var_228)))][((unsigned int)(((var_225)+(var_227))))])).imag)) = ((((((y0[((unsigned int)((var_226)))]))[((unsigned int)((var_225)))])).imag)));
									};
									((i) = (0+(((int)(ceil((((double)(((((*var_216).fftblock))-0)))/((double)(1))))))*1)));
								};
							};
							((k) = (0+(((int)(ceil((((double)((((d[((unsigned int)(2))]))-0)))/((double)(1))))))*1)));
						};
					};
					((ii) = (0+(((int)(ceil((((double)((((((d[((unsigned int)(0))]))-(((*var_216).fftblock)))+1)-0)))/((double)((((*var_216).fftblock))))))))*(((*var_216).fftblock)))));
				};
			};
			((j) = (0+(((int)(ceil((((double)((((d[((unsigned int)(1))]))-0)))/((double)(1))))))*1)));
		};
	}
}


// start code fragment :: Definition of fft //
void fft(void* _capture, int dir, struct dcomplex(* x1)[128][128], struct dcomplex(* x2)[128][128]) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_114 = ((struct __insieme_funType_type_9*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		struct dcomplex y0[128][18];
		struct dcomplex y1[128][18];
		if((dir==1)) {
			call__insieme_funType_type_10(((struct __insieme_funType_type_10*)(&((struct __insieme_funType_type_11){&cffts1, 0, var_114}))), 1, (((((*var_114).dims))[0]))[((unsigned int)(0))], x1, x1, (y0), (y1));
			call__insieme_funType_type_10(((struct __insieme_funType_type_10*)(&((struct __insieme_funType_type_11){&cffts2, 0, var_114}))), 1, (((((*var_114).dims))[0]))[((unsigned int)(1))], x1, x1, (y0), (y1));
			call__insieme_funType_type_10(((struct __insieme_funType_type_10*)(&((struct __insieme_funType_type_11){&cffts3, 0, var_114}))), 1, (((((*var_114).dims))[0]))[((unsigned int)(2))], x1, x2, (y0), (y1));
		} else {
			call__insieme_funType_type_10(((struct __insieme_funType_type_10*)(&((struct __insieme_funType_type_11){&cffts3, 0, var_114}))), (((int)(0))-1), (((((*var_114).dims))[0]))[((unsigned int)(2))], x1, x1, (y0), (y1));
			call__insieme_funType_type_10(((struct __insieme_funType_type_10*)(&((struct __insieme_funType_type_11){&cffts2, 0, var_114}))), (((int)(0))-1), (((((*var_114).dims))[0]))[((unsigned int)(1))], x1, x1, (y0), (y1));
			call__insieme_funType_type_10(((struct __insieme_funType_type_10*)(&((struct __insieme_funType_type_11){&cffts1, 0, var_114}))), (((int)(0))-1), (((((*var_114).dims))[0]))[((unsigned int)(0))], x1, x2, (y0), (y1));
		};
	}
}


// start code fragment :: Definitions for function type: __insieme_funType_type_14 //
// Abstract prototype for lambdas of type __insieme_funType_type_14
struct __insieme_funType_type_14 { 
    double(*fun)(void*);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_14
double call__insieme_funType_type_14(struct __insieme_funType_type_14* lambda) { return lambda->fun(lambda); }

// start code fragment :: Definitions for function type: __insieme_funType_type_15 //
// Abstract prototype for lambdas of type __insieme_funType_type_15
struct __insieme_funType_type_15 { 
    double(*fun)(void*);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: Definitions for function type: __insieme_funType_type_16 //
// Abstract prototype for lambdas of type __insieme_funType_type_16
struct __insieme_funType_type_16 { 
    void(*fun)(void*, double*);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_16
void call__insieme_funType_type_16(struct __insieme_funType_type_16* lambda, double* p1) { return lambda->fun(lambda, p1); }

// start code fragment :: Definitions for function type: __insieme_funType_type_17 //
// Abstract prototype for lambdas of type __insieme_funType_type_17
struct __insieme_funType_type_17 { 
    void(*fun)(void*, double*);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: type_declaration_timeval //
struct timeval { 
    long tv_sec;
    long tv_usec;
};

// start code fragment :: type_declaration_timezone //
struct timezone { 
    int tz_minuteswest;
    int tz_dsttime;
};

// start code fragment :: Prototype for external function: gettimeofday //
int gettimeofday(struct timeval*, struct timezone*);

// start code fragment :: Definition of wtime //
void wtime(void* _capture, double* t) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_237 = ((struct __insieme_funType_type_17*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		struct timeval tv;
		gettimeofday(&tv, null);
		if(((((*var_237).sec))<0)) {
			((((*var_237).sec)) = ((int)((((tv).tv_sec)))));
		};
		(((t[0])) = (((double)(((((tv).tv_sec))-((long)((((*var_237).sec)))))))+(1.0e-6*((double)((((tv).tv_usec)))))));
	}
}


// start code fragment :: Definition of elapsed_time //
double elapsed_time(void* _capture) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_234 = ((struct __insieme_funType_type_15*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		double t = 0.0;
		call__insieme_funType_type_16(((struct __insieme_funType_type_16*)(&((struct __insieme_funType_type_17){&wtime, 0, var_234}))), &t);
		return (t);;
	}
}


// start code fragment :: Definition of timer_start //
void timer_start(void* _capture, int n) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_233 = ((struct __insieme_funType_type_1*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		((((((((*var_233).start))[0]))[((unsigned int)(n))])) = call__insieme_funType_type_14(((struct __insieme_funType_type_14*)(&((struct __insieme_funType_type_15){&elapsed_time, 0, var_233})))));
	}
}


// start code fragment :: Definition of timer_stop //
void timer_stop(void* _capture, int n) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_243 = ((struct __insieme_funType_type_1*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		double t = 0.0;
		double now = 0.0;
		((now) = call__insieme_funType_type_14(((struct __insieme_funType_type_14*)(&((struct __insieme_funType_type_15){&elapsed_time, 0, var_243})))));
		((t) = ((now)-(((((((*var_243).start))[0]))[((unsigned int)(n))]))));
		((((((((*var_243).elapsed))[0]))[((unsigned int)(n))])) = ((((((((*var_243).elapsed))[0]))[((unsigned int)(n))]))+(t)));
	}
}


// start code fragment :: Definitions for function type: __insieme_funType_type_18 //
// Abstract prototype for lambdas of type __insieme_funType_type_18
struct __insieme_funType_type_18 { 
    void(*fun)(void*, struct dcomplex(*)[128][128], struct dcomplex(*)[128][128], int, int(*)[128][128], int*);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_18
void call__insieme_funType_type_18(struct __insieme_funType_type_18* lambda, struct dcomplex(* p1)[128][128], struct dcomplex(* p2)[128][128], int p3, int(* p4)[128][128], int* p5) { return lambda->fun(lambda, p1,p2,p3,p4,p5); }

// start code fragment :: Definitions for function type: __insieme_funType_type_19 //
// Abstract prototype for lambdas of type __insieme_funType_type_19
struct __insieme_funType_type_19 { 
    void(*fun)(void*, struct dcomplex(*)[128][128], struct dcomplex(*)[128][128], int, int(*)[128][128], int*);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: Definitions for function type: __insieme_funType_type_20 //
// Abstract prototype for lambdas of type __insieme_funType_type_20
struct __insieme_funType_type_20 { 
    void(*fun)(void*);
    const size_t size;
    struct dcomplex(* p0)[128][128];
    struct dcomplex(* p1)[128][128];
    int p2;
    int(* p3)[128][128];
    struct __insieme_globals* p4;
    int* p5;
    int* p6;
    int* p7;
};

// start code fragment :: Definition of __insieme_supp_21 //
void __insieme_supp_21(void* _capture) {
	// --------- Captured Stuff - Begin -------------
	struct dcomplex(* var_256)[128][128] = ((struct __insieme_funType_type_20*)_capture)->p0;
	struct dcomplex(* var_257)[128][128] = ((struct __insieme_funType_type_20*)_capture)->p1;
	int var_258 = ((struct __insieme_funType_type_20*)_capture)->p2;
	int(* var_259)[128][128] = ((struct __insieme_funType_type_20*)_capture)->p3;
	struct __insieme_globals* var_260 = ((struct __insieme_funType_type_20*)_capture)->p4;
	int* var_261 = ((struct __insieme_funType_type_20*)_capture)->p5;
	int* var_262 = ((struct __insieme_funType_type_20*)_capture)->p6;
	int* var_263 = ((struct __insieme_funType_type_20*)_capture)->p7;
	// --------- Captured Stuff -  End  -------------
	{
		(((((((var_257[((unsigned int)((*var_263)))]))[((unsigned int)((*var_262)))][((unsigned int)((*var_261)))])).real)) = (((((((var_256[((unsigned int)((*var_263)))]))[((unsigned int)((*var_262)))][((unsigned int)((*var_261)))])).real))*(((((((*var_260).ex))[0]))[((unsigned int)((var_258*((((var_259[((unsigned int)((*var_263)))]))[((unsigned int)((*var_262)))][((unsigned int)((*var_261)))])))))]))));
		return (((((((var_257[((unsigned int)((*var_263)))]))[((unsigned int)((*var_262)))][((unsigned int)((*var_261)))])).imag)) = (((((((var_256[((unsigned int)((*var_263)))]))[((unsigned int)((*var_262)))][((unsigned int)((*var_261)))])).imag))*(((((((*var_260).ex))[0]))[((unsigned int)((var_258*((((var_259[((unsigned int)((*var_263)))]))[((unsigned int)((*var_262)))][((unsigned int)((*var_261)))])))))]))));;
	}
}


// start code fragment :: Definition of evolve //
void evolve(void* _capture, struct dcomplex(* u0)[128][128], struct dcomplex(* u1)[128][128], int t, int(* indexmap)[128][128], int* d) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_252 = ((struct __insieme_funType_type_19*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		int i = 0;
		int j = 0;
		int k = 0;
		{
			for(int var_267 = 0; var_267 < ((d[((unsigned int)(2))])); var_267 += 1) {
				{
					for(int var_266 = 0; var_266 < ((d[((unsigned int)(1))])); var_266 += 1) {
						{
							for(int var_265 = 0; var_265 < ((d[((unsigned int)(0))])); var_265 += 1) {
								call__insieme_funType_type_2(((struct __insieme_funType_type_2*)(&((struct __insieme_funType_type_20){&__insieme_supp_21, 0, u0, u1, t, indexmap, var_252, &var_265, &var_266, &var_267}))));
							};
							((i) = (0+(((int)(ceil((((double)((((d[((unsigned int)(0))]))-0)))/((double)(1))))))*1)));
						};
					};
					((j) = (0+(((int)(ceil((((double)((((d[((unsigned int)(1))]))-0)))/((double)(1))))))*1)));
				};
			};
			((k) = (0+(((int)(ceil((((double)((((d[((unsigned int)(2))]))-0)))/((double)(1))))))*1)));
		};
	}
}


// start code fragment :: Definitions for function type: __insieme_funType_type_22 //
// Abstract prototype for lambdas of type __insieme_funType_type_22
struct __insieme_funType_type_22 { 
    void(*fun)(void*, int, struct dcomplex(*)[128][128], int*);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_22
void call__insieme_funType_type_22(struct __insieme_funType_type_22* lambda, int p1, struct dcomplex(* p2)[128][128], int* p3) { return lambda->fun(lambda, p1,p2,p3); }

// start code fragment :: Definitions for function type: __insieme_funType_type_23 //
// Abstract prototype for lambdas of type __insieme_funType_type_23
struct __insieme_funType_type_23 { 
    void(*fun)(void*, int, struct dcomplex(*)[128][128], int*);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: Definitions for function type: __insieme_funType_type_24 //
// Abstract prototype for lambdas of type __insieme_funType_type_24
struct __insieme_funType_type_24 { 
    void(*fun)(void*);
    const size_t size;
    struct dcomplex(* p0)[128][128];
    struct __insieme_globals* p1;
    int* p2;
    int* p3;
    int* p4;
    struct dcomplex* p5;
};

// start code fragment :: Definition of __insieme_supp_25 //
void __insieme_supp_25(void* _capture) {
	// --------- Captured Stuff - Begin -------------
	struct dcomplex(* var_280)[128][128] = ((struct __insieme_funType_type_24*)_capture)->p0;
	struct __insieme_globals* var_281 = ((struct __insieme_funType_type_24*)_capture)->p1;
	int* var_282 = ((struct __insieme_funType_type_24*)_capture)->p2;
	int* var_283 = ((struct __insieme_funType_type_24*)_capture)->p3;
	int* var_284 = ((struct __insieme_funType_type_24*)_capture)->p4;
	struct dcomplex* var_285 = ((struct __insieme_funType_type_24*)_capture)->p5;
	// --------- Captured Stuff -  End  -------------
	{
		((((*var_285).real)) = ((((*var_285).real))+((((((var_280[((unsigned int)(((*var_284)-(((((((*var_281).zstart))[0]))[((unsigned int)(0))])))))]))[((unsigned int)(((*var_283)-(((((((*var_281).ystart))[0]))[((unsigned int)(0))])))))][((unsigned int)(((*var_282)-(((((((*var_281).xstart))[0]))[((unsigned int)(0))])))))])).real))));
		return ((((*var_285).imag)) = ((((*var_285).imag))+((((((var_280[((unsigned int)(((*var_284)-(((((((*var_281).zstart))[0]))[((unsigned int)(0))])))))]))[((unsigned int)(((*var_283)-(((((((*var_281).ystart))[0]))[((unsigned int)(0))])))))][((unsigned int)(((*var_282)-(((((((*var_281).xstart))[0]))[((unsigned int)(0))])))))])).imag))));;
	}
}


// start code fragment :: Definition of checksum //
void checksum(void* _capture, int i, struct dcomplex(* u1)[128][128], int* d) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_272 = ((struct __insieme_funType_type_23*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		int j = 0;
		int q = 0;
		int r = 0;
		int s = 0;
		int ierr = 0;
		struct dcomplex chk;
		struct dcomplex allchk;
		((((chk).real)) = 0.0);
		((((chk).imag)) = 0.0);
		{
			for(int var_296 = 1; var_296 < (1024+1); var_296 += 1) {
				((q) = (((var_296)%128)+1));
				if((((q)>=(((((((*var_272).xstart))[0]))[((unsigned int)(0))])))&&((q)<=(((((((*var_272).xend))[0]))[((unsigned int)(0))]))))) {
					((r) = (((3*(var_296))%128)+1));
					if((((r)>=(((((((*var_272).ystart))[0]))[((unsigned int)(0))])))&&((r)<=(((((((*var_272).yend))[0]))[((unsigned int)(0))]))))) {
						((s) = (((5*(var_296))%32)+1));
						if((((s)>=(((((((*var_272).zstart))[0]))[((unsigned int)(0))])))&&((s)<=(((((((*var_272).zend))[0]))[((unsigned int)(0))]))))) {
							call__insieme_funType_type_2(((struct __insieme_funType_type_2*)(&((struct __insieme_funType_type_24){&__insieme_supp_25, 0, u1, var_272, &q, &r, &s, &chk}))));
						};
					};
				};
			};
			((j) = (1+(((int)(ceil((((double)(((1024+1)-1)))/((double)(1))))))*1)));
		};
		{
			((((((((((*var_272).sums))[0]))[((unsigned int)(i))])).real)) = ((((((((((*var_272).sums))[0]))[((unsigned int)(i))])).real))+(((chk).real))));
			((((((((((*var_272).sums))[0]))[((unsigned int)(i))])).imag)) = ((((((((((*var_272).sums))[0]))[((unsigned int)(i))])).imag))+(((chk).imag))));
		};
		{
			((((((((((*var_272).sums))[0]))[((unsigned int)(i))])).real)) = ((((((((((*var_272).sums))[0]))[((unsigned int)(i))])).real))/((double)(524288))));
			((((((((((*var_272).sums))[0]))[((unsigned int)(i))])).imag)) = ((((((((((*var_272).sums))[0]))[((unsigned int)(i))])).imag))/((double)(524288))));
			printf("T = %5d     Checksum = %22.12e %22.12e\n", i, (((((((((*var_272).sums))[0]))[((unsigned int)(i))])).real)), (((((((((*var_272).sums))[0]))[((unsigned int)(i))])).imag)));
		};
	}
}


// start code fragment :: Definitions for function type: __insieme_funType_type_26 //
// Abstract prototype for lambdas of type __insieme_funType_type_26
struct __insieme_funType_type_26 { 
    void(*fun)(void*, int, int, int, int, int*, char*);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_26
void call__insieme_funType_type_26(struct __insieme_funType_type_26* lambda, int p1, int p2, int p3, int p4, int* p5, char* p6) { return lambda->fun(lambda, p1,p2,p3,p4,p5,p6); }

// start code fragment :: Definitions for function type: __insieme_funType_type_27 //
// Abstract prototype for lambdas of type __insieme_funType_type_27
struct __insieme_funType_type_27 { 
    void(*fun)(void*, int, int, int, int, int*, char*);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: Prototype for external function: fabs //
double fabs(double);

// start code fragment :: Definition of verify //
void verify(void* _capture, int d1, int d2, int d3, int nt, int* verified, char* class) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_305 = ((struct __insieme_funType_type_27*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		int ierr = 0;
		int size = 0;
		int i = 0;
		double err = 0.0;
		double epsilon = 0.0;
		double vdata_real_s[7] = {0.0, 5.546087004964e+02, 5.546385409189e+02, 5.546148406171e+02, 5.545423607415e+02, 5.544255039624e+02, 5.542683411902e+02};
		double vdata_imag_s[7] = {0.0, 4.845363331978e+02, 4.865304269511e+02, 4.883910722336e+02, 4.901273169046e+02, 4.917475857993e+02, 4.932597244941e+02};
		double vdata_real_w[7] = {0.0, 5.673612178944e+02, 5.631436885271e+02, 5.594024089970e+02, 5.560698047020e+02, 5.530898991250e+02, 5.504159734538e+02};
		double vdata_imag_w[7] = {0.0, 5.293246849175e+02, 5.282149986629e+02, 5.270996558037e+02, 5.260027904925e+02, 5.249400845633e+02, 5.239212247086e+02};
		double vdata_real_a[7] = {0.0, 5.046735008193e+02, 5.059412319734e+02, 5.069376896287e+02, 5.077892868474e+02, 5.085233095391e+02, 5.091487099959e+02};
		double vdata_imag_a[7] = {0.0, 5.114047905510e+02, 5.098809666433e+02, 5.098144042213e+02, 5.101336130759e+02, 5.104914655194e+02, 5.107917842803e+02};
		double vdata_real_b[21] = {0.0, 5.177643571579e+02, 5.154521291263e+02, 5.146409228649e+02, 5.142378756213e+02, 5.139626667737e+02, 5.137423460082e+02, 5.135547056878e+02, 5.133910925466e+02, 5.132470705390e+02, 5.131197729984e+02, 5.130070319283e+02, 5.129070537032e+02, 5.128182883502e+02, 5.127393733383e+02, 5.126691062020e+02, 5.126064276004e+02, 5.125504076570e+02, 5.125002331720e+02, 5.124551951846e+02, 5.124146770029e+02};
		double vdata_imag_b[21] = {0.0, 5.077803458597e+02, 5.088249431599e+02, 5.096208912659e+02, 5.101023387619e+02, 5.103976610617e+02, 5.105948019802e+02, 5.107404165783e+02, 5.108576573661e+02, 5.109577278523e+02, 5.110460304483e+02, 5.111252433800e+02, 5.111968077718e+02, 5.112616233064e+02, 5.113203605551e+02, 5.113735928093e+02, 5.114218460548e+02, 5.114656139760e+02, 5.115053595966e+02, 5.115415130407e+02, 5.115744692211e+02};
		double vdata_real_c[21] = {0.0, 5.195078707457e+02, 5.155422171134e+02, 5.144678022222e+02, 5.140150594328e+02, 5.137550426810e+02, 5.135811056728e+02, 5.134569343165e+02, 5.133651975661e+02, 5.132955192805e+02, 5.132410471738e+02, 5.131971141679e+02, 5.131605205716e+02, 5.131290734194e+02, 5.131012720314e+02, 5.130760908195e+02, 5.130528295923e+02, 5.130310107773e+02, 5.130103090133e+02, 5.129905029333e+02, 5.129714421109e+02};
		double vdata_imag_c[21] = {0.0, 5.149019699238e+02, 5.127578201997e+02, 5.122251847514e+02, 5.121090289018e+02, 5.121143685824e+02, 5.121496764568e+02, 5.121870921893e+02, 5.122193250322e+02, 5.122454735794e+02, 5.122663649603e+02, 5.122830879827e+02, 5.122965869718e+02, 5.123075927445e+02, 5.123166486553e+02, 5.123241541685e+02, 5.123304037599e+02, 5.123356167976e+02, 5.123399592211e+02, 5.123435588985e+02, 5.123465164008e+02};
		((epsilon) = 1.0e-12);
		(((verified[0])) = 1);
		(((class[0])) = ((char)('U')));
		if(((((d1==64)&&(d2==64))&&(d3==64))&&(nt==6))) {
			(((class[0])) = ((char)('S')));
			{
				for(int var_321 = 1; var_321 < (nt+1); var_321 += 1) {
					((err) = (((((((((((*var_305).sums))[0]))[((unsigned int)((var_321)))])).real))-(((vdata_real_s)[((unsigned int)((var_321)))])))/(((vdata_real_s)[((unsigned int)((var_321)))]))));
					if((fabs((err))>(epsilon))) {
						(((verified[0])) = 0);
						break;
					};((err) = (((((((((((*var_305).sums))[0]))[((unsigned int)((var_321)))])).imag))-(((vdata_imag_s)[((unsigned int)((var_321)))])))/(((vdata_imag_s)[((unsigned int)((var_321)))]))));
					if((fabs((err))>(epsilon))) {
						(((verified[0])) = 0);
						break;
					};
				};
				((i) = (1+(((int)(ceil((((double)(((nt+1)-1)))/((double)(1))))))*1)));
			};
		} else if(((((d1==128)&&(d2==128))&&(d3==32))&&(nt==6))) {
			(((class[0])) = ((char)('W')));
			{
				for(int var_328 = 1; var_328 < (nt+1); var_328 += 1) {
					((err) = (((((((((((*var_305).sums))[0]))[((unsigned int)((var_328)))])).real))-(((vdata_real_w)[((unsigned int)((var_328)))])))/(((vdata_real_w)[((unsigned int)((var_328)))]))));
					if((fabs((err))>(epsilon))) {
						(((verified[0])) = 0);
						break;
					};((err) = (((((((((((*var_305).sums))[0]))[((unsigned int)((var_328)))])).imag))-(((vdata_imag_w)[((unsigned int)((var_328)))])))/(((vdata_imag_w)[((unsigned int)((var_328)))]))));
					if((fabs((err))>(epsilon))) {
						(((verified[0])) = 0);
						break;
					};
				};
				((i) = (1+(((int)(ceil((((double)(((nt+1)-1)))/((double)(1))))))*1)));
			};
		} else if(((((d1==256)&&(d2==256))&&(d3==128))&&(nt==6))) {
			(((class[0])) = ((char)('A')));
			{
				for(int var_335 = 1; var_335 < (nt+1); var_335 += 1) {
					((err) = (((((((((((*var_305).sums))[0]))[((unsigned int)((var_335)))])).real))-(((vdata_real_a)[((unsigned int)((var_335)))])))/(((vdata_real_a)[((unsigned int)((var_335)))]))));
					if((fabs((err))>(epsilon))) {
						(((verified[0])) = 0);
						break;
					};((err) = (((((((((((*var_305).sums))[0]))[((unsigned int)((var_335)))])).imag))-(((vdata_imag_a)[((unsigned int)((var_335)))])))/(((vdata_imag_a)[((unsigned int)((var_335)))]))));
					if((fabs((err))>(epsilon))) {
						(((verified[0])) = 0);
						break;
					};
				};
				((i) = (1+(((int)(ceil((((double)(((nt+1)-1)))/((double)(1))))))*1)));
			};
		} else if(((((d1==512)&&(d2==256))&&(d3==256))&&(nt==20))) {
			(((class[0])) = ((char)('B')));
			{
				for(int var_342 = 1; var_342 < (nt+1); var_342 += 1) {
					((err) = (((((((((((*var_305).sums))[0]))[((unsigned int)((var_342)))])).real))-(((vdata_real_b)[((unsigned int)((var_342)))])))/(((vdata_real_b)[((unsigned int)((var_342)))]))));
					if((fabs((err))>(epsilon))) {
						(((verified[0])) = 0);
						break;
					};((err) = (((((((((((*var_305).sums))[0]))[((unsigned int)((var_342)))])).imag))-(((vdata_imag_b)[((unsigned int)((var_342)))])))/(((vdata_imag_b)[((unsigned int)((var_342)))]))));
					if((fabs((err))>(epsilon))) {
						(((verified[0])) = 0);
						break;
					};
				};
				((i) = (1+(((int)(ceil((((double)(((nt+1)-1)))/((double)(1))))))*1)));
			};
		} else if(((((d1==512)&&(d2==512))&&(d3==512))&&(nt==20))) {
			(((class[0])) = ((char)('C')));
			{
				for(int var_349 = 1; var_349 < (nt+1); var_349 += 1) {
					((err) = (((((((((((*var_305).sums))[0]))[((unsigned int)((var_349)))])).real))-(((vdata_real_c)[((unsigned int)((var_349)))])))/(((vdata_real_c)[((unsigned int)((var_349)))]))));
					if((fabs((err))>(epsilon))) {
						(((verified[0])) = 0);
						break;
					};((err) = (((((((((((*var_305).sums))[0]))[((unsigned int)((var_349)))])).imag))-(((vdata_imag_c)[((unsigned int)((var_349)))])))/(((vdata_imag_c)[((unsigned int)((var_349)))]))));
					if((fabs((err))>(epsilon))) {
						(((verified[0])) = 0);
						break;
					};
				};
				((i) = (1+(((int)(ceil((((double)(((nt+1)-1)))/((double)(1))))))*1)));
			};
		};
		if((((int)(((class[0]))))!='U')) {
			printf("Result verification successful\n", 0);
		} else {
			printf("Result verification failed\n", 0);
		};
		printf("class = %1c\n", ((int)(((class[0])))));
	}
}


// start code fragment :: Definitions for function type: __insieme_funType_type_28 //
// Abstract prototype for lambdas of type __insieme_funType_type_28
struct __insieme_funType_type_28 { 
    double(*fun)(void*, int);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_28
double call__insieme_funType_type_28(struct __insieme_funType_type_28* lambda, int p1) { return lambda->fun(lambda, p1); }

// start code fragment :: Definitions for function type: __insieme_funType_type_29 //
// Abstract prototype for lambdas of type __insieme_funType_type_29
struct __insieme_funType_type_29 { 
    double(*fun)(void*, int);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: Definition of timer_read //
double timer_read(void* _capture, int n) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_358 = ((struct __insieme_funType_type_29*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		return (((((((*var_358).elapsed))[0]))[((unsigned int)(n))]));;
	}
}


// start code fragment :: Prototype for external function: log //
double log(double);

// start code fragment :: Definition of c_print_results //
void c_print_results(char* name, char class, int n1, int n2, int n3, int niter, int nthreads, double t, double mops, char* optype, int passed_verification, char* npbversion, char* compiletime, char* cc, char* clink, char* c_lib, char* c_inc, char* cflags, char* clinkflags, char* rand) {
	{
		char* evalue = "1000";
		printf("\n\n %s Benchmark Completed\n", name);
		printf(" Class           =                        %c\n", ((int)(class)));
		if(((n2==0)&&(n3==0))) {
			printf(" Size            =             %12d\n", n1);
		} else {
			printf(" Size            =              %3dx%3dx%3d\n", n1, n2, n3);
		};
		printf(" Iterations      =             %12d\n", niter);
		printf(" Threads         =             %12d\n", nthreads);
		printf(" Time in seconds =             %12.2f\n", 0.0);
		printf(" Mop/s total     =             %12.2f\n", 0.0);
		printf(" Operation type  = %24s\n", optype);
		if(((bool)(passed_verification))) {
			printf(" Verification    =               SUCCESSFUL\n", 0);
		} else {
			printf(" Verification    =             UNSUCCESSFUL\n", 0);
		};
		printf(" Version         =             %12s\n", npbversion);
		printf(" Compile date    =             %12s\n", compiletime);
		printf("\n Compile options:\n", 0);
		printf("    CC           = %s\n", cc);
		printf("    CLINK        = %s\n", clink);
		printf("    C_LIB        = %s\n", c_lib);
		printf("    C_INC        = %s\n", c_inc);
		printf("    CFLAGS       = %s\n", cflags);
		printf("    CLINKFLAGS   = %s\n", clinkflags);
		printf("    RAND         = %s\n", rand);
	}
}


// start code fragment :: Definition of print_timers //
void print_timers(void* _capture) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_384 = ((struct __insieme_funType_type_3*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		int i = 0;
		char*** tstrings[7] = {"          total ", "          setup ", "            fft ", "         evolve ", "       checksum ", "         fftlow ", "        fftcopy "};
		{
			for(int var_387 = 0; var_387 < 7; var_387 += 1) {
				if((call__insieme_funType_type_28(((struct __insieme_funType_type_28*)(&((struct __insieme_funType_type_29){&timer_read, 0, var_384}))), (var_387))!=0.0)) {
					printf("timer %2d(%16s( :%10.6f\n", (var_387), (tstrings)[((unsigned int)((var_387)))], call__insieme_funType_type_28(((struct __insieme_funType_type_28*)(&((struct __insieme_funType_type_29){&timer_read, 0, var_384}))), (var_387)));
				};
			};
			((i) = (0+(((int)(ceil((((double)((7-0)))/((double)(1))))))*1)));
		};
	}
}


// start code fragment :: Definition of main //
int main(int argc, char** argv) {
	{
		struct __insieme_globals var_1 = ((struct __insieme_globals){0,
			0,
			(calloc(sizeof(int[3][3]), 1)),
			(calloc(sizeof(int[3]), 1)),
			(calloc(sizeof(int[3]), 1)),
			(calloc(sizeof(int[3]), 1)),
			(calloc(sizeof(int[3]), 1)),
			(calloc(sizeof(int[3]), 1)),
			(calloc(sizeof(int[3]), 1)),
			(calloc(sizeof(double[50689]), 1)),
			(calloc(sizeof(struct dcomplex[128]), 1)),
			(calloc(sizeof(struct dcomplex[7]), 1)),
			0,
			(calloc(sizeof(struct dcomplex[32][128][128]), 1)),
			(calloc(sizeof(struct dcomplex[3]), 1)),
			(calloc(sizeof(struct dcomplex[32][128][128]), 1)),
			(calloc(sizeof(struct dcomplex[3]), 1)),
			(calloc(sizeof(struct dcomplex[32][128][128]), 1)),
			(calloc(sizeof(struct dcomplex[3]), 1)),
			(calloc(sizeof(int[32][128][128]), 1)),
			(calloc(sizeof(double[32769]), 1)),
			(calloc(sizeof(double[64]), 1)),
			(calloc(sizeof(double[64]), 1)),
			(((int)(0))-1)
		});
		int i = 0;
		int ierr = 0;
		int iter = 0;
		int nthreads = 1;
		double total_time = 0.0;
		double mflops = 0.0;
		int verified = 0;
		char class = '\0';
		{
			for(int var_390 = 0; var_390 < 7; var_390 += 1) {
				call__insieme_funType_type_0(((struct __insieme_funType_type_0*)(&((struct __insieme_funType_type_1){&timer_clear, 0, &var_1}))), (var_390));
			};
			((i) = (0+(((int)(ceil((((double)((7-0)))/((double)(1))))))*1)));
		};
		call__insieme_funType_type_2(((struct __insieme_funType_type_2*)(&((struct __insieme_funType_type_3){&setup, 0, &var_1}))));
		{
			call__insieme_funType_type_4(((struct __insieme_funType_type_4*)(&((struct __insieme_funType_type_5){&compute_indexmap, 0, &var_1}))), (((((var_1).indexmap))[0])), (((((var_1).dims))[0]))[((unsigned int)(2))]);
			{
				call__insieme_funType_type_6(((struct __insieme_funType_type_6*)(&((struct __insieme_funType_type_7){&compute_initial_conditions, 0, &var_1}))), (((((var_1).u1))[0])), (((((var_1).dims))[0]))[((unsigned int)(0))]);
				call__insieme_funType_type_0(((struct __insieme_funType_type_0*)(&((struct __insieme_funType_type_1){&fft_init, 0, &var_1}))), (((((((var_1).dims))[0]))[((unsigned int)(0))][((unsigned int)(0))])));
			};
			call__insieme_funType_type_8(((struct __insieme_funType_type_8*)(&((struct __insieme_funType_type_9){&fft, 0, &var_1}))), 1, (((((var_1).u1))[0])), (((((var_1).u0))[0])));
		};
		{
			for(int var_391 = 0; var_391 < 7; var_391 += 1) {
				call__insieme_funType_type_0(((struct __insieme_funType_type_0*)(&((struct __insieme_funType_type_1){&timer_clear, 0, &var_1}))), (var_391));
			};
			((i) = (0+(((int)(ceil((((double)((7-0)))/((double)(1))))))*1)));
		};
		call__insieme_funType_type_0(((struct __insieme_funType_type_0*)(&((struct __insieme_funType_type_1){&timer_start, 0, &var_1}))), 0);
		if((0==1)) {
			call__insieme_funType_type_0(((struct __insieme_funType_type_0*)(&((struct __insieme_funType_type_1){&timer_start, 0, &var_1}))), 1);
		};
		{
			call__insieme_funType_type_4(((struct __insieme_funType_type_4*)(&((struct __insieme_funType_type_5){&compute_indexmap, 0, &var_1}))), (((((var_1).indexmap))[0])), (((((var_1).dims))[0]))[((unsigned int)(2))]);
			{
				call__insieme_funType_type_6(((struct __insieme_funType_type_6*)(&((struct __insieme_funType_type_7){&compute_initial_conditions, 0, &var_1}))), (((((var_1).u1))[0])), (((((var_1).dims))[0]))[((unsigned int)(0))]);
				call__insieme_funType_type_0(((struct __insieme_funType_type_0*)(&((struct __insieme_funType_type_1){&fft_init, 0, &var_1}))), (((((((var_1).dims))[0]))[((unsigned int)(0))][((unsigned int)(0))])));
			};
			if((0==1)) {
				call__insieme_funType_type_0(((struct __insieme_funType_type_0*)(&((struct __insieme_funType_type_1){&timer_stop, 0, &var_1}))), 1);
			};
			if((0==1)) {
				call__insieme_funType_type_0(((struct __insieme_funType_type_0*)(&((struct __insieme_funType_type_1){&timer_start, 0, &var_1}))), 2);
			};
			call__insieme_funType_type_8(((struct __insieme_funType_type_8*)(&((struct __insieme_funType_type_9){&fft, 0, &var_1}))), 1, (((((var_1).u1))[0])), (((((var_1).u0))[0])));
			if((0==1)) {
				call__insieme_funType_type_0(((struct __insieme_funType_type_0*)(&((struct __insieme_funType_type_1){&timer_stop, 0, &var_1}))), 2);
			};
			{
				for(int var_392 = 1; var_392 < ((((var_1).niter))+1); var_392 += 1) {
					if((0==1)) {
						call__insieme_funType_type_0(((struct __insieme_funType_type_0*)(&((struct __insieme_funType_type_1){&timer_start, 0, &var_1}))), 3);
					};
					call__insieme_funType_type_18(((struct __insieme_funType_type_18*)(&((struct __insieme_funType_type_19){&evolve, 0, &var_1}))), (((((var_1).u0))[0])), (((((var_1).u1))[0])), (var_392), (((((var_1).indexmap))[0])), (((((var_1).dims))[0]))[((unsigned int)(0))]);
					if((0==1)) {
						call__insieme_funType_type_0(((struct __insieme_funType_type_0*)(&((struct __insieme_funType_type_1){&timer_stop, 0, &var_1}))), 3);
					};
					if((0==1)) {
						call__insieme_funType_type_0(((struct __insieme_funType_type_0*)(&((struct __insieme_funType_type_1){&timer_start, 0, &var_1}))), 2);
					};
					call__insieme_funType_type_8(((struct __insieme_funType_type_8*)(&((struct __insieme_funType_type_9){&fft, 0, &var_1}))), (((int)(0))-1), (((((var_1).u1))[0])), (((((var_1).u2))[0])));
					if((0==1)) {
						call__insieme_funType_type_0(((struct __insieme_funType_type_0*)(&((struct __insieme_funType_type_1){&timer_stop, 0, &var_1}))), 2);
					};
					if((0==1)) {
						call__insieme_funType_type_0(((struct __insieme_funType_type_0*)(&((struct __insieme_funType_type_1){&timer_start, 0, &var_1}))), 4);
					};
					call__insieme_funType_type_22(((struct __insieme_funType_type_22*)(&((struct __insieme_funType_type_23){&checksum, 0, &var_1}))), (var_392), (((((var_1).u2))[0])), (((((var_1).dims))[0]))[((unsigned int)(0))]);
					if((0==1)) {
						call__insieme_funType_type_0(((struct __insieme_funType_type_0*)(&((struct __insieme_funType_type_1){&timer_stop, 0, &var_1}))), 4);
					};
				};
				((iter) = (1+(((int)(ceil((((double)((((((var_1).niter))+1)-1)))/((double)(1))))))*1)));
			};
			call__insieme_funType_type_26(((struct __insieme_funType_type_26*)(&((struct __insieme_funType_type_27){&verify, 0, &var_1}))), 128, 128, 32, (((var_1).niter)), &verified, &class);
		};
		call__insieme_funType_type_0(((struct __insieme_funType_type_0*)(&((struct __insieme_funType_type_1){&timer_stop, 0, &var_1}))), 0);
		((total_time) = call__insieme_funType_type_28(((struct __insieme_funType_type_28*)(&((struct __insieme_funType_type_29){&timer_read, 0, &var_1}))), 0));
		if(((total_time)!=0.0)) {
			((mflops) = (((1.0e-6*((double)(524288)))*((14.8157+(7.19641*log(((double)(524288)))))+((5.23518+(7.21113*log(((double)(524288)))))*((double)((((var_1).niter)))))))/(total_time)));
		} else {
			((mflops) = 0.0);
		};
		c_print_results("FT", (class), 128, 128, 32, (((var_1).niter)), (nthreads), (total_time), (mflops), "          floating point", (verified), "2.3", "02 Dec 2010", "cc", "cc", "-lm", "-I../common", "-O3 ", "-lm", "randdp");
		if((0==1)) {
			call__insieme_funType_type_2(((struct __insieme_funType_type_2*)(&((struct __insieme_funType_type_3){&print_timers, 0, &var_1}))));
		};
	}
}

