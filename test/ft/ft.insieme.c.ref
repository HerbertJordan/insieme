// --- Generated Inspire Code ---
#include <alloca.h>
#include <stddef.h>
#include <runtime.h>
#define bool int
#define true 1
#define false 0
#define null 0

// start code fragment :: vector_type_declaration of __insieme_type_2 <=> vector<int<4>,3> //
typedef struct ___insieme_type_2 { 
    int data[3];
} __insieme_type_2;

// A constructor initializing a vector of the type __insieme_type_2 uniformly
static inline __insieme_type_2 __insieme_type_2_init_uniform(int value) {
	__insieme_type_2 res;
	for (int i=0; i<3;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_1 <=> vector<vector<int<4>,3>,3> //
typedef struct ___insieme_type_1 { 
    __insieme_type_2 data[3];
} __insieme_type_1;

// A constructor initializing a vector of the type __insieme_type_1 uniformly
static inline __insieme_type_1 __insieme_type_1_init_uniform(__insieme_type_2 value) {
	__insieme_type_1 res;
	for (int i=0; i<3;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_3 <=> vector<real<8>,50689> //
typedef struct ___insieme_type_3 { 
    double data[50689];
} __insieme_type_3;

// A constructor initializing a vector of the type __insieme_type_3 uniformly
static inline __insieme_type_3 __insieme_type_3_init_uniform(double value) {
	__insieme_type_3 res;
	for (int i=0; i<50689;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: type_declaration_dcomplex //
struct dcomplex { 
    double real;
    double imag;
};

// start code fragment :: vector_type_declaration of __insieme_type_4 <=> vector<struct<real:real<8>,imag:real<8>>,128> //
typedef struct ___insieme_type_4 { 
    struct dcomplex data[128];
} __insieme_type_4;

// A constructor initializing a vector of the type __insieme_type_4 uniformly
static inline __insieme_type_4 __insieme_type_4_init_uniform(struct dcomplex value) {
	__insieme_type_4 res;
	for (int i=0; i<128;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_5 <=> vector<struct<real:real<8>,imag:real<8>>,7> //
typedef struct ___insieme_type_5 { 
    struct dcomplex data[7];
} __insieme_type_5;

// A constructor initializing a vector of the type __insieme_type_5 uniformly
static inline __insieme_type_5 __insieme_type_5_init_uniform(struct dcomplex value) {
	__insieme_type_5 res;
	for (int i=0; i<7;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_7 <=> vector<vector<struct<real:real<8>,imag:real<8>>,128>,128> //
typedef struct ___insieme_type_7 { 
    __insieme_type_4 data[128];
} __insieme_type_7;

// A constructor initializing a vector of the type __insieme_type_7 uniformly
static inline __insieme_type_7 __insieme_type_7_init_uniform(__insieme_type_4 value) {
	__insieme_type_7 res;
	for (int i=0; i<128;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_6 <=> vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32> //
typedef struct ___insieme_type_6 { 
    __insieme_type_7 data[32];
} __insieme_type_6;

// A constructor initializing a vector of the type __insieme_type_6 uniformly
static inline __insieme_type_6 __insieme_type_6_init_uniform(__insieme_type_7 value) {
	__insieme_type_6 res;
	for (int i=0; i<32;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_8 <=> vector<struct<real:real<8>,imag:real<8>>,3> //
typedef struct ___insieme_type_8 { 
    struct dcomplex data[3];
} __insieme_type_8;

// A constructor initializing a vector of the type __insieme_type_8 uniformly
static inline __insieme_type_8 __insieme_type_8_init_uniform(struct dcomplex value) {
	__insieme_type_8 res;
	for (int i=0; i<3;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_11 <=> vector<int<4>,128> //
typedef struct ___insieme_type_11 { 
    int data[128];
} __insieme_type_11;

// A constructor initializing a vector of the type __insieme_type_11 uniformly
static inline __insieme_type_11 __insieme_type_11_init_uniform(int value) {
	__insieme_type_11 res;
	for (int i=0; i<128;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_10 <=> vector<vector<int<4>,128>,128> //
typedef struct ___insieme_type_10 { 
    __insieme_type_11 data[128];
} __insieme_type_10;

// A constructor initializing a vector of the type __insieme_type_10 uniformly
static inline __insieme_type_10 __insieme_type_10_init_uniform(__insieme_type_11 value) {
	__insieme_type_10 res;
	for (int i=0; i<128;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_9 <=> vector<vector<vector<int<4>,128>,128>,32> //
typedef struct ___insieme_type_9 { 
    __insieme_type_10 data[32];
} __insieme_type_9;

// A constructor initializing a vector of the type __insieme_type_9 uniformly
static inline __insieme_type_9 __insieme_type_9_init_uniform(__insieme_type_10 value) {
	__insieme_type_9 res;
	for (int i=0; i<32;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_12 <=> vector<real<8>,32769> //
typedef struct ___insieme_type_12 { 
    double data[32769];
} __insieme_type_12;

// A constructor initializing a vector of the type __insieme_type_12 uniformly
static inline __insieme_type_12 __insieme_type_12_init_uniform(double value) {
	__insieme_type_12 res;
	for (int i=0; i<32769;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_13 <=> vector<real<8>,64> //
typedef struct ___insieme_type_13 { 
    double data[64];
} __insieme_type_13;

// A constructor initializing a vector of the type __insieme_type_13 uniformly
static inline __insieme_type_13 __insieme_type_13_init_uniform(double value) {
	__insieme_type_13 res;
	for (int i=0; i<64;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: type_declaration___insieme_globals //
struct __insieme_globals { 
    int fftblock;
    int fftblockpad;
    __insieme_type_1 dims;
    __insieme_type_2 xstart;
    __insieme_type_2 ystart;
    __insieme_type_2 zstart;
    __insieme_type_2 xend;
    __insieme_type_2 yend;
    __insieme_type_2 zend;
    __insieme_type_3 ex;
    __insieme_type_4 u;
    __insieme_type_5 sums;
    int niter;
    __insieme_type_6 u0;
    __insieme_type_8 pad1;
    __insieme_type_6 u1;
    __insieme_type_8 pad2;
    __insieme_type_6 u2;
    __insieme_type_8 pad3;
    __insieme_type_9 indexmap;
    __insieme_type_12 tmp;
    __insieme_type_13 start;
    __insieme_type_13 elapsed;
    int sec;
};

// start code fragment :: Definition of timer_clear ... type: ((ref<struct<fftblock:int<4>,fftblockpad:int<4>,dims:vector<vector<int<4>,3>,3>,xstart:vector<int<4>,3>,ystart:vector<int<4>,3>,zstart:vector<int<4>,3>,xend:vector<int<4>,3>,yend:vector<int<4>,3>,zend:vector<int<4>,3>,ex:vector<real<8>,50689>,u:vector<struct<real:real<8>,imag:real<8>>,128>,sums:vector<struct<real:real<8>,imag:real<8>>,7>,niter:int<4>,u0:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad1:vector<struct<real:real<8>,imag:real<8>>,3>,u1:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad2:vector<struct<real:real<8>,imag:real<8>>,3>,u2:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad3:vector<struct<real:real<8>,imag:real<8>>,3>,indexmap:vector<vector<vector<int<4>,128>,128>,32>,tmp:vector<real<8>,32769>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,int<4>)->unit) //
void timer_clear(struct __insieme_globals* var_75, int n) { ((((*(&((*var_75).elapsed))).data[((unsigned int)(n))])) = 0.0); }
static void timer_clear_wrap(void* _closure, struct __insieme_globals* var_75, int n) { timer_clear(var_75, n); }

// start code fragment :: Prototype for external function: ceil ... type: ((real<8>)->real<8>) //
double ceil(double);
static double ceil_wrap(void* _closure, double var_437) { return ceil(var_437); }

// start code fragment :: Prototype for external function: printf ... type: ((ref<array<char,1>>,var_list)->int<4>) //
int printf(char*, ...);

// start code fragment :: Definition of setup ... type: ((ref<struct<fftblock:int<4>,fftblockpad:int<4>,dims:vector<vector<int<4>,3>,3>,xstart:vector<int<4>,3>,ystart:vector<int<4>,3>,zstart:vector<int<4>,3>,xend:vector<int<4>,3>,yend:vector<int<4>,3>,zend:vector<int<4>,3>,ex:vector<real<8>,50689>,u:vector<struct<real:real<8>,imag:real<8>>,128>,sums:vector<struct<real:real<8>,imag:real<8>>,7>,niter:int<4>,u0:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad1:vector<struct<real:real<8>,imag:real<8>>,3>,u1:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad2:vector<struct<real:real<8>,imag:real<8>>,3>,u2:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad3:vector<struct<real:real<8>,imag:real<8>>,3>,indexmap:vector<vector<vector<int<4>,128>,128>,32>,tmp:vector<real<8>,32769>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>)->unit) //
void setup(struct __insieme_globals* var_93){
	int ierr = 0;
	int i = 0;
	int j = 0;
	int fstatus = 0;
	printf("\n\n NAS Parallel Benchmarks 2.3 OpenMP C version - FT Benchmark\n\n", 0);
	((*(&((*var_93).niter))) = 6);
	printf(" Size                : %3dx%3dx%3d\n", 128, 128, 32);
	printf(" Iterations          :     %7d\n", (*(&((*var_93).niter))));
	{
		for(int var_99 = 0; var_99 < 3; var_99 += 1) {
			((((((*(&((*var_93).dims))).data[((unsigned int)(var_99))])).data[((unsigned int)(0))])) = 128);
			((((((*(&((*var_93).dims))).data[((unsigned int)(var_99))])).data[((unsigned int)(1))])) = 128);
			((((((*(&((*var_93).dims))).data[((unsigned int)(var_99))])).data[((unsigned int)(2))])) = 32);
		};
		((i) = (0+(((int)(ceil((((double)((3-0)))/((double)(1))))))*1)));
	};
	{
		for(int var_101 = 0; var_101 < 3; var_101 += 1) {
			((((*(&((*var_93).xstart))).data[((unsigned int)(var_101))])) = 1);
			((((*(&((*var_93).xend))).data[((unsigned int)(var_101))])) = 128);
			((((*(&((*var_93).ystart))).data[((unsigned int)(var_101))])) = 1);
			((((*(&((*var_93).yend))).data[((unsigned int)(var_101))])) = 128);
			((((*(&((*var_93).zstart))).data[((unsigned int)(var_101))])) = 1);
			((((*(&((*var_93).zend))).data[((unsigned int)(var_101))])) = 32);
		};
		((i) = (0+(((int)(ceil((((double)((3-0)))/((double)(1))))))*1)));
	};
	((*(&((*var_93).fftblock))) = 16);
	((*(&((*var_93).fftblockpad))) = 18);
	if(((*(&((*var_93).fftblock)))!=16)) { ((*(&((*var_93).fftblockpad))) = ((*(&((*var_93).fftblock)))+3)); };
}
static void setup_wrap(void* _closure, struct __insieme_globals* var_93) { setup(var_93); }

// start code fragment :: Prototype for external function: exp ... type: ((real<8>)->real<8>) //
double exp(double);
static double exp_wrap(void* _closure, double var_438) { return exp(var_438); }

// start code fragment :: Definition of compute_indexmap ... type: ((ref<struct<fftblock:int<4>,fftblockpad:int<4>,dims:vector<vector<int<4>,3>,3>,xstart:vector<int<4>,3>,ystart:vector<int<4>,3>,zstart:vector<int<4>,3>,xend:vector<int<4>,3>,yend:vector<int<4>,3>,zend:vector<int<4>,3>,ex:vector<real<8>,50689>,u:vector<struct<real:real<8>,imag:real<8>>,128>,sums:vector<struct<real:real<8>,imag:real<8>>,7>,niter:int<4>,u0:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad1:vector<struct<real:real<8>,imag:real<8>>,3>,u1:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad2:vector<struct<real:real<8>,imag:real<8>>,3>,u2:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad3:vector<struct<real:real<8>,imag:real<8>>,3>,indexmap:vector<vector<vector<int<4>,128>,128>,32>,tmp:vector<real<8>,32769>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,ref<array<vector<vector<int<4>,128>,128>,1>>,ref<array<int<4>,1>>)->unit) //
void compute_indexmap(struct __insieme_globals* var_103, __insieme_type_10* indexmap, int* d){
	int i = 0;
	int j = 0;
	int k = 0;
	int ii = 0;
	int ii2 = 0;
	int jj = 0;
	int ij2 = 0;
	int kk = 0;
	double ap = 0.0;
	{
		for(int var_120 = 0; var_120 < (((((*(&((*var_103).dims))).data[((unsigned int)(2))])).data[((unsigned int)(0))])); var_120 += 1) {
			((ii) = ((((((var_120+1)+(((*(&((*var_103).xstart))).data[((unsigned int)(2))])))-2)+(128/2))%128)-(128/2)));
			((ii2) = ((ii)*(ii)));
			{
				for(int var_118 = 0; var_118 < (((((*(&((*var_103).dims))).data[((unsigned int)(2))])).data[((unsigned int)(1))])); var_118 += 1) {
					((jj) = ((((((var_118+1)+(((*(&((*var_103).ystart))).data[((unsigned int)(2))])))-2)+(128/2))%128)-(128/2)));
					((ij2) = (((jj)*(jj))+(ii2)));
					{
						for(int var_116 = 0; var_116 < (((((*(&((*var_103).dims))).data[((unsigned int)(2))])).data[((unsigned int)(2))])); var_116 += 1) {
							((kk) = ((((((var_116+1)+(((*(&((*var_103).zstart))).data[((unsigned int)(2))])))-2)+(32/2))%32)-(32/2)));
							(((((((indexmap[((unsigned int)(var_116))])).data[((unsigned int)(var_118))])).data[((unsigned int)(var_120))])) = (((kk)*(kk))+(ij2)));
						};
						((k) = (0+(((int)(ceil((((double)(((((((*(&((*var_103).dims))).data[((unsigned int)(2))])).data[((unsigned int)(2))]))-0)))/((double)(1))))))*1)));
					};
				};
				((j) = (0+(((int)(ceil((((double)(((((((*(&((*var_103).dims))).data[((unsigned int)(2))])).data[((unsigned int)(1))]))-0)))/((double)(1))))))*1)));
			};
		};
		((i) = (0+(((int)(ceil((((double)(((((((*(&((*var_103).dims))).data[((unsigned int)(2))])).data[((unsigned int)(0))]))-0)))/((double)(1))))))*1)));
	};
	{
		((ap) = ((((((double)(0))-4.0)*1.0e-6)*3.141592653589793238)*3.141592653589793238));
		((((*(&((*var_103).ex))).data[((unsigned int)(0))])) = 1.0);
		((((*(&((*var_103).ex))).data[((unsigned int)(1))])) = exp((ap)));
		{
			for(int var_122 = 2; var_122 < ((6*((((128*128)/4)+((128*128)/4))+((32*32)/4)))+1); var_122 += 1)  { ((((*(&((*var_103).ex))).data[((unsigned int)(var_122))])) = ((((*(&((*var_103).ex))).data[((unsigned int)((var_122-1)))]))*(((*(&((*var_103).ex))).data[((unsigned int)(1))])))); };
			((i) = (2+(((int)(ceil((((double)((((6*((((128*128)/4)+((128*128)/4))+((32*32)/4)))+1)-2)))/((double)(1))))))*1)));
		};
	};
}
static void compute_indexmap_wrap(void* _closure, struct __insieme_globals* var_103, __insieme_type_10* indexmap, int* d) { compute_indexmap(var_103, indexmap, d); }

// start code fragment :: Definition of randlc ... type: ((ref<array<real<8>,1>>,real<8>)->real<8>) //
double randlc(double* x, double a){
	double t1 = 0.0;
	double t2 = 0.0;
	double t3 = 0.0;
	double t4 = 0.0;
	double a1 = 0.0;
	double a2 = 0.0;
	double x1 = 0.0;
	double x2 = 0.0;
	double z = 0.0;
	((t1) = (((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*a));
	((a1) = ((double)(((int)((t1))))));
	((a2) = (a-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(a1))));
	((t1) = (((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((x[0]))));
	((x1) = ((double)(((int)((t1))))));
	((x2) = (((x[0]))-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(x1))));
	((t1) = (((a1)*(x2))+((a2)*(x1))));
	((t2) = ((double)(((int)((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*(t1)))))));
	((z) = ((t1)-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(t2))));
	((t3) = ((((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(z))+((a2)*(x2))));
	((t4) = ((double)(((int)(((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5))*(t3)))))));
	(((x[0])) = ((t3)-((((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0))*(t4))));
	return ((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5))*((x[0])));
}
static double randlc_wrap(void* _closure, double* x, double a) { return randlc(x, a); }

// start code fragment :: Definition of ipow46 ... type: ((real<8>,int<4>,ref<array<real<8>,1>>)->int<4>) //
int ipow46(double a, int exponent, double* result){
	double dummy = 0.0;
	double q = 0.0;
	double r = 0.0;
	int n = 0;
	int n2 = 0;
	(((result[0])) = ((double)(1)));
	if((exponent==0)) { return 0; };
	((q) = a);
	((r) = ((double)(1)));
	((n) = exponent);
	while(((n)>1)) {
		((n2) = ((n)/2));
		if((((n2)*2)==(n))){
			((dummy) = randlc((&q), (q)));
			((n) = (n2));
		} else {
			((dummy) = randlc((&r), (q)));
			((n) = ((n)-1));
		};
	};
	((dummy) = randlc((&r), (q)));
	(((result[0])) = (r));
	return 0;
}
static int ipow46_wrap(void* _closure, double a, int exponent, double* result) { return ipow46(a, exponent, result); }

// start code fragment :: Definition of vranlc ... type: ((int<4>,ref<array<real<8>,1>>,real<8>,ref<array<real<8>,1>>)->unit) //
void vranlc(int n, double* x_seed, double a, double* y){
	int i = 0;
	double x = 0.0;
	double t1 = 0.0;
	double t2 = 0.0;
	double t3 = 0.0;
	double t4 = 0.0;
	double a1 = 0.0;
	double a2 = 0.0;
	double x1 = 0.0;
	double x2 = 0.0;
	double z = 0.0;
	((t1) = (((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*a));
	((a1) = ((double)(((int)((t1))))));
	((a2) = (a-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(a1))));
	((x) = ((x_seed[0])));
	{
		for(int var_34 = 1; var_34 < (n+1); var_34 += 1) {
			((t1) = (((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*(x)));
			((x1) = ((double)(((int)((t1))))));
			((x2) = ((x)-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(x1))));
			((t1) = (((a1)*(x2))+((a2)*(x1))));
			((t2) = ((double)(((int)((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*(t1)))))));
			((z) = ((t1)-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(t2))));
			((t3) = ((((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(z))+((a2)*(x2))));
			((t4) = ((double)(((int)(((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5))*(t3)))))));
			((x) = ((t3)-((((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0))*(t4))));
			(((y[((unsigned int)(var_34))])) = ((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5))*(x)));
		};
		((i) = (1+(((int)(ceil((((double)(((n+1)-1)))/((double)(1))))))*1)));
	};
	(((x_seed[0])) = (x));
}
static void vranlc_wrap(void* _closure, int n, double* x_seed, double a, double* y) { vranlc(n, x_seed, a, y); }

// start code fragment :: Definition of compute_initial_conditions ... type: ((ref<struct<fftblock:int<4>,fftblockpad:int<4>,dims:vector<vector<int<4>,3>,3>,xstart:vector<int<4>,3>,ystart:vector<int<4>,3>,zstart:vector<int<4>,3>,xend:vector<int<4>,3>,yend:vector<int<4>,3>,zend:vector<int<4>,3>,ex:vector<real<8>,50689>,u:vector<struct<real:real<8>,imag:real<8>>,128>,sums:vector<struct<real:real<8>,imag:real<8>>,7>,niter:int<4>,u0:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad1:vector<struct<real:real<8>,imag:real<8>>,3>,u1:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad2:vector<struct<real:real<8>,imag:real<8>>,3>,u2:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad3:vector<struct<real:real<8>,imag:real<8>>,3>,indexmap:vector<vector<vector<int<4>,128>,128>,32>,tmp:vector<real<8>,32769>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,ref<array<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,1>>,ref<array<int<4>,1>>)->unit) //
void compute_initial_conditions(struct __insieme_globals* var_124, __insieme_type_7* u0, int* d){
	int k = 0;
	double x0 = 0.0;
	double start = 0.0;
	double an = 0.0;
	double dummy = 0.0;
	int i = 0;
	int j = 0;
	int t = 0;
	((start) = 314159265.0);
	ipow46(1220703125.0, ((((((((*(&((*var_124).zstart))).data[((unsigned int)(0))]))-1)*2)*128)*128)+((((((*(&((*var_124).ystart))).data[((unsigned int)(0))]))-1)*2)*128)), (&an));
	((dummy) = randlc((&start), (an)));
	ipow46(1220703125.0, ((2*128)*128), (&an));
	{
		for(int var_149 = 0; var_149 < (((((*(&((*var_124).dims))).data[((unsigned int)(0))])).data[((unsigned int)(2))])); var_149 += 1) {
			((x0) = (start));
			vranlc(((2*128)*(((((*(&((*var_124).dims))).data[((unsigned int)(0))])).data[((unsigned int)(1))]))), (&x0), 1220703125.0, (((double*){(*(&((*var_124).tmp))).data})));
			((t) = 1);
			{
				for(int var_147 = 0; var_147 < (((((*(&((*var_124).dims))).data[((unsigned int)(0))])).data[((unsigned int)(1))])); var_147 += 1) {
					for(int var_145 = 0; var_145 < 128; var_145 += 1) {
						((*(&(((((((u0[((unsigned int)(var_149))])).data[((unsigned int)(var_147))])).data[((unsigned int)(var_145))])).real))) = (((*(&((*var_124).tmp))).data[((unsigned int)(((t)++)))])));
						((*(&(((((((u0[((unsigned int)(var_149))])).data[((unsigned int)(var_147))])).data[((unsigned int)(var_145))])).imag))) = (((*(&((*var_124).tmp))).data[((unsigned int)(((t)++)))])));
					};
					((i) = (0+(((int)(ceil((((double)((128-0)))/((double)(1))))))*1)));
				};
				((j) = (0+(((int)(ceil((((double)(((((((*(&((*var_124).dims))).data[((unsigned int)(0))])).data[((unsigned int)(1))]))-0)))/((double)(1))))))*1)));
			};
			if((var_149!=(((((*(&((*var_124).dims))).data[((unsigned int)(0))])).data[((unsigned int)(2))])))) { ((dummy) = randlc((&start), (an))); };
		};
		((k) = (0+(((int)(ceil((((double)(((((((*(&((*var_124).dims))).data[((unsigned int)(0))])).data[((unsigned int)(2))]))-0)))/((double)(1))))))*1)));
	};
}
static void compute_initial_conditions_wrap(void* _closure, struct __insieme_globals* var_124, __insieme_type_7* u0, int* d) { compute_initial_conditions(var_124, u0, d); }

// start code fragment :: Definition of ilog2 ... type: ((int<4>)->int<4>) //
int ilog2(int n){
	int nn = 0;
	int lg = 0;
	if((n==1)) { return 0; };
	((lg) = 1);
	((nn) = 2);
	while(((nn)<n)) {
		((nn) = ((nn)<<1));
		((lg)++);
	};
	return (lg);
}
static int ilog2_wrap(void* _closure, int n) { return ilog2(n); }

// start code fragment :: Prototype for external function: cos ... type: ((real<8>)->real<8>) //
double cos(double);
static double cos_wrap(void* _closure, double var_439) { return cos(var_439); }

// start code fragment :: Prototype for external function: sin ... type: ((real<8>)->real<8>) //
double sin(double);
static double sin_wrap(void* _closure, double var_440) { return sin(var_440); }

// start code fragment :: Definition of fft_init ... type: ((ref<struct<fftblock:int<4>,fftblockpad:int<4>,dims:vector<vector<int<4>,3>,3>,xstart:vector<int<4>,3>,ystart:vector<int<4>,3>,zstart:vector<int<4>,3>,xend:vector<int<4>,3>,yend:vector<int<4>,3>,zend:vector<int<4>,3>,ex:vector<real<8>,50689>,u:vector<struct<real:real<8>,imag:real<8>>,128>,sums:vector<struct<real:real<8>,imag:real<8>>,7>,niter:int<4>,u0:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad1:vector<struct<real:real<8>,imag:real<8>>,3>,u1:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad2:vector<struct<real:real<8>,imag:real<8>>,3>,u2:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad3:vector<struct<real:real<8>,imag:real<8>>,3>,indexmap:vector<vector<vector<int<4>,128>,128>,32>,tmp:vector<real<8>,32769>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,int<4>)->unit) //
void fft_init(struct __insieme_globals* var_151, int n){
	int m = 0;
	int nu = 0;
	int ku = 0;
	int i = 0;
	int j = 0;
	int ln = 0;
	double t = 0.0;
	double ti = 0.0;
	((nu) = n);
	((m) = ilog2(n));
	((*(&((((*(&((*var_151).u))).data[((unsigned int)(0))])).real))) = ((double)((m))));
	((*(&((((*(&((*var_151).u))).data[((unsigned int)(0))])).imag))) = 0.0);
	((ku) = 1);
	((ln) = 1);
	{
		for(int var_168 = 1; var_168 < ((m)+1); var_168 += 1) {
			((t) = (3.141592653589793238/((double)((ln)))));
			{
				for(int var_166 = 0; var_166 < (((ln)-1)+1); var_166 += 1) {
					((ti) = (((double)(var_166))*(t)));
					((*(&((((*(&((*var_151).u))).data[((unsigned int)((var_166+(ku))))])).real))) = cos((ti)));
					((*(&((((*(&((*var_151).u))).data[((unsigned int)((var_166+(ku))))])).imag))) = sin((ti)));
				};
				((i) = (0+(((int)(ceil((((double)(((((ln)-1)+1)-0)))/((double)(1))))))*1)));
			};
			((ku) = ((ku)+(ln)));
			((ln) = (2*(ln)));
		};
		((j) = (1+(((int)(ceil((((double)((((m)+1)-1)))/((double)(1))))))*1)));
	};
}
static void fft_init_wrap(void* _closure, struct __insieme_globals* var_151, int n) { fft_init(var_151, n); }

// start code fragment :: vector_type_declaration of __insieme_type_15 <=> vector<struct<real:real<8>,imag:real<8>>,18> //
typedef struct ___insieme_type_15 { 
    struct dcomplex data[18];
} __insieme_type_15;

// A constructor initializing a vector of the type __insieme_type_15 uniformly
static inline __insieme_type_15 __insieme_type_15_init_uniform(struct dcomplex value) {
	__insieme_type_15 res;
	for (int i=0; i<18;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_14 <=> vector<vector<struct<real:real<8>,imag:real<8>>,18>,128> //
typedef struct ___insieme_type_14 { 
    __insieme_type_15 data[128];
} __insieme_type_14;

// A constructor initializing a vector of the type __insieme_type_14 uniformly
static inline __insieme_type_14 __insieme_type_14_init_uniform(__insieme_type_15 value) {
	__insieme_type_14 res;
	for (int i=0; i<128;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: Prototype for external function: exit ... type: ((int<4>)->unit) //
void exit(int);
static void exit_wrap(void* _closure, int var_441) { exit(var_441); }

// start code fragment :: Definition of fftz2 ... type: ((int<4>,int<4>,int<4>,int<4>,int<4>,int<4>,ref<array<struct<real:real<8>,imag:real<8>>,1>>,ref<array<vector<struct<real:real<8>,imag:real<8>>,18>,1>>,ref<array<vector<struct<real:real<8>,imag:real<8>>,18>,1>>)->unit) //
void fftz2(int is, int l, int m, int n, int ny, int ny1, struct dcomplex* u, __insieme_type_15* x, __insieme_type_15* y){
	int k = 0;
	int n1 = 0;
	int li = 0;
	int lj = 0;
	int lk = 0;
	int ku = 0;
	int i = 0;
	int j = 0;
	int i11 = 0;
	int i12 = 0;
	int i21 = 0;
	int i22 = 0;
	struct dcomplex u1;
	struct dcomplex x11;
	struct dcomplex x21;
	((n1) = (n/2));
	if(((l-1)==0)) { ((lk) = 1); } else  { ((lk) = (2<<((l-1)-1))); };
	if(((m-l)==0)) { ((li) = 1); } else  { ((li) = (2<<((m-l)-1))); };
	((lj) = (2*(lk)));
	((ku) = (li));
	{
		for(int var_244 = 0; var_244 < (li); var_244 += 1) {
			((i11) = (var_244*(lk)));
			((i12) = ((i11)+(n1)));
			((i21) = (var_244*(lj)));
			((i22) = ((i21)+(lk)));
			if((is>=1)){
				((*(&((u1).real))) = (*(&(((u[((unsigned int)(((ku)+var_244)))])).real))));
				((*(&((u1).imag))) = (*(&(((u[((unsigned int)(((ku)+var_244)))])).imag))));
			} else {
				((*(&((u1).real))) = (*(&(((u[((unsigned int)(((ku)+var_244)))])).real))));
				((*(&((u1).imag))) = (((double)(0))-(*(&(((u[((unsigned int)(((ku)+var_244)))])).imag)))));
			};
			{
				for(int var_242 = 0; var_242 < (lk); var_242 += 1)  { {
					for(int var_240 = 0; var_240 < ny; var_240 += 1) {
						double x11real = 0.0;
						double x11imag = 0.0;
						double x21real = 0.0;
						double x21imag = 0.0;
						((x11real) = (*(&(((((x[((unsigned int)(((i11)+var_242)))])).data[((unsigned int)(var_240))])).real))));
						((x11imag) = (*(&(((((x[((unsigned int)(((i11)+var_242)))])).data[((unsigned int)(var_240))])).imag))));
						((x21real) = (*(&(((((x[((unsigned int)(((i12)+var_242)))])).data[((unsigned int)(var_240))])).real))));
						((x21imag) = (*(&(((((x[((unsigned int)(((i12)+var_242)))])).data[((unsigned int)(var_240))])).imag))));
						((*(&(((((y[((unsigned int)(((i21)+var_242)))])).data[((unsigned int)(var_240))])).real))) = ((x11real)+(x21real)));
						((*(&(((((y[((unsigned int)(((i21)+var_242)))])).data[((unsigned int)(var_240))])).imag))) = ((x11imag)+(x21imag)));
						((*(&(((((y[((unsigned int)(((i22)+var_242)))])).data[((unsigned int)(var_240))])).real))) = (((*(&((u1).real)))*((x11real)-(x21real)))-((*(&((u1).imag)))*((x11imag)-(x21imag)))));
						((*(&(((((y[((unsigned int)(((i22)+var_242)))])).data[((unsigned int)(var_240))])).imag))) = (((*(&((u1).real)))*((x11imag)-(x21imag)))+((*(&((u1).imag)))*((x11real)-(x21real)))));
					};
					((j) = (0+(((int)(ceil((((double)((ny-0)))/((double)(1))))))*1)));
				}; };
				((k) = (0+(((int)(ceil((((double)(((lk)-0)))/((double)(1))))))*1)));
			};
		};
		((i) = (0+(((int)(ceil((((double)(((li)-0)))/((double)(1))))))*1)));
	};
}
static void fftz2_wrap(void* _closure, int is, int l, int m, int n, int ny, int ny1, struct dcomplex* u, __insieme_type_15* x, __insieme_type_15* y) { fftz2(is, l, m, n, ny, ny1, u, x, y); }

// start code fragment :: Definition of cfftz ... type: ((ref<struct<fftblock:int<4>,fftblockpad:int<4>,dims:vector<vector<int<4>,3>,3>,xstart:vector<int<4>,3>,ystart:vector<int<4>,3>,zstart:vector<int<4>,3>,xend:vector<int<4>,3>,yend:vector<int<4>,3>,zend:vector<int<4>,3>,ex:vector<real<8>,50689>,u:vector<struct<real:real<8>,imag:real<8>>,128>,sums:vector<struct<real:real<8>,imag:real<8>>,7>,niter:int<4>,u0:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad1:vector<struct<real:real<8>,imag:real<8>>,3>,u1:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad2:vector<struct<real:real<8>,imag:real<8>>,3>,u2:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad3:vector<struct<real:real<8>,imag:real<8>>,3>,indexmap:vector<vector<vector<int<4>,128>,128>,32>,tmp:vector<real<8>,32769>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,int<4>,int<4>,int<4>,ref<array<vector<struct<real:real<8>,imag:real<8>>,18>,1>>,ref<array<vector<struct<real:real<8>,imag:real<8>>,18>,1>>)->unit) //
void cfftz(struct __insieme_globals* var_194, int is, int m, int n, __insieme_type_15* x, __insieme_type_15* y){
	int i = 0;
	int j = 0;
	int l = 0;
	int mx = 0;
	((mx) = ((int)((*(&((((*(&((*var_194).u))).data[((unsigned int)(0))])).real))))));
	if(((((is!=1)&&(is!=(((int)(0))-1)))||(m<1))||(m>(mx)))){
		printf("CFFTZ: Either U has not been initialized, or else\n", is, m, (mx));
		exit(1);
	};
	{
		for(int var_247 = 1; var_247 < (m+1); var_247 += 2) {
			fftz2(is, var_247, m, n, (*(&((*var_194).fftblock))), (*(&((*var_194).fftblockpad))), (((struct dcomplex*){(*(&((*var_194).u))).data})), x, y);
			if((var_247==m)) { break; };
			fftz2(is, (var_247+1), m, n, (*(&((*var_194).fftblock))), (*(&((*var_194).fftblockpad))), (((struct dcomplex*){(*(&((*var_194).u))).data})), y, x);
		};
		((l) = (1+(((int)(ceil((((double)(((m+1)-1)))/((double)(2))))))*2)));
	};
	if(((m%2)==1)) { {
		for(int var_251 = 0; var_251 < n; var_251 += 1)  { {
			for(int var_249 = 0; var_249 < (*(&((*var_194).fftblock))); var_249 += 1) {
				((*(&(((((x[((unsigned int)(var_251))])).data[((unsigned int)(var_249))])).real))) = (*(&(((((y[((unsigned int)(var_251))])).data[((unsigned int)(var_249))])).real))));
				((*(&(((((x[((unsigned int)(var_251))])).data[((unsigned int)(var_249))])).imag))) = (*(&(((((y[((unsigned int)(var_251))])).data[((unsigned int)(var_249))])).imag))));
			};
			((i) = (0+(((int)(ceil((((double)(((*(&((*var_194).fftblock)))-0)))/((double)(1))))))*1)));
		}; };
		((j) = (0+(((int)(ceil((((double)((n-0)))/((double)(1))))))*1)));
	}; };
}
static void cfftz_wrap(void* _closure, struct __insieme_globals* var_194, int is, int m, int n, __insieme_type_15* x, __insieme_type_15* y) { cfftz(var_194, is, m, n, x, y); }

// start code fragment :: Definition of cffts1 ... type: ((ref<struct<fftblock:int<4>,fftblockpad:int<4>,dims:vector<vector<int<4>,3>,3>,xstart:vector<int<4>,3>,ystart:vector<int<4>,3>,zstart:vector<int<4>,3>,xend:vector<int<4>,3>,yend:vector<int<4>,3>,zend:vector<int<4>,3>,ex:vector<real<8>,50689>,u:vector<struct<real:real<8>,imag:real<8>>,128>,sums:vector<struct<real:real<8>,imag:real<8>>,7>,niter:int<4>,u0:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad1:vector<struct<real:real<8>,imag:real<8>>,3>,u1:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad2:vector<struct<real:real<8>,imag:real<8>>,3>,u2:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad3:vector<struct<real:real<8>,imag:real<8>>,3>,indexmap:vector<vector<vector<int<4>,128>,128>,32>,tmp:vector<real<8>,32769>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,int<4>,ref<array<int<4>,1>>,ref<array<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,1>>,ref<array<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,1>>,ref<array<vector<struct<real:real<8>,imag:real<8>>,18>,1>>,ref<array<vector<struct<real:real<8>,imag:real<8>>,18>,1>>)->unit) //
void cffts1(struct __insieme_globals* var_176, int is, int* d, __insieme_type_7* x, __insieme_type_7* xout, __insieme_type_15* y0, __insieme_type_15* y1){
	__insieme_type_2 logd;
	int i = 0;
	int j = 0;
	int k = 0;
	int jj = 0;
	{
		for(int var_189 = 0; var_189 < 3; var_189 += 1)  { ((((logd).data[((unsigned int)(var_189))])) = ilog2(((d[((unsigned int)(var_189))])))); };
		((i) = (0+(((int)(ceil((((double)((3-0)))/((double)(1))))))*1)));
	};
	{
		for(int var_260 = 0; var_260 < ((d[((unsigned int)(2))])); var_260 += 1)  { {
			for(int var_258 = 0; var_258 < ((((d[((unsigned int)(1))]))-(*(&((*var_176).fftblock))))+1); var_258 += (*(&((*var_176).fftblock)))) {
				{
					for(int var_193 = 0; var_193 < (*(&((*var_176).fftblock))); var_193 += 1)  { {
						for(int var_191 = 0; var_191 < ((d[((unsigned int)(0))])); var_191 += 1) {
							((*(&(((((y0[((unsigned int)(var_191))])).data[((unsigned int)(var_193))])).real))) = (*(&(((((((x[((unsigned int)(var_260))])).data[((unsigned int)((var_193+var_258)))])).data[((unsigned int)(var_191))])).real))));
							((*(&(((((y0[((unsigned int)(var_191))])).data[((unsigned int)(var_193))])).imag))) = (*(&(((((((x[((unsigned int)(var_260))])).data[((unsigned int)((var_193+var_258)))])).data[((unsigned int)(var_191))])).imag))));
						};
						((i) = (0+(((int)(ceil((((double)((((d[((unsigned int)(0))]))-0)))/((double)(1))))))*1)));
					}; };
					((j) = (0+(((int)(ceil((((double)(((*(&((*var_176).fftblock)))-0)))/((double)(1))))))*1)));
				};
				cfftz(var_176, is, (((logd).data[((unsigned int)(0))])), ((d[((unsigned int)(0))])), y0, y1);
				{
					for(int var_256 = 0; var_256 < (*(&((*var_176).fftblock))); var_256 += 1)  { {
						for(int var_254 = 0; var_254 < ((d[((unsigned int)(0))])); var_254 += 1) {
							((*(&(((((((xout[((unsigned int)(var_260))])).data[((unsigned int)((var_256+var_258)))])).data[((unsigned int)(var_254))])).real))) = (*(&(((((y0[((unsigned int)(var_254))])).data[((unsigned int)(var_256))])).real))));
							((*(&(((((((xout[((unsigned int)(var_260))])).data[((unsigned int)((var_256+var_258)))])).data[((unsigned int)(var_254))])).imag))) = (*(&(((((y0[((unsigned int)(var_254))])).data[((unsigned int)(var_256))])).imag))));
						};
						((i) = (0+(((int)(ceil((((double)((((d[((unsigned int)(0))]))-0)))/((double)(1))))))*1)));
					}; };
					((j) = (0+(((int)(ceil((((double)(((*(&((*var_176).fftblock)))-0)))/((double)(1))))))*1)));
				};
			};
			((jj) = (0+(((int)(ceil((((double)((((((d[((unsigned int)(1))]))-(*(&((*var_176).fftblock))))+1)-0)))/((double)((*(&((*var_176).fftblock)))))))))*(*(&((*var_176).fftblock))))));
		}; };
		((k) = (0+(((int)(ceil((((double)((((d[((unsigned int)(2))]))-0)))/((double)(1))))))*1)));
	};
}
static void cffts1_wrap(void* _closure, struct __insieme_globals* var_176, int is, int* d, __insieme_type_7* x, __insieme_type_7* xout, __insieme_type_15* y0, __insieme_type_15* y1) { cffts1(var_176, is, d, x, xout, y0, y1); }

// start code fragment :: Definition of cffts2 ... type: ((ref<struct<fftblock:int<4>,fftblockpad:int<4>,dims:vector<vector<int<4>,3>,3>,xstart:vector<int<4>,3>,ystart:vector<int<4>,3>,zstart:vector<int<4>,3>,xend:vector<int<4>,3>,yend:vector<int<4>,3>,zend:vector<int<4>,3>,ex:vector<real<8>,50689>,u:vector<struct<real:real<8>,imag:real<8>>,128>,sums:vector<struct<real:real<8>,imag:real<8>>,7>,niter:int<4>,u0:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad1:vector<struct<real:real<8>,imag:real<8>>,3>,u1:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad2:vector<struct<real:real<8>,imag:real<8>>,3>,u2:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad3:vector<struct<real:real<8>,imag:real<8>>,3>,indexmap:vector<vector<vector<int<4>,128>,128>,32>,tmp:vector<real<8>,32769>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,int<4>,ref<array<int<4>,1>>,ref<array<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,1>>,ref<array<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,1>>,ref<array<vector<struct<real:real<8>,imag:real<8>>,18>,1>>,ref<array<vector<struct<real:real<8>,imag:real<8>>,18>,1>>)->unit) //
void cffts2(struct __insieme_globals* var_262, int is, int* d, __insieme_type_7* x, __insieme_type_7* xout, __insieme_type_15* y0, __insieme_type_15* y1){
	__insieme_type_2 logd;
	int i = 0;
	int j = 0;
	int k = 0;
	int ii = 0;
	{
		for(int var_275 = 0; var_275 < 3; var_275 += 1)  { ((((logd).data[((unsigned int)(var_275))])) = ilog2(((d[((unsigned int)(var_275))])))); };
		((i) = (0+(((int)(ceil((((double)((3-0)))/((double)(1))))))*1)));
	};
	{
		for(int var_287 = 0; var_287 < ((d[((unsigned int)(2))])); var_287 += 1)  { {
			for(int var_285 = 0; var_285 < ((((d[((unsigned int)(0))]))-(*(&((*var_262).fftblock))))+1); var_285 += (*(&((*var_262).fftblock)))) {
				{
					for(int var_279 = 0; var_279 < ((d[((unsigned int)(1))])); var_279 += 1)  { {
						for(int var_277 = 0; var_277 < (*(&((*var_262).fftblock))); var_277 += 1) {
							((*(&(((((y0[((unsigned int)(var_279))])).data[((unsigned int)(var_277))])).real))) = (*(&(((((((x[((unsigned int)(var_287))])).data[((unsigned int)(var_279))])).data[((unsigned int)((var_277+var_285)))])).real))));
							((*(&(((((y0[((unsigned int)(var_279))])).data[((unsigned int)(var_277))])).imag))) = (*(&(((((((x[((unsigned int)(var_287))])).data[((unsigned int)(var_279))])).data[((unsigned int)((var_277+var_285)))])).imag))));
						};
						((i) = (0+(((int)(ceil((((double)(((*(&((*var_262).fftblock)))-0)))/((double)(1))))))*1)));
					}; };
					((j) = (0+(((int)(ceil((((double)((((d[((unsigned int)(1))]))-0)))/((double)(1))))))*1)));
				};
				cfftz(var_262, is, (((logd).data[((unsigned int)(1))])), ((d[((unsigned int)(1))])), y0, y1);
				{
					for(int var_283 = 0; var_283 < ((d[((unsigned int)(1))])); var_283 += 1)  { {
						for(int var_281 = 0; var_281 < (*(&((*var_262).fftblock))); var_281 += 1) {
							((*(&(((((((xout[((unsigned int)(var_287))])).data[((unsigned int)(var_283))])).data[((unsigned int)((var_281+var_285)))])).real))) = (*(&(((((y0[((unsigned int)(var_283))])).data[((unsigned int)(var_281))])).real))));
							((*(&(((((((xout[((unsigned int)(var_287))])).data[((unsigned int)(var_283))])).data[((unsigned int)((var_281+var_285)))])).imag))) = (*(&(((((y0[((unsigned int)(var_283))])).data[((unsigned int)(var_281))])).imag))));
						};
						((i) = (0+(((int)(ceil((((double)(((*(&((*var_262).fftblock)))-0)))/((double)(1))))))*1)));
					}; };
					((j) = (0+(((int)(ceil((((double)((((d[((unsigned int)(1))]))-0)))/((double)(1))))))*1)));
				};
			};
			((ii) = (0+(((int)(ceil((((double)((((((d[((unsigned int)(0))]))-(*(&((*var_262).fftblock))))+1)-0)))/((double)((*(&((*var_262).fftblock)))))))))*(*(&((*var_262).fftblock))))));
		}; };
		((k) = (0+(((int)(ceil((((double)((((d[((unsigned int)(2))]))-0)))/((double)(1))))))*1)));
	};
}
static void cffts2_wrap(void* _closure, struct __insieme_globals* var_262, int is, int* d, __insieme_type_7* x, __insieme_type_7* xout, __insieme_type_15* y0, __insieme_type_15* y1) { cffts2(var_262, is, d, x, xout, y0, y1); }

// start code fragment :: Definition of cffts3 ... type: ((ref<struct<fftblock:int<4>,fftblockpad:int<4>,dims:vector<vector<int<4>,3>,3>,xstart:vector<int<4>,3>,ystart:vector<int<4>,3>,zstart:vector<int<4>,3>,xend:vector<int<4>,3>,yend:vector<int<4>,3>,zend:vector<int<4>,3>,ex:vector<real<8>,50689>,u:vector<struct<real:real<8>,imag:real<8>>,128>,sums:vector<struct<real:real<8>,imag:real<8>>,7>,niter:int<4>,u0:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad1:vector<struct<real:real<8>,imag:real<8>>,3>,u1:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad2:vector<struct<real:real<8>,imag:real<8>>,3>,u2:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad3:vector<struct<real:real<8>,imag:real<8>>,3>,indexmap:vector<vector<vector<int<4>,128>,128>,32>,tmp:vector<real<8>,32769>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,int<4>,ref<array<int<4>,1>>,ref<array<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,1>>,ref<array<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,1>>,ref<array<vector<struct<real:real<8>,imag:real<8>>,18>,1>>,ref<array<vector<struct<real:real<8>,imag:real<8>>,18>,1>>)->unit) //
void cffts3(struct __insieme_globals* var_289, int is, int* d, __insieme_type_7* x, __insieme_type_7* xout, __insieme_type_15* y0, __insieme_type_15* y1){
	__insieme_type_2 logd;
	int i = 0;
	int j = 0;
	int k = 0;
	int ii = 0;
	{
		for(int var_302 = 0; var_302 < 3; var_302 += 1)  { ((((logd).data[((unsigned int)(var_302))])) = ilog2(((d[((unsigned int)(var_302))])))); };
		((i) = (0+(((int)(ceil((((double)((3-0)))/((double)(1))))))*1)));
	};
	{
		for(int var_314 = 0; var_314 < ((d[((unsigned int)(1))])); var_314 += 1)  { {
			for(int var_312 = 0; var_312 < ((((d[((unsigned int)(0))]))-(*(&((*var_289).fftblock))))+1); var_312 += (*(&((*var_289).fftblock)))) {
				{
					for(int var_306 = 0; var_306 < ((d[((unsigned int)(2))])); var_306 += 1)  { {
						for(int var_304 = 0; var_304 < (*(&((*var_289).fftblock))); var_304 += 1) {
							((*(&(((((y0[((unsigned int)(var_306))])).data[((unsigned int)(var_304))])).real))) = (*(&(((((((x[((unsigned int)(var_306))])).data[((unsigned int)(var_314))])).data[((unsigned int)((var_304+var_312)))])).real))));
							((*(&(((((y0[((unsigned int)(var_306))])).data[((unsigned int)(var_304))])).imag))) = (*(&(((((((x[((unsigned int)(var_306))])).data[((unsigned int)(var_314))])).data[((unsigned int)((var_304+var_312)))])).imag))));
						};
						((i) = (0+(((int)(ceil((((double)(((*(&((*var_289).fftblock)))-0)))/((double)(1))))))*1)));
					}; };
					((k) = (0+(((int)(ceil((((double)((((d[((unsigned int)(2))]))-0)))/((double)(1))))))*1)));
				};
				cfftz(var_289, is, (((logd).data[((unsigned int)(2))])), ((d[((unsigned int)(2))])), y0, y1);
				{
					for(int var_310 = 0; var_310 < ((d[((unsigned int)(2))])); var_310 += 1)  { {
						for(int var_308 = 0; var_308 < (*(&((*var_289).fftblock))); var_308 += 1) {
							((*(&(((((((xout[((unsigned int)(var_310))])).data[((unsigned int)(var_314))])).data[((unsigned int)((var_308+var_312)))])).real))) = (*(&(((((y0[((unsigned int)(var_310))])).data[((unsigned int)(var_308))])).real))));
							((*(&(((((((xout[((unsigned int)(var_310))])).data[((unsigned int)(var_314))])).data[((unsigned int)((var_308+var_312)))])).imag))) = (*(&(((((y0[((unsigned int)(var_310))])).data[((unsigned int)(var_308))])).imag))));
						};
						((i) = (0+(((int)(ceil((((double)(((*(&((*var_289).fftblock)))-0)))/((double)(1))))))*1)));
					}; };
					((k) = (0+(((int)(ceil((((double)((((d[((unsigned int)(2))]))-0)))/((double)(1))))))*1)));
				};
			};
			((ii) = (0+(((int)(ceil((((double)((((((d[((unsigned int)(0))]))-(*(&((*var_289).fftblock))))+1)-0)))/((double)((*(&((*var_289).fftblock)))))))))*(*(&((*var_289).fftblock))))));
		}; };
		((j) = (0+(((int)(ceil((((double)((((d[((unsigned int)(1))]))-0)))/((double)(1))))))*1)));
	};
}
static void cffts3_wrap(void* _closure, struct __insieme_globals* var_289, int is, int* d, __insieme_type_7* x, __insieme_type_7* xout, __insieme_type_15* y0, __insieme_type_15* y1) { cffts3(var_289, is, d, x, xout, y0, y1); }

// start code fragment :: Definition of fft ... type: ((ref<struct<fftblock:int<4>,fftblockpad:int<4>,dims:vector<vector<int<4>,3>,3>,xstart:vector<int<4>,3>,ystart:vector<int<4>,3>,zstart:vector<int<4>,3>,xend:vector<int<4>,3>,yend:vector<int<4>,3>,zend:vector<int<4>,3>,ex:vector<real<8>,50689>,u:vector<struct<real:real<8>,imag:real<8>>,128>,sums:vector<struct<real:real<8>,imag:real<8>>,7>,niter:int<4>,u0:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad1:vector<struct<real:real<8>,imag:real<8>>,3>,u1:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad2:vector<struct<real:real<8>,imag:real<8>>,3>,u2:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad3:vector<struct<real:real<8>,imag:real<8>>,3>,indexmap:vector<vector<vector<int<4>,128>,128>,32>,tmp:vector<real<8>,32769>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,int<4>,ref<array<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,1>>,ref<array<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,1>>)->unit) //
void fft(struct __insieme_globals* var_170, int dir, __insieme_type_7* x1, __insieme_type_7* x2){
	__insieme_type_14 y0;
	__insieme_type_14 y1;
	if((dir==1)){
		cffts1(var_170, 1, (((int*){(((*(&((*var_170).dims))).data[((unsigned int)(0))])).data})), x1, x1, (((__insieme_type_15*){(y0).data})), (((__insieme_type_15*){(y1).data})));
		cffts2(var_170, 1, (((int*){(((*(&((*var_170).dims))).data[((unsigned int)(1))])).data})), x1, x1, (((__insieme_type_15*){(y0).data})), (((__insieme_type_15*){(y1).data})));
		cffts3(var_170, 1, (((int*){(((*(&((*var_170).dims))).data[((unsigned int)(2))])).data})), x1, x2, (((__insieme_type_15*){(y0).data})), (((__insieme_type_15*){(y1).data})));
	} else {
		cffts3(var_170, (((int)(0))-1), (((int*){(((*(&((*var_170).dims))).data[((unsigned int)(2))])).data})), x1, x1, (((__insieme_type_15*){(y0).data})), (((__insieme_type_15*){(y1).data})));
		cffts2(var_170, (((int)(0))-1), (((int*){(((*(&((*var_170).dims))).data[((unsigned int)(1))])).data})), x1, x1, (((__insieme_type_15*){(y0).data})), (((__insieme_type_15*){(y1).data})));
		cffts1(var_170, (((int)(0))-1), (((int*){(((*(&((*var_170).dims))).data[((unsigned int)(0))])).data})), x1, x2, (((__insieme_type_15*){(y0).data})), (((__insieme_type_15*){(y1).data})));
	};
}
static void fft_wrap(void* _closure, struct __insieme_globals* var_170, int dir, __insieme_type_7* x1, __insieme_type_7* x2) { fft(var_170, dir, x1, x2); }

// start code fragment :: type_declaration_timeval //
struct timeval { 
    long tv_sec;
    long tv_usec;
};

// start code fragment :: type_declaration_timezone //
struct timezone { 
    int tz_minuteswest;
    int tz_dsttime;
};

// start code fragment :: Prototype for external function: gettimeofday ... type: ((ref<array<struct<tv_sec:int<8>,tv_usec:int<8>>,1>>,ref<array<struct<tz_minuteswest:int<4>,tz_dsttime:int<4>>,1>>)->int<4>) //
int gettimeofday(struct timeval*, struct timezone*);
static int gettimeofday_wrap(void* _closure, struct timeval* var_442, struct timezone* var_443) { return gettimeofday(var_442, var_443); }

// start code fragment :: Definition of wtime ... type: ((ref<struct<fftblock:int<4>,fftblockpad:int<4>,dims:vector<vector<int<4>,3>,3>,xstart:vector<int<4>,3>,ystart:vector<int<4>,3>,zstart:vector<int<4>,3>,xend:vector<int<4>,3>,yend:vector<int<4>,3>,zend:vector<int<4>,3>,ex:vector<real<8>,50689>,u:vector<struct<real:real<8>,imag:real<8>>,128>,sums:vector<struct<real:real<8>,imag:real<8>>,7>,niter:int<4>,u0:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad1:vector<struct<real:real<8>,imag:real<8>>,3>,u1:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad2:vector<struct<real:real<8>,imag:real<8>>,3>,u2:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad3:vector<struct<real:real<8>,imag:real<8>>,3>,indexmap:vector<vector<vector<int<4>,128>,128>,32>,tmp:vector<real<8>,32769>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,ref<array<real<8>,1>>)->unit) //
void wtime(struct __insieme_globals* var_63, double* t){
	struct timeval tv;
	gettimeofday((&tv), 0);
	if(((*(&((*var_63).sec)))<0)) { ((*(&((*var_63).sec))) = ((int)((*(&((tv).tv_sec)))))); };
	(((t[0])) = (((double)(((*(&((tv).tv_sec)))-((long)((*(&((*var_63).sec))))))))+(1.0e-6*((double)((*(&((tv).tv_usec))))))));
}
static void wtime_wrap(void* _closure, struct __insieme_globals* var_63, double* t) { wtime(var_63, t); }

// start code fragment :: Definition of elapsed_time ... type: ((ref<struct<fftblock:int<4>,fftblockpad:int<4>,dims:vector<vector<int<4>,3>,3>,xstart:vector<int<4>,3>,ystart:vector<int<4>,3>,zstart:vector<int<4>,3>,xend:vector<int<4>,3>,yend:vector<int<4>,3>,zend:vector<int<4>,3>,ex:vector<real<8>,50689>,u:vector<struct<real:real<8>,imag:real<8>>,128>,sums:vector<struct<real:real<8>,imag:real<8>>,7>,niter:int<4>,u0:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad1:vector<struct<real:real<8>,imag:real<8>>,3>,u1:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad2:vector<struct<real:real<8>,imag:real<8>>,3>,u2:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad3:vector<struct<real:real<8>,imag:real<8>>,3>,indexmap:vector<vector<vector<int<4>,128>,128>,32>,tmp:vector<real<8>,32769>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>)->real<8>) //
double elapsed_time(struct __insieme_globals* var_67){
	double t = 0.0;
	wtime(var_67, (&t));
	return (t);
}
static double elapsed_time_wrap(void* _closure, struct __insieme_globals* var_67) { return elapsed_time(var_67); }

// start code fragment :: Definition of timer_start ... type: ((ref<struct<fftblock:int<4>,fftblockpad:int<4>,dims:vector<vector<int<4>,3>,3>,xstart:vector<int<4>,3>,ystart:vector<int<4>,3>,zstart:vector<int<4>,3>,xend:vector<int<4>,3>,yend:vector<int<4>,3>,zend:vector<int<4>,3>,ex:vector<real<8>,50689>,u:vector<struct<real:real<8>,imag:real<8>>,128>,sums:vector<struct<real:real<8>,imag:real<8>>,7>,niter:int<4>,u0:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad1:vector<struct<real:real<8>,imag:real<8>>,3>,u1:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad2:vector<struct<real:real<8>,imag:real<8>>,3>,u2:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad3:vector<struct<real:real<8>,imag:real<8>>,3>,indexmap:vector<vector<vector<int<4>,128>,128>,32>,tmp:vector<real<8>,32769>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,int<4>)->unit) //
void timer_start(struct __insieme_globals* var_78, int n) { ((((*(&((*var_78).start))).data[((unsigned int)(n))])) = elapsed_time(var_78)); }
static void timer_start_wrap(void* _closure, struct __insieme_globals* var_78, int n) { timer_start(var_78, n); }

// start code fragment :: Definition of timer_stop ... type: ((ref<struct<fftblock:int<4>,fftblockpad:int<4>,dims:vector<vector<int<4>,3>,3>,xstart:vector<int<4>,3>,ystart:vector<int<4>,3>,zstart:vector<int<4>,3>,xend:vector<int<4>,3>,yend:vector<int<4>,3>,zend:vector<int<4>,3>,ex:vector<real<8>,50689>,u:vector<struct<real:real<8>,imag:real<8>>,128>,sums:vector<struct<real:real<8>,imag:real<8>>,7>,niter:int<4>,u0:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad1:vector<struct<real:real<8>,imag:real<8>>,3>,u1:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad2:vector<struct<real:real<8>,imag:real<8>>,3>,u2:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad3:vector<struct<real:real<8>,imag:real<8>>,3>,indexmap:vector<vector<vector<int<4>,128>,128>,32>,tmp:vector<real<8>,32769>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,int<4>)->unit) //
void timer_stop(struct __insieme_globals* var_70, int n){
	double t = 0.0;
	double now = 0.0;
	((now) = elapsed_time(var_70));
	((t) = ((now)-(((*(&((*var_70).start))).data[((unsigned int)(n))]))));
	((((*(&((*var_70).elapsed))).data[((unsigned int)(n))])) = ((((*(&((*var_70).elapsed))).data[((unsigned int)(n))]))+(t)));
}
static void timer_stop_wrap(void* _closure, struct __insieme_globals* var_70, int n) { timer_stop(var_70, n); }

// start code fragment :: Definition of _crmul ... type: ((ref<array<struct<real:real<8>,imag:real<8>>,1>>,ref<array<struct<real:real<8>,imag:real<8>>,1>>,int<4>)->real<8>) //
double _crmul(struct dcomplex* c, struct dcomplex* a, int b){
	((*(&(((c[0])).real))) = ((*(&(((a[0])).real)))*((double)(b))));
	return ((double)(((*(&(((c[0])).imag))) = ((*(&(((a[0])).imag)))*((double)(b))))));
}
static double _crmul_wrap(void* _closure, struct dcomplex* c, struct dcomplex* a, int b) { return _crmul(c, a, b); }

// start code fragment :: Definition of evolve ... type: ((ref<struct<fftblock:int<4>,fftblockpad:int<4>,dims:vector<vector<int<4>,3>,3>,xstart:vector<int<4>,3>,ystart:vector<int<4>,3>,zstart:vector<int<4>,3>,xend:vector<int<4>,3>,yend:vector<int<4>,3>,zend:vector<int<4>,3>,ex:vector<real<8>,50689>,u:vector<struct<real:real<8>,imag:real<8>>,128>,sums:vector<struct<real:real<8>,imag:real<8>>,7>,niter:int<4>,u0:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad1:vector<struct<real:real<8>,imag:real<8>>,3>,u1:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad2:vector<struct<real:real<8>,imag:real<8>>,3>,u2:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad3:vector<struct<real:real<8>,imag:real<8>>,3>,indexmap:vector<vector<vector<int<4>,128>,128>,32>,tmp:vector<real<8>,32769>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,ref<array<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,1>>,ref<array<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,1>>,int<4>,ref<array<vector<vector<int<4>,128>,128>,1>>,ref<array<int<4>,1>>)->unit) //
void evolve(struct __insieme_globals* var_319, __insieme_type_7* u0, __insieme_type_7* u1, int t, __insieme_type_10* indexmap, int* d){
	int i = 0;
	int j = 0;
	int k = 0;
	{
		for(int var_333 = 0; var_333 < ((d[((unsigned int)(2))])); var_333 += 1)  { {
			for(int var_331 = 0; var_331 < ((d[((unsigned int)(1))])); var_331 += 1)  { {
				for(int var_329 = 0; var_329 < ((d[((unsigned int)(0))])); var_329 += 1)  { _crmul((&(((((u1[((unsigned int)(var_333))])).data[((unsigned int)(var_331))])).data[((unsigned int)(var_329))])), (&(((((u0[((unsigned int)(var_333))])).data[((unsigned int)(var_331))])).data[((unsigned int)(var_329))])), ((int)((((*(&((*var_319).ex))).data[((unsigned int)((t*((((((indexmap[((unsigned int)(var_333))])).data[((unsigned int)(var_331))])).data[((unsigned int)(var_329))])))))]))))); };
				((i) = (0+(((int)(ceil((((double)((((d[((unsigned int)(0))]))-0)))/((double)(1))))))*1)));
			}; };
			((j) = (0+(((int)(ceil((((double)((((d[((unsigned int)(1))]))-0)))/((double)(1))))))*1)));
		}; };
		((k) = (0+(((int)(ceil((((double)((((d[((unsigned int)(2))]))-0)))/((double)(1))))))*1)));
	};
}
static void evolve_wrap(void* _closure, struct __insieme_globals* var_319, __insieme_type_7* u0, __insieme_type_7* u1, int t, __insieme_type_10* indexmap, int* d) { evolve(var_319, u0, u1, t, indexmap, d); }

// start code fragment :: Definition of __insieme_supp_16 ... type: ((ref<struct<real:real<8>,imag:real<8>>>,ref<int<4>>,ref<int<4>>,ref<struct<fftblock:int<4>,fftblockpad:int<4>,dims:vector<vector<int<4>,3>,3>,xstart:vector<int<4>,3>,ystart:vector<int<4>,3>,zstart:vector<int<4>,3>,xend:vector<int<4>,3>,yend:vector<int<4>,3>,zend:vector<int<4>,3>,ex:vector<real<8>,50689>,u:vector<struct<real:real<8>,imag:real<8>>,128>,sums:vector<struct<real:real<8>,imag:real<8>>,7>,niter:int<4>,u0:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad1:vector<struct<real:real<8>,imag:real<8>>,3>,u1:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad2:vector<struct<real:real<8>,imag:real<8>>,3>,u2:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad3:vector<struct<real:real<8>,imag:real<8>>,3>,indexmap:vector<vector<vector<int<4>,128>,128>,32>,tmp:vector<real<8>,32769>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,ref<array<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,1>>,ref<int<4>>)->unit) //
void __insieme_supp_16(struct dcomplex* var_346, int* var_347, int* var_348, struct __insieme_globals* var_349, __insieme_type_7* var_350, int* var_351){
	((*(&((*var_346).real))) = ((*(&((*var_346).real)))+(*(&(((((((var_350[((unsigned int)(((*var_348)-(((*(&((*var_349).zstart))).data[((unsigned int)(0))])))))])).data[((unsigned int)(((*var_347)-(((*(&((*var_349).ystart))).data[((unsigned int)(0))])))))])).data[((unsigned int)(((*var_351)-(((*(&((*var_349).xstart))).data[((unsigned int)(0))])))))])).real)))));
	((*(&((*var_346).imag))) = ((*(&((*var_346).imag)))+(*(&(((((((var_350[((unsigned int)(((*var_348)-(((*(&((*var_349).zstart))).data[((unsigned int)(0))])))))])).data[((unsigned int)(((*var_347)-(((*(&((*var_349).ystart))).data[((unsigned int)(0))])))))])).data[((unsigned int)(((*var_351)-(((*(&((*var_349).xstart))).data[((unsigned int)(0))])))))])).imag)))));
}
static void __insieme_supp_16_wrap(void* _closure, struct dcomplex* var_346, int* var_347, int* var_348, struct __insieme_globals* var_349, __insieme_type_7* var_350, int* var_351) { __insieme_supp_16(var_346, var_347, var_348, var_349, var_350, var_351); }

// start code fragment :: Definition of checksum ... type: ((ref<struct<fftblock:int<4>,fftblockpad:int<4>,dims:vector<vector<int<4>,3>,3>,xstart:vector<int<4>,3>,ystart:vector<int<4>,3>,zstart:vector<int<4>,3>,xend:vector<int<4>,3>,yend:vector<int<4>,3>,zend:vector<int<4>,3>,ex:vector<real<8>,50689>,u:vector<struct<real:real<8>,imag:real<8>>,128>,sums:vector<struct<real:real<8>,imag:real<8>>,7>,niter:int<4>,u0:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad1:vector<struct<real:real<8>,imag:real<8>>,3>,u1:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad2:vector<struct<real:real<8>,imag:real<8>>,3>,u2:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad3:vector<struct<real:real<8>,imag:real<8>>,3>,indexmap:vector<vector<vector<int<4>,128>,128>,32>,tmp:vector<real<8>,32769>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,int<4>,ref<array<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,1>>,ref<array<int<4>,1>>)->unit) //
void checksum(struct __insieme_globals* var_335, int i, __insieme_type_7* u1, int* d){
	int j = 0;
	int q = 0;
	int r = 0;
	int s = 0;
	int ierr = 0;
	struct dcomplex chk;
	struct dcomplex allchk;
	((*(&((chk).real))) = 0.0);
	((*(&((chk).imag))) = 0.0);
	{
		for(int var_363 = 1; var_363 < (1024+1); var_363 += 1) {
			((q) = ((var_363%128)+1));
			if((((q)>=(((*(&((*var_335).xstart))).data[((unsigned int)(0))])))&&((q)<=(((*(&((*var_335).xend))).data[((unsigned int)(0))]))))){
				((r) = (((3*var_363)%128)+1));
				if((((r)>=(((*(&((*var_335).ystart))).data[((unsigned int)(0))])))&&((r)<=(((*(&((*var_335).yend))).data[((unsigned int)(0))]))))){
					((s) = (((5*var_363)%32)+1));
					if((((s)>=(((*(&((*var_335).zstart))).data[((unsigned int)(0))])))&&((s)<=(((*(&((*var_335).zend))).data[((unsigned int)(0))]))))) { __insieme_supp_16(&chk, &r, &s, var_335, u1, &q); };
				};
			};
		};
		((j) = (1+(((int)(ceil((((double)(((1024+1)-1)))/((double)(1))))))*1)));
	};
	{
		((*(&((((*(&((*var_335).sums))).data[((unsigned int)(i))])).real))) = ((*(&((((*(&((*var_335).sums))).data[((unsigned int)(i))])).real)))+(*(&((chk).real)))));
		((*(&((((*(&((*var_335).sums))).data[((unsigned int)(i))])).imag))) = ((*(&((((*(&((*var_335).sums))).data[((unsigned int)(i))])).imag)))+(*(&((chk).imag)))));
	};
	{
		((*(&((((*(&((*var_335).sums))).data[((unsigned int)(i))])).real))) = ((*(&((((*(&((*var_335).sums))).data[((unsigned int)(i))])).real)))/((double)(524288))));
		((*(&((((*(&((*var_335).sums))).data[((unsigned int)(i))])).imag))) = ((*(&((((*(&((*var_335).sums))).data[((unsigned int)(i))])).imag)))/((double)(524288))));
		printf("T = %5d     Checksum = %22.12e %22.12e\n", i, (*(&((((*(&((*var_335).sums))).data[((unsigned int)(i))])).real))), (*(&((((*(&((*var_335).sums))).data[((unsigned int)(i))])).imag))));
	};
}
static void checksum_wrap(void* _closure, struct __insieme_globals* var_335, int i, __insieme_type_7* u1, int* d) { checksum(var_335, i, u1, d); }

// start code fragment :: vector_type_declaration of __insieme_type_17 <=> vector<real<8>,7> //
typedef struct ___insieme_type_17 { 
    double data[7];
} __insieme_type_17;

// A constructor initializing a vector of the type __insieme_type_17 uniformly
static inline __insieme_type_17 __insieme_type_17_init_uniform(double value) {
	__insieme_type_17 res;
	for (int i=0; i<7;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_18 <=> vector<real<8>,21> //
typedef struct ___insieme_type_18 { 
    double data[21];
} __insieme_type_18;

// A constructor initializing a vector of the type __insieme_type_18 uniformly
static inline __insieme_type_18 __insieme_type_18_init_uniform(double value) {
	__insieme_type_18 res;
	for (int i=0; i<21;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: Prototype for external function: fabs ... type: ((real<8>)->real<8>) //
double fabs(double);
static double fabs_wrap(void* _closure, double var_444) { return fabs(var_444); }

// start code fragment :: Definition of verify ... type: ((ref<struct<fftblock:int<4>,fftblockpad:int<4>,dims:vector<vector<int<4>,3>,3>,xstart:vector<int<4>,3>,ystart:vector<int<4>,3>,zstart:vector<int<4>,3>,xend:vector<int<4>,3>,yend:vector<int<4>,3>,zend:vector<int<4>,3>,ex:vector<real<8>,50689>,u:vector<struct<real:real<8>,imag:real<8>>,128>,sums:vector<struct<real:real<8>,imag:real<8>>,7>,niter:int<4>,u0:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad1:vector<struct<real:real<8>,imag:real<8>>,3>,u1:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad2:vector<struct<real:real<8>,imag:real<8>>,3>,u2:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad3:vector<struct<real:real<8>,imag:real<8>>,3>,indexmap:vector<vector<vector<int<4>,128>,128>,32>,tmp:vector<real<8>,32769>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,int<4>,int<4>,int<4>,int<4>,ref<array<int<4>,1>>,ref<array<char,1>>)->unit) //
void verify(struct __insieme_globals* var_367, int d1, int d2, int d3, int nt, int* verified, char* class){
	int ierr = 0;
	int size = 0;
	int i = 0;
	double err = 0.0;
	double epsilon = 0.0;
	__insieme_type_17 vdata_real_s = ((__insieme_type_17){{0.0, 5.546087004964e+02, 5.546385409189e+02, 5.546148406171e+02, 5.545423607415e+02, 5.544255039624e+02, 5.542683411902e+02}});
	__insieme_type_17 vdata_imag_s = ((__insieme_type_17){{0.0, 4.845363331978e+02, 4.865304269511e+02, 4.883910722336e+02, 4.901273169046e+02, 4.917475857993e+02, 4.932597244941e+02}});
	__insieme_type_17 vdata_real_w = ((__insieme_type_17){{0.0, 5.673612178944e+02, 5.631436885271e+02, 5.594024089970e+02, 5.560698047020e+02, 5.530898991250e+02, 5.504159734538e+02}});
	__insieme_type_17 vdata_imag_w = ((__insieme_type_17){{0.0, 5.293246849175e+02, 5.282149986629e+02, 5.270996558037e+02, 5.260027904925e+02, 5.249400845633e+02, 5.239212247086e+02}});
	__insieme_type_17 vdata_real_a = ((__insieme_type_17){{0.0, 5.046735008193e+02, 5.059412319734e+02, 5.069376896287e+02, 5.077892868474e+02, 5.085233095391e+02, 5.091487099959e+02}});
	__insieme_type_17 vdata_imag_a = ((__insieme_type_17){{0.0, 5.114047905510e+02, 5.098809666433e+02, 5.098144042213e+02, 5.101336130759e+02, 5.104914655194e+02, 5.107917842803e+02}});
	__insieme_type_18 vdata_real_b = ((__insieme_type_18){{0.0, 5.177643571579e+02, 5.154521291263e+02, 5.146409228649e+02, 5.142378756213e+02, 5.139626667737e+02, 5.137423460082e+02, 5.135547056878e+02, 5.133910925466e+02, 5.132470705390e+02, 5.131197729984e+02, 5.130070319283e+02, 5.129070537032e+02, 5.128182883502e+02, 5.127393733383e+02, 5.126691062020e+02, 5.126064276004e+02, 5.125504076570e+02, 5.125002331720e+02, 5.124551951846e+02, 5.124146770029e+02}});
	__insieme_type_18 vdata_imag_b = ((__insieme_type_18){{0.0, 5.077803458597e+02, 5.088249431599e+02, 5.096208912659e+02, 5.101023387619e+02, 5.103976610617e+02, 5.105948019802e+02, 5.107404165783e+02, 5.108576573661e+02, 5.109577278523e+02, 5.110460304483e+02, 5.111252433800e+02, 5.111968077718e+02, 5.112616233064e+02, 5.113203605551e+02, 5.113735928093e+02, 5.114218460548e+02, 5.114656139760e+02, 5.115053595966e+02, 5.115415130407e+02, 5.115744692211e+02}});
	__insieme_type_18 vdata_real_c = ((__insieme_type_18){{0.0, 5.195078707457e+02, 5.155422171134e+02, 5.144678022222e+02, 5.140150594328e+02, 5.137550426810e+02, 5.135811056728e+02, 5.134569343165e+02, 5.133651975661e+02, 5.132955192805e+02, 5.132410471738e+02, 5.131971141679e+02, 5.131605205716e+02, 5.131290734194e+02, 5.131012720314e+02, 5.130760908195e+02, 5.130528295923e+02, 5.130310107773e+02, 5.130103090133e+02, 5.129905029333e+02, 5.129714421109e+02}});
	__insieme_type_18 vdata_imag_c = ((__insieme_type_18){{0.0, 5.149019699238e+02, 5.127578201997e+02, 5.122251847514e+02, 5.121090289018e+02, 5.121143685824e+02, 5.121496764568e+02, 5.121870921893e+02, 5.122193250322e+02, 5.122454735794e+02, 5.122663649603e+02, 5.122830879827e+02, 5.122965869718e+02, 5.123075927445e+02, 5.123166486553e+02, 5.123241541685e+02, 5.123304037599e+02, 5.123356167976e+02, 5.123399592211e+02, 5.123435588985e+02, 5.123465164008e+02}});
	((epsilon) = 1.0e-12);
	(((verified[0])) = 1);
	(((class[0])) = 'U');
	if(((((d1==64)&&(d2==64))&&(d3==64))&&(nt==6))){
		(((class[0])) = 'S');
		{
			for(int var_390 = 1; var_390 < (nt+1); var_390 += 1) {
				((err) = (((*(&((((*(&((*var_367).sums))).data[((unsigned int)(var_390))])).real)))-(((vdata_real_s).data[((unsigned int)(var_390))])))/(((vdata_real_s).data[((unsigned int)(var_390))]))));
				if((fabs((err))>(epsilon))){
					(((verified[0])) = 0);
					break;
				};((err) = (((*(&((((*(&((*var_367).sums))).data[((unsigned int)(var_390))])).imag)))-(((vdata_imag_s).data[((unsigned int)(var_390))])))/(((vdata_imag_s).data[((unsigned int)(var_390))]))));
				if((fabs((err))>(epsilon))){
					(((verified[0])) = 0);
					break;
				};
			};
			((i) = (1+(((int)(ceil((((double)(((nt+1)-1)))/((double)(1))))))*1)));
		};
	} else  { if(((((d1==128)&&(d2==128))&&(d3==32))&&(nt==6))){
		(((class[0])) = 'W');
		{
			for(int var_398 = 1; var_398 < (nt+1); var_398 += 1) {
				((err) = (((*(&((((*(&((*var_367).sums))).data[((unsigned int)(var_398))])).real)))-(((vdata_real_w).data[((unsigned int)(var_398))])))/(((vdata_real_w).data[((unsigned int)(var_398))]))));
				if((fabs((err))>(epsilon))){
					(((verified[0])) = 0);
					break;
				};((err) = (((*(&((((*(&((*var_367).sums))).data[((unsigned int)(var_398))])).imag)))-(((vdata_imag_w).data[((unsigned int)(var_398))])))/(((vdata_imag_w).data[((unsigned int)(var_398))]))));
				if((fabs((err))>(epsilon))){
					(((verified[0])) = 0);
					break;
				};
			};
			((i) = (1+(((int)(ceil((((double)(((nt+1)-1)))/((double)(1))))))*1)));
		};
	} else  { if(((((d1==256)&&(d2==256))&&(d3==128))&&(nt==6))){
		(((class[0])) = 'A');
		{
			for(int var_406 = 1; var_406 < (nt+1); var_406 += 1) {
				((err) = (((*(&((((*(&((*var_367).sums))).data[((unsigned int)(var_406))])).real)))-(((vdata_real_a).data[((unsigned int)(var_406))])))/(((vdata_real_a).data[((unsigned int)(var_406))]))));
				if((fabs((err))>(epsilon))){
					(((verified[0])) = 0);
					break;
				};((err) = (((*(&((((*(&((*var_367).sums))).data[((unsigned int)(var_406))])).imag)))-(((vdata_imag_a).data[((unsigned int)(var_406))])))/(((vdata_imag_a).data[((unsigned int)(var_406))]))));
				if((fabs((err))>(epsilon))){
					(((verified[0])) = 0);
					break;
				};
			};
			((i) = (1+(((int)(ceil((((double)(((nt+1)-1)))/((double)(1))))))*1)));
		};
	} else  { if(((((d1==512)&&(d2==256))&&(d3==256))&&(nt==20))){
		(((class[0])) = 'B');
		{
			for(int var_414 = 1; var_414 < (nt+1); var_414 += 1) {
				((err) = (((*(&((((*(&((*var_367).sums))).data[((unsigned int)(var_414))])).real)))-(((vdata_real_b).data[((unsigned int)(var_414))])))/(((vdata_real_b).data[((unsigned int)(var_414))]))));
				if((fabs((err))>(epsilon))){
					(((verified[0])) = 0);
					break;
				};((err) = (((*(&((((*(&((*var_367).sums))).data[((unsigned int)(var_414))])).imag)))-(((vdata_imag_b).data[((unsigned int)(var_414))])))/(((vdata_imag_b).data[((unsigned int)(var_414))]))));
				if((fabs((err))>(epsilon))){
					(((verified[0])) = 0);
					break;
				};
			};
			((i) = (1+(((int)(ceil((((double)(((nt+1)-1)))/((double)(1))))))*1)));
		};
	} else  { if(((((d1==512)&&(d2==512))&&(d3==512))&&(nt==20))){
		(((class[0])) = 'C');
		{
			for(int var_422 = 1; var_422 < (nt+1); var_422 += 1) {
				((err) = (((*(&((((*(&((*var_367).sums))).data[((unsigned int)(var_422))])).real)))-(((vdata_real_c).data[((unsigned int)(var_422))])))/(((vdata_real_c).data[((unsigned int)(var_422))]))));
				if((fabs((err))>(epsilon))){
					(((verified[0])) = 0);
					break;
				};((err) = (((*(&((((*(&((*var_367).sums))).data[((unsigned int)(var_422))])).imag)))-(((vdata_imag_c).data[((unsigned int)(var_422))])))/(((vdata_imag_c).data[((unsigned int)(var_422))]))));
				if((fabs((err))>(epsilon))){
					(((verified[0])) = 0);
					break;
				};
			};
			((i) = (1+(((int)(ceil((((double)(((nt+1)-1)))/((double)(1))))))*1)));
		};
	}; }; }; }; };
	if((((int)(((class[0]))))!=85)) { printf("Result verification successful\n", 0); } else  { printf("Result verification failed\n", 0); };
	printf("class = %1c\n", ((int)(((class[0])))));
}
static void verify_wrap(void* _closure, struct __insieme_globals* var_367, int d1, int d2, int d3, int nt, int* verified, char* class) { verify(var_367, d1, d2, d3, nt, verified, class); }

// start code fragment :: Definition of timer_read ... type: ((ref<struct<fftblock:int<4>,fftblockpad:int<4>,dims:vector<vector<int<4>,3>,3>,xstart:vector<int<4>,3>,ystart:vector<int<4>,3>,zstart:vector<int<4>,3>,xend:vector<int<4>,3>,yend:vector<int<4>,3>,zend:vector<int<4>,3>,ex:vector<real<8>,50689>,u:vector<struct<real:real<8>,imag:real<8>>,128>,sums:vector<struct<real:real<8>,imag:real<8>>,7>,niter:int<4>,u0:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad1:vector<struct<real:real<8>,imag:real<8>>,3>,u1:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad2:vector<struct<real:real<8>,imag:real<8>>,3>,u2:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad3:vector<struct<real:real<8>,imag:real<8>>,3>,indexmap:vector<vector<vector<int<4>,128>,128>,32>,tmp:vector<real<8>,32769>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,int<4>)->real<8>) //
double timer_read(struct __insieme_globals* var_36, int n) { return (((*(&((*var_36).elapsed))).data[((unsigned int)(n))])); }
static double timer_read_wrap(void* _closure, struct __insieme_globals* var_36, int n) { return timer_read(var_36, n); }

// start code fragment :: Prototype for external function: log ... type: ((real<8>)->real<8>) //
double log(double);
static double log_wrap(void* _closure, double var_445) { return log(var_445); }

// start code fragment :: Definition of c_print_results ... type: ((ref<array<char,1>>,char,int<4>,int<4>,int<4>,int<4>,int<4>,real<8>,real<8>,ref<array<char,1>>,int<4>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>)->unit) //
void c_print_results(char* name, char class, int n1, int n2, int n3, int niter, int nthreads, double t, double mops, char* optype, int passed_verification, char* npbversion, char* compiletime, char* cc, char* clink, char* c_lib, char* c_inc, char* cflags, char* clinkflags, char* rand){
	char* evalue = "1000";
	printf("\n\n %s Benchmark Completed\n", name);
	printf(" Class           =                        %c\n", ((int)(class)));
	if(((n2==0)&&(n3==0))) { printf(" Size            =             %12d\n", n1); } else  { printf(" Size            =              %3dx%3dx%3d\n", n1, n2, n3); };
	printf(" Iterations      =             %12d\n", niter);
	printf(" Threads         =             %12d\n", nthreads);
	printf(" Time in seconds =             %12.2f\n", 0.0);
	printf(" Mop/s total     =             %12.2f\n", 0.0);
	printf(" Operation type  = %24s\n", optype);
	if((passed_verification!=0)) { printf(" Verification    =               SUCCESSFUL\n", 0); } else  { printf(" Verification    =             UNSUCCESSFUL\n", 0); };
	printf(" Version         =             %12s\n", npbversion);
	printf(" Compile date    =             %12s\n", compiletime);
	printf("\n Compile options:\n", 0);
	printf("    CC           = %s\n", cc);
	printf("    CLINK        = %s\n", clink);
	printf("    C_LIB        = %s\n", c_lib);
	printf("    C_INC        = %s\n", c_inc);
	printf("    CFLAGS       = %s\n", cflags);
	printf("    CLINKFLAGS   = %s\n", clinkflags);
	printf("    RAND         = %s\n", rand);
}
static void c_print_results_wrap(void* _closure, char* name, char class, int n1, int n2, int n3, int niter, int nthreads, double t, double mops, char* optype, int passed_verification, char* npbversion, char* compiletime, char* cc, char* clink, char* c_lib, char* c_inc, char* cflags, char* clinkflags, char* rand) { c_print_results(name, class, n1, n2, n3, niter, nthreads, t, mops, optype, passed_verification, npbversion, compiletime, cc, clink, c_lib, c_inc, cflags, clinkflags, rand); }

// start code fragment :: vector_type_declaration of __insieme_type_19 <=> vector<ref<array<char,1>>,7> //
typedef struct ___insieme_type_19 { 
    char* data[7];
} __insieme_type_19;

// A constructor initializing a vector of the type __insieme_type_19 uniformly
static inline __insieme_type_19 __insieme_type_19_init_uniform(char* value) {
	__insieme_type_19 res;
	for (int i=0; i<7;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_20 <=> vector<char,17> //
typedef struct ___insieme_type_20 { 
    char data[17];
} __insieme_type_20;

// A constructor initializing a vector of the type __insieme_type_20 uniformly
static inline __insieme_type_20 __insieme_type_20_init_uniform(char value) {
	__insieme_type_20 res;
	for (int i=0; i<17;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: Definition of print_timers ... type: ((ref<struct<fftblock:int<4>,fftblockpad:int<4>,dims:vector<vector<int<4>,3>,3>,xstart:vector<int<4>,3>,ystart:vector<int<4>,3>,zstart:vector<int<4>,3>,xend:vector<int<4>,3>,yend:vector<int<4>,3>,zend:vector<int<4>,3>,ex:vector<real<8>,50689>,u:vector<struct<real:real<8>,imag:real<8>>,128>,sums:vector<struct<real:real<8>,imag:real<8>>,7>,niter:int<4>,u0:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad1:vector<struct<real:real<8>,imag:real<8>>,3>,u1:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad2:vector<struct<real:real<8>,imag:real<8>>,3>,u2:vector<vector<vector<struct<real:real<8>,imag:real<8>>,128>,128>,32>,pad3:vector<struct<real:real<8>,imag:real<8>>,3>,indexmap:vector<vector<vector<int<4>,128>,128>,32>,tmp:vector<real<8>,32769>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>)->unit) //
void print_timers(struct __insieme_globals* var_430){
	int i = 0;
	__insieme_type_19 tstrings = ((__insieme_type_19){{((((__insieme_type_20){{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 't', 'o', 't', 'a', 'l', ' ', '\0'}})).data), ((((__insieme_type_20){{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 's', 'e', 't', 'u', 'p', ' ', '\0'}})).data), ((((__insieme_type_20){{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'f', 'f', 't', ' ', '\0'}})).data), ((((__insieme_type_20){{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'e', 'v', 'o', 'l', 'v', 'e', ' ', '\0'}})).data), ((((__insieme_type_20){{' ', ' ', ' ', ' ', ' ', ' ', ' ', 'c', 'h', 'e', 'c', 'k', 's', 'u', 'm', ' ', '\0'}})).data), ((((__insieme_type_20){{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'f', 'f', 't', 'l', 'o', 'w', ' ', '\0'}})).data), ((((__insieme_type_20){{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'f', 'f', 't', 'c', 'o', 'p', 'y', ' ', '\0'}})).data)}});
	{
		for(int var_434 = 0; var_434 < 7; var_434 += 1)  { if((timer_read(var_430, var_434)!=0.0)) { printf("timer %2d(%16s( :%10.6f\n", var_434, (((tstrings).data[((unsigned int)(var_434))])), timer_read(var_430, var_434)); }; };
		((i) = (0+(((int)(ceil((((double)((7-0)))/((double)(1))))))*1)));
	};
}
static void print_timers_wrap(void* _closure, struct __insieme_globals* var_430) { print_timers(var_430); }

// start code fragment :: Definition of main ... type: ((int<4>,ref<array<ref<array<char,1>>,1>>)->int<4>) //
int main(int argc, char** argv){
	struct __insieme_globals* var_1 = malloc(sizeof(struct __insieme_globals));
	((*(&((*var_1).fftblock))) = 0);
	((*(&((*var_1).fftblockpad))) = 0);
	((*(&((*var_1).niter))) = 0);
	((*(&((*var_1).sec))) = (((int)(0))-1));
	int i = 0;
	int ierr = 0;
	int iter = 0;
	int nthreads = 1;
	double total_time = 0.0;
	double mflops = 0.0;
	int verified = 0;
	char class = '\0';
	{
		for(int var_92 = 0; var_92 < 7; var_92 += 1)  { timer_clear(var_1, var_92); };
		((i) = (0+(((int)(ceil((((double)((7-0)))/((double)(1))))))*1)));
	};
	setup(var_1);
	{
		compute_indexmap(var_1, (((__insieme_type_10*){(*(&((*var_1).indexmap))).data})), (((int*){(((*(&((*var_1).dims))).data[((unsigned int)(2))])).data})));
		{
			compute_initial_conditions(var_1, (((__insieme_type_7*){(*(&((*var_1).u1))).data})), (((int*){(((*(&((*var_1).dims))).data[((unsigned int)(0))])).data})));
			fft_init(var_1, (((((*(&((*var_1).dims))).data[((unsigned int)(0))])).data[((unsigned int)(0))])));
		};
		fft(var_1, 1, (((__insieme_type_7*){(*(&((*var_1).u1))).data})), (((__insieme_type_7*){(*(&((*var_1).u0))).data})));
	};
	{
		for(int var_318 = 0; var_318 < 7; var_318 += 1)  { timer_clear(var_1, var_318); };
		((i) = (0+(((int)(ceil((((double)((7-0)))/((double)(1))))))*1)));
	};
	timer_start(var_1, 0);
	if((0==1)) { timer_start(var_1, 1); };
	{
		compute_indexmap(var_1, (((__insieme_type_10*){(*(&((*var_1).indexmap))).data})), (((int*){(((*(&((*var_1).dims))).data[((unsigned int)(2))])).data})));
		{
			compute_initial_conditions(var_1, (((__insieme_type_7*){(*(&((*var_1).u1))).data})), (((int*){(((*(&((*var_1).dims))).data[((unsigned int)(0))])).data})));
			fft_init(var_1, (((((*(&((*var_1).dims))).data[((unsigned int)(0))])).data[((unsigned int)(0))])));
		};
		if((0==1)) { timer_stop(var_1, 1); };
		if((0==1)) { timer_start(var_1, 2); };
		fft(var_1, 1, (((__insieme_type_7*){(*(&((*var_1).u1))).data})), (((__insieme_type_7*){(*(&((*var_1).u0))).data})));
		if((0==1)) { timer_stop(var_1, 2); };
		{
			for(int var_366 = 1; var_366 < ((*(&((*var_1).niter)))+1); var_366 += 1) {
				if((0==1)) { timer_start(var_1, 3); };
				evolve(var_1, (((__insieme_type_7*){(*(&((*var_1).u0))).data})), (((__insieme_type_7*){(*(&((*var_1).u1))).data})), var_366, (((__insieme_type_10*){(*(&((*var_1).indexmap))).data})), (((int*){(((*(&((*var_1).dims))).data[((unsigned int)(0))])).data})));
				if((0==1)) { timer_stop(var_1, 3); };
				if((0==1)) { timer_start(var_1, 2); };
				fft(var_1, (((int)(0))-1), (((__insieme_type_7*){(*(&((*var_1).u1))).data})), (((__insieme_type_7*){(*(&((*var_1).u2))).data})));
				if((0==1)) { timer_stop(var_1, 2); };
				if((0==1)) { timer_start(var_1, 4); };
				checksum(var_1, var_366, (((__insieme_type_7*){(*(&((*var_1).u2))).data})), (((int*){(((*(&((*var_1).dims))).data[((unsigned int)(0))])).data})));
				if((0==1)) { timer_stop(var_1, 4); };
			};
			((iter) = (1+(((int)(ceil((((double)((((*(&((*var_1).niter)))+1)-1)))/((double)(1))))))*1)));
		};
		verify(var_1, 128, 128, 32, (*(&((*var_1).niter))), (&verified), (&class));
	};
	timer_stop(var_1, 0);
	((total_time) = timer_read(var_1, 0));
	if(((total_time)!=0.0)) { ((mflops) = (((1.0e-6*((double)(524288)))*((14.8157+(7.19641*log(((double)(524288)))))+((5.23518+(7.21113*log(((double)(524288)))))*((double)((*(&((*var_1).niter))))))))/(total_time))); } else  { ((mflops) = 0.0); };
	c_print_results("FT", (class), 128, 128, 32, (*(&((*var_1).niter))), (nthreads), (total_time), (mflops), "          floating point", (verified), "2.3", "02 Dec 2010", "cc", "cc", "-lm", "-I../common", "-O3 ", "-lm", "randdp");
	if((0==1)) { print_timers(var_1); };
}
static int main_wrap(void* _closure, int argc, char** argv) { return main(argc, argv); }
