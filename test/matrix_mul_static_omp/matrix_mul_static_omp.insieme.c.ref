// --- Generated Inspire Code ---
#include <alloca.h>
#include <stddef.h>
#include <runtime.h>
#define bool int
#define true 1
#define false 0
#define null 0

// start code fragment :: vector_type_declaration of __insieme_type_2 <=> vector<real<8>,1000> //
typedef struct ___insieme_type_2 { 
    double data[1000];
} __insieme_type_2;

// A constructor initializing a vector of the type __insieme_type_2 uniformly
static inline __insieme_type_2 __insieme_type_2_init_uniform(double value) {
	__insieme_type_2 res;
	for (int i=0; i<1000;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_1 <=> vector<vector<real<8>,1000>,1000> //
typedef struct ___insieme_type_1 { 
    __insieme_type_2 data[1000];
} __insieme_type_1;

// A constructor initializing a vector of the type __insieme_type_1 uniformly
static inline __insieme_type_1 __insieme_type_1_init_uniform(__insieme_type_2 value) {
	__insieme_type_1 res;
	for (int i=0; i<1000;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: type_declaration___insieme_globals //
struct __insieme_globals { 
    __insieme_type_1 A;
    __insieme_type_1 B;
    __insieme_type_1 C;
};

// start code fragment :: global data //
struct __insieme_globals __GLOBAL__;

// start code fragment :: struct for job __insieme_job_3 //
struct __insieme_job_3 { 
	unsigned structSize;
	unsigned min, max;
	void (*fun)(isbr_JobArgs*);
	// ---- additional captured variables -----
};

// start code fragment :: Definitions for function type: __insieme_funType_4 //
//
// -------------------- Begin of constructs for function type (()->unit)---------------------
// Base-struct of describing closures of type __insieme_funType_4 <-> (()->unit)
typedef struct ___insieme_funType_4 { 
    void(*call)(void*);
} __insieme_funType_4;

// Type safe function for invoking closures of type __insieme_funType_4
static inline void __insieme_funType_4_call(__insieme_funType_4* closure) {  closure->call(closure); }

// A constructor for closures wrapping pure functions of type (()->unit)
static inline __insieme_funType_4* __insieme_funType_4_ctr(__insieme_funType_4* target, void(*call)(void*)) {
	*target = (__insieme_funType_4){call};
	return target;
}
// ----------------------- end of constructs for function (()->unit)-----------------------

// start code fragment :: Definition of __insieme_closure_5 ... type: (()->unit) //
// -- Begin - Closure Constructs ------------------------------------------------------------
// struct definition a closure of type (()->unit)
typedef struct ___insieme_closure_5 {
    void(*call)(void*);
    __insieme_funType_4* nested;
} __insieme_closure_5;

static inline void __insieme_closure_5_bind(__insieme_closure_5* closure) {  closure->nested->call(closure->nested); }

static inline __insieme_closure_5* __insieme_closure_5_ctr(__insieme_closure_5* closure, __insieme_funType_4* nested) {
    *closure = (__insieme_closure_5){&__insieme_closure_5_bind, nested};
    return closure;
}
// -- End - Closure Constructs --------------------------------------------------------------

// start code fragment :: capture-struct for pfor-body __insieme_pfor_body_7_fun //
struct __insieme_pfor_body_7_fun_capture {
};

// start code fragment :: Definition of __insieme_supp_8 ... type: ((int<4>)->unit) //
void __insieme_supp_8(int var_40) { for(int var_4 = 0; var_4 < 1000; var_4 += 1)  { ((((((*(&((__GLOBAL__).A))).data[((unsigned int)(var_40))])).data[((unsigned int)(var_4))])) = ((double)((var_40*var_4)))); }; }
static void __insieme_supp_8_wrap(void* _closure, int var_40) { __insieme_supp_8(var_40); }

// start code fragment :: function for pfor-body __insieme_pfor_body_7_fun //
void __insieme_pfor_body_7_fun(const isbr_PForRange range) {
	// ----- captured variables -----
	
	// ----- process iterations -----
	for(int __it = range.start; __it<range.end; __it+=range.step) {
		__insieme_supp_8(__it);
	}
	
}

// start code fragment :: capture-struct for pfor-body __insieme_pfor_body_9_fun //
struct __insieme_pfor_body_9_fun_capture {
};

// start code fragment :: Definition of __insieme_supp_10 ... type: ((int<4>)->unit) //
void __insieme_supp_10(int var_44) { for(int var_12 = 0; var_12 < 1000; var_12 += 1)  { ((((((*(&((__GLOBAL__).B))).data[((unsigned int)(var_44))])).data[((unsigned int)(var_12))])) = ((double)((((var_44==var_12))?(1):(0))))); }; }
static void __insieme_supp_10_wrap(void* _closure, int var_44) { __insieme_supp_10(var_44); }

// start code fragment :: function for pfor-body __insieme_pfor_body_9_fun //
void __insieme_pfor_body_9_fun(const isbr_PForRange range) {
	// ----- captured variables -----
	
	// ----- process iterations -----
	for(int __it = range.start; __it<range.end; __it+=range.step) {
		__insieme_supp_10(__it);
	}
	
}

// start code fragment :: capture-struct for pfor-body __insieme_pfor_body_11_fun //
struct __insieme_pfor_body_11_fun_capture {
};

// start code fragment :: Definition of __insieme_supp_12 ... type: ((int<4>)->unit) //
void __insieme_supp_12(int var_48) { for(int var_19 = 0; var_19 < 1000; var_19 += 1) {
	double sum = ((double)(0));
	for(int var_18 = 0; var_18 < 1000; var_18 += 1)  { ((sum) = ((sum)+((((((*(&((__GLOBAL__).A))).data[((unsigned int)(var_48))])).data[((unsigned int)(var_18))]))*(((((*(&((__GLOBAL__).B))).data[((unsigned int)(var_18))])).data[((unsigned int)(var_19))]))))); };
	((((((*(&((__GLOBAL__).C))).data[((unsigned int)(var_48))])).data[((unsigned int)(var_19))])) = (sum));
}; }
static void __insieme_supp_12_wrap(void* _closure, int var_48) { __insieme_supp_12(var_48); }

// start code fragment :: function for pfor-body __insieme_pfor_body_11_fun //
void __insieme_pfor_body_11_fun(const isbr_PForRange range) {
	// ----- captured variables -----
	
	// ----- process iterations -----
	for(int __it = range.start; __it<range.end; __it+=range.step) {
		__insieme_supp_12(__it);
	}
	
}

// start code fragment :: Definition of __insieme_supp_6 ... type: (()->unit) //
void __insieme_supp_6(){
	{
		isbr_pfor(isbr_getThreadGroup(0),(isbr_PForRange){0, 1000, 1, 0},&__insieme_pfor_body_7_fun);
		isbr_barrier(isbr_getThreadGroup(0));
	};
	{
		isbr_pfor(isbr_getThreadGroup(0),(isbr_PForRange){0, 1000, 1, 0},&__insieme_pfor_body_9_fun);
		isbr_barrier(isbr_getThreadGroup(0));
	};
	{
		isbr_pfor(isbr_getThreadGroup(0),(isbr_PForRange){0, 1000, 1, 0},&__insieme_pfor_body_11_fun);
		isbr_barrier(isbr_getThreadGroup(0));
	};
}
static void __insieme_supp_6_wrap(void* _closure) { __insieme_supp_6(); }

// start code fragment :: function for job __insieme_job_3 //
void fun__insieme_job_3(isbr_JobArgs* args) {
	// ----------- Unpacking local scope variables ----------
	// ---------- Unpacking auto-captured variables ---------
	// ------------------ Processing Guards -----------------
	// ------------------ Default processing -----------------
	__insieme_funType_4_call((__insieme_funType_4*)__insieme_closure_5_ctr((__insieme_closure_5*)alloca(sizeof(__insieme_closure_5)),(__insieme_funType_4*)__insieme_funType_4_ctr((__insieme_funType_4*)alloca(sizeof(__insieme_funType_4)),&__insieme_supp_6_wrap)));
}

// start code fragment :: Prototype for external function: printf ... type: ((ref<array<char,1>>,var_list)->int<4>) //
int printf(char*, ...);

// start code fragment :: vector_type_declaration of __insieme_type_13 <=> vector<char,3> //
typedef struct ___insieme_type_13 { 
    char data[3];
} __insieme_type_13;

// A constructor initializing a vector of the type __insieme_type_13 uniformly
static inline __insieme_type_13 __insieme_type_13_init_uniform(char value) {
	__insieme_type_13 res;
	for (int i=0; i<3;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_14 <=> vector<char,4> //
typedef struct ___insieme_type_14 { 
    char data[4];
} __insieme_type_14;

// A constructor initializing a vector of the type __insieme_type_14 uniformly
static inline __insieme_type_14 __insieme_type_14_init_uniform(char value) {
	__insieme_type_14 res;
	for (int i=0; i<4;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: Definition of main ... type: (()->int<4>) //
int main(){
	;
	isbr_merge(isbr_parallel(memcpy(malloc(sizeof(struct __insieme_job_3)),&((struct __insieme_job_3){sizeof(struct __insieme_job_3),1,isbr_getMaxThreads(),&fun__insieme_job_3}),sizeof(struct __insieme_job_3))));
	int success = 1;
	for(int var_33 = 0; var_33 < 1000; var_33 += 1) {
		for(int var_26 = 0; var_26 < (((1000<1000))?(1000):(1000)); var_26 += 1)  { if(((((((*(&((__GLOBAL__).A))).data[((unsigned int)(var_33))])).data[((unsigned int)(var_26))]))!=(((((*(&((__GLOBAL__).C))).data[((unsigned int)(var_33))])).data[((unsigned int)(var_26))])))) { ((success) = 0); }; };
		for(int var_32 = (((1000<1000))?(1000):(1000)); var_32 < (((1000>1000))?(1000):(1000)); var_32 += 1)  { if(((((((*(&((__GLOBAL__).C))).data[((unsigned int)(var_33))])).data[((unsigned int)(var_32))]))!=((double)(0)))) { ((success) = 0); }; };
	};
	printf("Verification: %s\n", ((((success)!=0))?(((((__insieme_type_13){{'O', 'K', '\0'}})).data)):(((((__insieme_type_14){{'E', 'R', 'R', '\0'}})).data))));
}
static int main_wrap(void* _closure) { return main(); }
