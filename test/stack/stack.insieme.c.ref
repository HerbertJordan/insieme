// --- Generated Inspire Code ---
#include <alloca.h>
#include <stddef.h>
#include <runtime.h>
#define bool int
#define true 1
#define false 0
#define null 0

// start code fragment :: type_declaration_stack //
struct stack { 
    struct item* top;
};

// start code fragment :: Definition of newStack ... type: (()->ref<array<struct<top:ref<array<rec 'elem.{'elem=struct<value:int<4>,next:ref<array<'elem,1>>>},1>>>,1>>) //
struct stack* newStack(){
	struct stack* res = (((struct stack*){malloc(sizeof(struct stack*)*(sizeof(struct stack)/sizeof(struct stack)))}));
	((*(&((((res)[0])).top))) = 0);
	return (res);
}
static struct stack* newStack_wrap(void* _closure) { return newStack(); }

// start code fragment :: Prototype for external function: printf ... type: ((ref<array<char,1>>,var_list)->int<4>) //
int printf(char*, ...);

// start code fragment :: Prototype of struct item //
struct item;

// start code fragment :: type_declaration_item //
struct item { 
    int value;
    struct item* next;
};

// start code fragment :: Definition of push ... type: ((ref<array<struct<top:ref<array<rec 'elem.{'elem=struct<value:int<4>,next:ref<array<'elem,1>>>},1>>>,1>>,int<4>)->unit) //
void push(struct stack* stack, int value){
	struct item* element = (((struct item*){malloc(sizeof(struct item*)*(sizeof(struct item)/sizeof(struct item)))}));
	((*(&((((element)[0])).value))) = value);
	((*(&((((element)[0])).next))) = (*(&(((stack[0])).top))));
	((*(&(((stack[0])).top))) = (element));
}
static void push_wrap(void* _closure, struct stack* stack, int value) { push(stack, value); }

// start code fragment :: Prototype for external function: ceil ... type: ((real<8>)->real<8>) //
double ceil(double);
static double ceil_wrap(void* _closure, double var_22) { return ceil(var_22); }

// start code fragment :: Definition of pop ... type: ((ref<array<struct<top:ref<array<rec 'elem.{'elem=struct<value:int<4>,next:ref<array<'elem,1>>>},1>>>,1>>)->int<4>) //
int pop(struct stack* stack){
	if((!(!((*(&(((stack[0])).top)))==0)))) { return (((int)(0))-1); };
	struct item* tmp = (*(&(((stack[0])).top)));
	int res = (*(&((((tmp)[0])).value)));
	((*(&(((stack[0])).top))) = (*(&((((tmp)[0])).next))));
	free((tmp));
	return (res);
}
static int pop_wrap(void* _closure, struct stack* stack) { return pop(stack); }

// start code fragment :: Definition of dumpStack ... type: ((ref<array<struct<top:ref<array<rec 'elem.{'elem=struct<value:int<4>,next:ref<array<'elem,1>>>},1>>>,1>>)->unit) //
void dumpStack(struct stack* stack){
	struct stack* var_5 = stack;
	{
		while((!((*(&((((var_5)[0])).top)))==0))) {
			struct item* tmp = (*(&((((var_5)[0])).top)));
			((*(&((((var_5)[0])).top))) = (*(&((((tmp)[0])).next))));
			free((tmp));
		};
		;
	};
}
static void dumpStack_wrap(void* _closure, struct stack* stack) { dumpStack(stack); }

// start code fragment :: Definition of main ... type: (()->int<4>) //
int main(){
	int i = 0;
	struct stack* stack;
	((stack) = newStack());
	{
		for(int var_18 = 0; var_18 < 10; var_18 += 1) {
			printf("Pushing %d\n", var_18);
			push((stack), var_18);
		};
		((i) = (0+(((int)(ceil((((double)((10-0)))/((double)(1))))))*1)));
	};
	{
		for(int var_20 = 0; var_20 < 5; var_20 += 1)  { printf("Poping  %d\n", pop((stack))); };
		((i) = (0+(((int)(ceil((((double)((5-0)))/((double)(1))))))*1)));
	};
	dumpStack((stack));
	return 0;
}
static int main_wrap(void* _closure) { return main(); }
