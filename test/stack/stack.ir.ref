// -------------- Pretty Print Inspire --------------
// Inspire Program 
//  Entry Point: 
fun(){
        decl ref<int<4>> v1 =  var(0);
        decl ref<array<struct<top:array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>,1>> v2 =  var(undefined(type<array<struct<top:array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>,1>>));
        v2 := fun(){
            decl ref<array<struct<top:array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>,1>> v3 =  new(array.create.1D(type<struct<top:array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>>, sizeof(type<struct<top:array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>>)/sizeof(type<struct<top:array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>>)));
            composite.ref.elem(array.ref.elem.1D(v3, 0), top, type<array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>) := get.null(type<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>}>);
            return v3;
        }();
        {
            for(decl ref<int<4>> v9 =  var(0) .. 10 : 1) {
                printf(string.as.char.pointer("Pushing %d\n"), varlist.pack((v9)));
                fun(ref<array<struct<top:array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>,1>> v5, int<4> v6){
                    decl ref<array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>> v7 =  new(array.create.1D(type<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>}>, sizeof(type<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>}>)/sizeof(type<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>}>)));
                    composite.ref.elem(array.ref.elem.1D(v7, 0), value, type<int<4>>) := v6;
                    composite.ref.elem(array.ref.elem.1D(v7, 0), next, type<array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>) := composite.ref.elem(array.ref.elem.1D(v5, 0), top, type<array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>);
                    composite.ref.elem(array.ref.elem.1D(v5, 0), top, type<array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>) := v7;
                }(v2, v9);
            };
            v1 := 0+ceil(10-0/1)*1;
        };
        {
            for(decl ref<int<4>> v14 =  var(0) .. 5 : 1) {
                printf(string.as.char.pointer("Poping  %d\n"), varlist.pack((fun(ref<array<struct<top:array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>,1>> v10){
                    if(!!is.null(composite.ref.elem(array.ref.elem.1D(v10, 0), top, type<array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>))) {
                        return 0-1;
                    } else { };
                    decl ref<array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>> v11 = composite.ref.elem(array.ref.elem.1D(v10, 0), top, type<array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>);
                    decl ref<int<4>> v12 = composite.ref.elem(array.ref.elem.1D(v11, 0), value, type<int<4>>);
                    composite.ref.elem(array.ref.elem.1D(v10, 0), top, type<array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>) := composite.ref.elem(array.ref.elem.1D(v11, 0), next, type<array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>);
                     del(v11);
                    return v12;
                }(v2))));
            };
            v1 := 0+ceil(5-0/1)*1;
        };
        fun(ref<array<struct<top:array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>,1>> v15){
            decl ref<ref<array<struct<top:array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>,1>>> v17 =  var(v15);
            {
                while(!is.null(composite.ref.elem(array.ref.elem.1D(v17, 0), top, type<array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>))) {
                    decl ref<array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>> v16 = composite.ref.elem(array.ref.elem.1D(v17, 0), top, type<array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>);
                    composite.ref.elem(array.ref.elem.1D(v17, 0), top, type<array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>) := composite.ref.elem(array.ref.elem.1D(v16, 0), next, type<array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>);
                     del(v16);
                };
                 del(v17);
            };
        }(v2);
        return 0;
    }




// --------- Pretty Print Inspire - Detail ----------
// Inspire Program 
//  Entry Point: 
fun(){
        decl ref<int<4>> v1 = ( var(0));
        decl ref<array<struct<top:array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>,1>> v2 = ( var(undefined(type<array<struct<top:array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>,1>>)));
        (v2 := ( *fun(){
            decl ref<array<struct<top:array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>,1>> v3 = ( new(array.create.1D(type<struct<top:array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>>, (sizeof(type<struct<top:array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>>)/sizeof(type<struct<top:array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>>)))));
            (composite.ref.elem(array.ref.elem.1D(v3, 0), top, type<array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>) := get.null(type<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>}>));
            return v3;
        }()));
        {
            for(decl ref<int<4>> v9 = ( var(0)) .. 10 : 1) {
                printf(string.as.char.pointer("Pushing %d\n"), varlist.pack((( *v9))));
                fun(ref<array<struct<top:array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>,1>> v5, int<4> v6){
                    decl ref<array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>> v7 = ( new(array.create.1D(type<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>}>, (sizeof(type<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>}>)/sizeof(type<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>}>)))));
                    (composite.ref.elem(array.ref.elem.1D(v7, 0), value, type<int<4>>) := v6);
                    (composite.ref.elem(array.ref.elem.1D(v7, 0), next, type<array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>) := ( *composite.ref.elem(array.ref.elem.1D(v5, 0), top, type<array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>)));
                    (composite.ref.elem(array.ref.elem.1D(v5, 0), top, type<array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>) := ( *v7));
                }(v2, ( *v9));
            };
            (v1 := (0+(CAST<int<4>>(ceil((CAST<real<8>>((10-0))/CAST<real<8>>(1))))*1)));
        };
        {
            for(decl ref<int<4>> v14 = ( var(0)) .. 5 : 1) {
                printf(string.as.char.pointer("Poping  %d\n"), varlist.pack((fun(ref<array<struct<top:array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>,1>> v10){
                    if((!(!is.null(( *composite.ref.elem(array.ref.elem.1D(v10, 0), top, type<array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>)))))) {
                        return (CAST<int<4>>(0)-1);
                    } else { };
                    decl ref<array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>> v11 = composite.ref.elem(array.ref.elem.1D(v10, 0), top, type<array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>);
                    decl ref<int<4>> v12 = composite.ref.elem(array.ref.elem.1D(v11, 0), value, type<int<4>>);
                    (composite.ref.elem(array.ref.elem.1D(v10, 0), top, type<array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>) := ( *composite.ref.elem(array.ref.elem.1D(v11, 0), next, type<array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>)));
                    ( del(v11));
                    return ( *v12);
                }(v2))));
            };
            (v1 := (0+(CAST<int<4>>(ceil((CAST<real<8>>((5-0))/CAST<real<8>>(1))))*1)));
        };
        fun(ref<array<struct<top:array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>,1>> v15){
            decl ref<ref<array<struct<top:array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>,1>>> v17 = ( var(v15));
            {
                while((!is.null(( *composite.ref.elem(array.ref.elem.1D(( *v17), 0), top, type<array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>))))) {
                    decl ref<array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>> v16 = composite.ref.elem(array.ref.elem.1D(( *v17), 0), top, type<array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>);
                    (composite.ref.elem(array.ref.elem.1D(( *v17), 0), top, type<array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>) := ( *composite.ref.elem(array.ref.elem.1D(v16, 0), next, type<array<rec 'elem{'elem=struct<value:int<4>,next:array<'elem,1>>},1>>)));
                    ( del(v16));
                };
                ( del(v17));
            };
        }(v2);
        return 0;
    }

