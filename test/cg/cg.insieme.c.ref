// --- Generated Inspire Code ---
#include <alloca.h>
#include <stddef.h>
#include <stdlib.h>
#include <runtime.h>
#define bool int
#define true 1
#define false 0
#define null 0

// start code fragment :: array type definition of __insieme_type_1 <=> array<char,1> //
typedef struct ___insieme_type_1 { 
    char* data;
} __insieme_type_1;

// start code fragment :: array type definition of __insieme_type_0 <=> array<array<char,1>,1> //
typedef struct ___insieme_type_0 { 
    __insieme_type_1* data;
} __insieme_type_0;

// start code fragment :: vector_type_declaration of __insieme_type_2 <=> vector<int<4>,637001> //
typedef struct ___insieme_type_2 { 
    int data[637001];
} __insieme_type_2;

// A constructor initializing a vector of the type __insieme_type_2 uniformly
static inline __insieme_type_2 __insieme_type_2_init_uniform(int value) {
	__insieme_type_2 res;
	for (int i=0; i<637001;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_3 <=> vector<int<4>,7002> //
typedef struct ___insieme_type_3 { 
    int data[7002];
} __insieme_type_3;

// A constructor initializing a vector of the type __insieme_type_3 uniformly
static inline __insieme_type_3 __insieme_type_3_init_uniform(int value) {
	__insieme_type_3 res;
	for (int i=0; i<7002;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_4 <=> vector<int<4>,14002> //
typedef struct ___insieme_type_4 { 
    int data[14002];
} __insieme_type_4;

// A constructor initializing a vector of the type __insieme_type_4 uniformly
static inline __insieme_type_4 __insieme_type_4_init_uniform(int value) {
	__insieme_type_4 res;
	for (int i=0; i<14002;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_5 <=> vector<real<8>,7002> //
typedef struct ___insieme_type_5 { 
    double data[7002];
} __insieme_type_5;

// A constructor initializing a vector of the type __insieme_type_5 uniformly
static inline __insieme_type_5 __insieme_type_5_init_uniform(double value) {
	__insieme_type_5 res;
	for (int i=0; i<7002;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_6 <=> vector<real<8>,637001> //
typedef struct ___insieme_type_6 { 
    double data[637001];
} __insieme_type_6;

// A constructor initializing a vector of the type __insieme_type_6 uniformly
static inline __insieme_type_6 __insieme_type_6_init_uniform(double value) {
	__insieme_type_6 res;
	for (int i=0; i<637001;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_7 <=> vector<real<8>,7003> //
typedef struct ___insieme_type_7 { 
    double data[7003];
} __insieme_type_7;

// A constructor initializing a vector of the type __insieme_type_7 uniformly
static inline __insieme_type_7 __insieme_type_7_init_uniform(double value) {
	__insieme_type_7 res;
	for (int i=0; i<7003;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_8 <=> vector<real<8>,64> //
typedef struct ___insieme_type_8 { 
    double data[64];
} __insieme_type_8;

// A constructor initializing a vector of the type __insieme_type_8 uniformly
static inline __insieme_type_8 __insieme_type_8_init_uniform(double value) {
	__insieme_type_8 res;
	for (int i=0; i<64;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: type_declaration___insieme_globals //
struct __insieme_globals { 
    int naa;
    int nzz;
    int firstrow;
    int lastrow;
    int firstcol;
    int lastcol;
    __insieme_type_2 colidx;
    __insieme_type_3 rowstr;
    __insieme_type_4 iv;
    __insieme_type_2 arow;
    __insieme_type_2 acol;
    __insieme_type_5 v;
    __insieme_type_6 aelt;
    __insieme_type_6 a;
    __insieme_type_7 x;
    __insieme_type_7 z;
    __insieme_type_7 p;
    __insieme_type_7 q;
    __insieme_type_7 r;
    __insieme_type_7 w;
    double amult;
    double tran;
    double d;
    double sum;
    double rho;
    double rho0;
    double alpha;
    double beta;
    __insieme_type_8 start;
    __insieme_type_8 elapsed;
    int sec;
};

// start code fragment :: global data //
struct __insieme_globals __GLOBAL__;

// start code fragment :: Prototype for external function: printf ... type: ((ref<array<char,1>>,var_list)->int<4>) //
int printf(char*, ...);

// start code fragment :: array type definition of __insieme_type_13 <=> array<real<8>,1> //
typedef struct ___insieme_type_13 { 
    double* data;
} __insieme_type_13;

// start code fragment :: Definition of randlc ... type: ((ref<array<real<8>,1>>,real<8>)->real<8>) //
double randlc(__insieme_type_13* x, double a){
	double t1 = 0.0;
	double t2 = 0.0;
	double t3 = 0.0;
	double t4 = 0.0;
	double a1 = 0.0;
	double a2 = 0.0;
	double x1 = 0.0;
	double x2 = 0.0;
	double z = 0.0;
	((t1) = (((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*a));
	((a1) = ((double)(((int)(t1)))));
	((a2) = (a-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(a1))));
	((t1) = (((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*(((*x).data[0]))));
	((x1) = ((double)(((int)(t1)))));
	((x2) = ((((*x).data[0]))-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(x1))));
	((t1) = (((a1)*(x2))+((a2)*(x1))));
	((t2) = ((double)(((int)((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*(t1)))))));
	((z) = ((t1)-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(t2))));
	((t3) = ((((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(z))+((a2)*(x2))));
	((t4) = ((double)(((int)(((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5))*(t3)))))));
	((((*x).data[0])) = ((t3)-((((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0))*(t4))));
	return ((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5))*(((*x).data[0])));
}
static double randlc_wrap(void* _closure, __insieme_type_13* x, double a) { return randlc(x, a); }

// start code fragment :: array type definition of __insieme_type_15 <=> array<int<4>,1> //
typedef struct ___insieme_type_15 { 
    int* data;
} __insieme_type_15;

// start code fragment :: Prototype for external function: pow ... type: ((real<8>,real<8>)->real<8>) //
double pow(double, double);
static double pow_wrap(void* _closure, double var_282, double var_283) { return pow(var_282, var_283); }

// start code fragment :: Prototype for external function: ceil ... type: ((real<8>)->real<8>) //
double ceil(double);
static double ceil_wrap(void* _closure, double var_284) { return ceil(var_284); }

// start code fragment :: Definition of icnvrt ... type: ((real<8>,int<4>)->int<4>) //
int icnvrt(double x, int ipwr2) { return ((int)((((double)(ipwr2))*x))); }
static int icnvrt_wrap(void* _closure, double x, int ipwr2) { return icnvrt(x, ipwr2); }

// start code fragment :: Definition of sprnvc ... type: ((int<4>,int<4>,ref<array<real<8>,1>>,ref<array<int<4>,1>>,ref<array<int<4>,1>>,ref<array<int<4>,1>>)->unit) //
void sprnvc(int n, int nz, __insieme_type_13* v, __insieme_type_15* iv, __insieme_type_15* nzloc, __insieme_type_15* mark){
	int nn1 = 0;
	int nzrow = 0;
	int nzv = 0;
	int ii = 0;
	int i = 0;
	double vecelt = 0.0;
	double vecloc = 0.0;
	((nzv) = 0);
	((nzrow) = 0);
	((nn1) = 1);
	{
		((nn1) = (2*(nn1)));
		while(((nn1)<n))  { ((nn1) = (2*(nn1))); };
	};
	while(((nzv)<nz)) {
		((vecelt) = randlc((&((__insieme_type_13){(&((__GLOBAL__).tran))})), (*(&((__GLOBAL__).amult)))));
		((vecloc) = randlc((&((__insieme_type_13){(&((__GLOBAL__).tran))})), (*(&((__GLOBAL__).amult)))));
		((i) = (icnvrt((vecloc), (nn1))+1));
		if(((i)>n)) { continue; };
		if(((((*mark).data[((unsigned int)((i)))]))==0)){
			((((*mark).data[((unsigned int)((i)))])) = 1);
			((nzrow) = ((nzrow)+1));
			((((*nzloc).data[((unsigned int)((nzrow)))])) = (i));
			((nzv) = ((nzv)+1));
			((((*v).data[((unsigned int)((nzv)))])) = (vecelt));
			((((*iv).data[((unsigned int)((nzv)))])) = (i));
		};
	};
	{
		for(int var_95 = 1; var_95 < ((nzrow)+1); var_95 += 1) {
			((i) = (((*nzloc).data[((unsigned int)(var_95))])));
			((((*mark).data[((unsigned int)((i)))])) = 0);
		};
		((ii) = (1+(((int)(ceil((((double)((((nzrow)+1)-1)))/((double)(1))))))*1)));
	};
}
static void sprnvc_wrap(void* _closure, int n, int nz, __insieme_type_13* v, __insieme_type_15* iv, __insieme_type_15* nzloc, __insieme_type_15* mark) { sprnvc(n, nz, v, iv, nzloc, mark); }

// start code fragment :: Definition of vecset ... type: ((int<4>,ref<array<real<8>,1>>,ref<array<int<4>,1>>,ref<array<int<4>,1>>,int<4>,real<8>)->unit) //
void vecset(int n, __insieme_type_13* v, __insieme_type_15* iv, __insieme_type_15* nzv, int i, double val){
	int k = 0;
	int set = 0;
	((set) = 0);
	{
		for(int var_106 = 1; var_106 < ((((*nzv).data[0]))+1); var_106 += 1)  { if(((((*iv).data[((unsigned int)(var_106))]))==i)){
			((((*v).data[((unsigned int)(var_106))])) = val);
			((set) = 1);
		}; };
		((k) = (1+(((int)(ceil((((double)((((((*nzv).data[0]))+1)-1)))/((double)(1))))))*1)));
	};
	if(((set)==0)){
		((((*nzv).data[0])) = ((((*nzv).data[0]))+1));
		((((*v).data[((unsigned int)((((*nzv).data[0]))))])) = val);
		((((*iv).data[((unsigned int)((((*nzv).data[0]))))])) = i);
	};
}
static void vecset_wrap(void* _closure, int n, __insieme_type_13* v, __insieme_type_15* iv, __insieme_type_15* nzv, int i, double val) { vecset(n, v, iv, nzv, i, val); }

// start code fragment :: Prototype for external function: exit ... type: ((int<4>)->unit) //
void exit(int);
static void exit_wrap(void* _closure, int var_285) { exit(var_285); }

// start code fragment :: Definition of sparse ... type: ((ref<array<real<8>,1>>,ref<array<int<4>,1>>,ref<array<int<4>,1>>,int<4>,ref<array<int<4>,1>>,ref<array<int<4>,1>>,ref<array<real<8>,1>>,int<4>,int<4>,ref<array<real<8>,1>>,ref<array<int<4>,1>>,ref<array<int<4>,1>>,int<4>)->unit) //
void sparse(__insieme_type_13* a, __insieme_type_15* colidx, __insieme_type_15* rowstr, int n, __insieme_type_15* arow, __insieme_type_15* acol, __insieme_type_13* aelt, int firstrow, int lastrow, __insieme_type_13* x, __insieme_type_15* mark, __insieme_type_15* nzloc, int nnza){
	int nrows = 0;
	int i = 0;
	int j = 0;
	int jajp1 = 0;
	int nza = 0;
	int k = 0;
	int nzrow = 0;
	double xi = 0.0;
	((nrows) = ((lastrow-firstrow)+1));
	{
		for(int var_147 = 1; var_147 < (n+1); var_147 += 1) {
			((((*rowstr).data[((unsigned int)(var_147))])) = 0);
			((((*mark).data[((unsigned int)(var_147))])) = 0);
		};
		((j) = (1+(((int)(ceil((((double)(((n+1)-1)))/((double)(1))))))*1)));
	};
	((((*rowstr).data[((unsigned int)((n+1)))])) = 0);
	{
		for(int var_149 = 1; var_149 < (nnza+1); var_149 += 1) {
			((j) = ((((((*arow).data[((unsigned int)(var_149))]))-firstrow)+1)+1));
			((((*rowstr).data[((unsigned int)((j)))])) = ((((*rowstr).data[((unsigned int)((j)))]))+1));
		};
		((nza) = (1+(((int)(ceil((((double)(((nnza+1)-1)))/((double)(1))))))*1)));
	};
	((((*rowstr).data[((unsigned int)(1))])) = 1);
	{
		for(int var_151 = 2; var_151 < (((nrows)+1)+1); var_151 += 1)  { ((((*rowstr).data[((unsigned int)(var_151))])) = ((((*rowstr).data[((unsigned int)(var_151))]))+(((*rowstr).data[((unsigned int)((var_151-1)))])))); };
		((j) = (2+(((int)(ceil((((double)(((((nrows)+1)+1)-2)))/((double)(1))))))*1)));
	};
	{
		for(int var_153 = 1; var_153 < (nnza+1); var_153 += 1) {
			((j) = (((((*arow).data[((unsigned int)(var_153))]))-firstrow)+1));
			((k) = (((*rowstr).data[((unsigned int)((j)))])));
			((((*a).data[((unsigned int)((k)))])) = (((*aelt).data[((unsigned int)(var_153))])));
			((((*colidx).data[((unsigned int)((k)))])) = (((*acol).data[((unsigned int)(var_153))])));
			((((*rowstr).data[((unsigned int)((j)))])) = ((((*rowstr).data[((unsigned int)((j)))]))+1));
		};
		((nza) = (1+(((int)(ceil((((double)(((nnza+1)-1)))/((double)(1))))))*1)));
	};
	{
		for(int var_155 = (((int)(0))-(nrows)); var_155 < ((((int)(0))-1)+1); var_155 += 1)  { ((((*rowstr).data[((unsigned int)(((((int)(0))-var_155)+1)))])) = (((*rowstr).data[((unsigned int)((((int)(0))-var_155)))]))); };
		((j) = ((nrows)+(((int)(ceil((((double)((((((int)(0))-1)+1)-(nrows))))/((double)(1))))))*1)));
	};
	((((*rowstr).data[((unsigned int)(1))])) = 1);
	((nza) = 0);
	{
		for(int var_157 = 1; var_157 < (n+1); var_157 += 1) {
			((((*x).data[((unsigned int)(var_157))])) = 0.0);
			((((*mark).data[((unsigned int)(var_157))])) = 0);
		};
		((i) = (1+(((int)(ceil((((double)(((n+1)-1)))/((double)(1))))))*1)));
	};
	((jajp1) = (((*rowstr).data[((unsigned int)(1))])));
	{
		for(int var_166 = 1; var_166 < ((nrows)+1); var_166 += 1) {
			((nzrow) = 0);
			{
				for(int var_162 = (jajp1); var_162 < (((*rowstr).data[((unsigned int)((var_166+1)))])); var_162 += 1) {
					((i) = (((*colidx).data[((unsigned int)(var_162))])));
					((((*x).data[((unsigned int)((i)))])) = ((((*x).data[((unsigned int)((i)))]))+(((*a).data[((unsigned int)(var_162))]))));
					if((((((*mark).data[((unsigned int)((i)))]))==0)&&((((*x).data[((unsigned int)((i)))]))!=0.0))){
						((((*mark).data[((unsigned int)((i)))])) = 1);
						((nzrow) = ((nzrow)+1));
						((((*nzloc).data[((unsigned int)((nzrow)))])) = (i));
					};
				};
				((k) = ((jajp1)+(((int)(ceil((((double)(((((*rowstr).data[((unsigned int)((var_166+1)))]))-(jajp1))))/((double)(1))))))*1)));
			};
			{
				for(int var_164 = 1; var_164 < ((nzrow)+1); var_164 += 1) {
					((i) = (((*nzloc).data[((unsigned int)(var_164))])));
					((((*mark).data[((unsigned int)((i)))])) = 0);
					((xi) = (((*x).data[((unsigned int)((i)))])));
					((((*x).data[((unsigned int)((i)))])) = 0.0);
					if(((xi)!=0.0)){
						((nza) = ((nza)+1));
						((((*a).data[((unsigned int)((nza)))])) = (xi));
						((((*colidx).data[((unsigned int)((nza)))])) = (i));
					};
				};
				((k) = (1+(((int)(ceil((((double)((((nzrow)+1)-1)))/((double)(1))))))*1)));
			};
			((jajp1) = (((*rowstr).data[((unsigned int)((var_166+1)))])));
			((((*rowstr).data[((unsigned int)((var_166+1)))])) = ((nza)+(((*rowstr).data[((unsigned int)(1))]))));
		};
		((j) = (1+(((int)(ceil((((double)((((nrows)+1)-1)))/((double)(1))))))*1)));
	};
}
static void sparse_wrap(void* _closure, __insieme_type_13* a, __insieme_type_15* colidx, __insieme_type_15* rowstr, int n, __insieme_type_15* arow, __insieme_type_15* acol, __insieme_type_13* aelt, int firstrow, int lastrow, __insieme_type_13* x, __insieme_type_15* mark, __insieme_type_15* nzloc, int nnza) { sparse(a, colidx, rowstr, n, arow, acol, aelt, firstrow, lastrow, x, mark, nzloc, nnza); }

// start code fragment :: Definition of makea ... type: ((int<4>,int<4>,ref<array<real<8>,1>>,ref<array<int<4>,1>>,ref<array<int<4>,1>>,int<4>,int<4>,int<4>,int<4>,int<4>,real<8>,ref<array<int<4>,1>>,ref<array<int<4>,1>>,ref<array<real<8>,1>>,ref<array<real<8>,1>>,ref<array<int<4>,1>>,real<8>)->unit) //
void makea(int n, int nz, __insieme_type_13* a, __insieme_type_15* colidx, __insieme_type_15* rowstr, int nonzer, int firstrow, int lastrow, int firstcol, int lastcol, double rcond, __insieme_type_15* arow, __insieme_type_15* acol, __insieme_type_13* aelt, __insieme_type_13* v, __insieme_type_15* iv, double shift){
	int i = 0;
	int nnza = 0;
	int iouter = 0;
	int ivelt = 0;
	int ivelt1 = 0;
	int irow = 0;
	int nzv = 0;
	double size = 0.0;
	double ratio = 0.0;
	double scale = 0.0;
	int jcol = 0;
	((size) = 1.0);
	((ratio) = pow(rcond, (1.0/((double)(n)))));
	((nnza) = 0);
	{
		for(int var_76 = 1; var_76 < (n+1); var_76 += 1)  { ((((*colidx).data[((unsigned int)((n+var_76)))])) = 0); };
		((i) = (1+(((int)(ceil((((double)(((n+1)-1)))/((double)(1))))))*1)));
	};
	{
		for(int var_119 = 1; var_119 < (n+1); var_119 += 1) {
			((nzv) = nonzer);
			sprnvc(n, (nzv), v, iv, (&((__insieme_type_15){&((*colidx).data[((unsigned int)(0))])})), (&((__insieme_type_15){&((*colidx).data[((unsigned int)(n))])})));
			vecset(n, v, iv, (&((__insieme_type_15){&nzv})), var_119, 0.5);
			{
				for(int var_117 = 1; var_117 < ((nzv)+1); var_117 += 1) {
					((jcol) = (((*iv).data[((unsigned int)(var_117))])));
					if((((jcol)>=firstcol)&&((jcol)<=lastcol))){
						((scale) = ((size)*(((*v).data[((unsigned int)(var_117))]))));
						{
							for(int var_112 = 1; var_112 < ((nzv)+1); var_112 += 1) {
								((irow) = (((*iv).data[((unsigned int)(var_112))])));
								if((((irow)>=firstrow)&&((irow)<=lastrow))){
									((nnza) = ((nnza)+1));
									if(((nnza)>nz)){
										printf(((char*)((*(&((__insieme_type_1){"Space for matrix elements exceeded in"}))).data)), 0);
										printf(((char*)((*(&((__insieme_type_1){"nnza, nzmax = %d, %d\n"}))).data)), (nnza), nz);
										printf(((char*)((*(&((__insieme_type_1){"iouter = %d\n"}))).data)), var_119);
										exit(1);
									};
									((((*acol).data[((unsigned int)((nnza)))])) = (jcol));
									((((*arow).data[((unsigned int)((nnza)))])) = (irow));
									((((*aelt).data[((unsigned int)((nnza)))])) = ((((*v).data[((unsigned int)(var_112))]))*(scale)));
								};
							};
							((ivelt1) = (1+(((int)(ceil((((double)((((nzv)+1)-1)))/((double)(1))))))*1)));
						};
					};
				};
				((ivelt) = (1+(((int)(ceil((((double)((((nzv)+1)-1)))/((double)(1))))))*1)));
			};
			((size) = ((size)*(ratio)));
		};
		((iouter) = (1+(((int)(ceil((((double)(((n+1)-1)))/((double)(1))))))*1)));
	};
	{
		for(int var_124 = firstrow; var_124 < (lastrow+1); var_124 += 1)  { if(((var_124>=firstcol)&&((var_124)<=lastcol))){
			((iouter) = (n+var_124));
			((nnza) = ((nnza)+1));
			if(((nnza)>nz)){
				printf(((char*)((*(&((__insieme_type_1){"Space for matrix elements exceeded in makea\n"}))).data)), 0);
				printf(((char*)((*(&((__insieme_type_1){"nnza, nzmax = %d, %d\n"}))).data)), (nnza), nz);
				printf(((char*)((*(&((__insieme_type_1){"iouter = %d\n"}))).data)), (iouter));
				exit(1);
			};
			((((*acol).data[((unsigned int)((nnza)))])) = var_124);
			((((*arow).data[((unsigned int)((nnza)))])) = var_124);
			((((*aelt).data[((unsigned int)((nnza)))])) = (rcond-shift));
		}; };
		((i) = (firstrow+(((int)(ceil((((double)(((lastrow+1)-firstrow)))/((double)(1))))))*1)));
	};
	sparse(a, colidx, rowstr, n, arow, acol, aelt, firstrow, lastrow, v, (&((__insieme_type_15){&((*iv).data[((unsigned int)(0))])})), (&((__insieme_type_15){&((*iv).data[((unsigned int)(n))])})), (nnza));
}
static void makea_wrap(void* _closure, int n, int nz, __insieme_type_13* a, __insieme_type_15* colidx, __insieme_type_15* rowstr, int nonzer, int firstrow, int lastrow, int firstcol, int lastcol, double rcond, __insieme_type_15* arow, __insieme_type_15* acol, __insieme_type_13* aelt, __insieme_type_13* v, __insieme_type_15* iv, double shift) { makea(n, nz, a, colidx, rowstr, nonzer, firstrow, lastrow, firstcol, lastcol, rcond, arow, acol, aelt, v, iv, shift); }

// start code fragment :: Prototype for external function: sqrt ... type: ((real<8>)->real<8>) //
double sqrt(double);
static double sqrt_wrap(void* _closure, double var_286) { return sqrt(var_286); }

// start code fragment :: Definition of conj_grad ... type: ((ref<array<int<4>,1>>,ref<array<int<4>,1>>,ref<array<real<8>,1>>,ref<array<real<8>,1>>,ref<array<real<8>,1>>,ref<array<real<8>,1>>,ref<array<real<8>,1>>,ref<array<real<8>,1>>,ref<array<real<8>,1>>,ref<array<real<8>,1>>)->unit) //
void conj_grad(__insieme_type_15* colidx, __insieme_type_15* rowstr, __insieme_type_13* x, __insieme_type_13* z, __insieme_type_13* a, __insieme_type_13* p, __insieme_type_13* q, __insieme_type_13* r, __insieme_type_13* w, __insieme_type_13* rnorm){
	int i = 0;
	int j = 0;
	int k = 0;
	int cgit = 0;
	int cgitmax = 25;
	((*(&((__GLOBAL__).rho))) = 0.0);
	{
		for(int var_192 = 1; var_192 < (((*(&((__GLOBAL__).naa)))+1)+1); var_192 += 1) {
			((((*q).data[((unsigned int)(var_192))])) = 0.0);
			((((*z).data[((unsigned int)(var_192))])) = 0.0);
			((((*r).data[((unsigned int)(var_192))])) = (((*x).data[((unsigned int)(var_192))])));
			((((*p).data[((unsigned int)(var_192))])) = (((*r).data[((unsigned int)(var_192))])));
			((((*w).data[((unsigned int)(var_192))])) = 0.0);
		};
		((j) = (1+(((int)(ceil((((double)(((((*(&((__GLOBAL__).naa)))+1)+1)-1)))/((double)(1))))))*1)));
	};
	{
		for(int var_194 = 1; var_194 < ((((*(&((__GLOBAL__).lastcol)))-(*(&((__GLOBAL__).firstcol))))+1)+1); var_194 += 1)  { ((*(&((__GLOBAL__).rho))) = ((*(&((__GLOBAL__).rho)))+((((*x).data[((unsigned int)(var_194))]))*(((*x).data[((unsigned int)(var_194))]))))); };
		((j) = (1+(((int)(ceil((((double)((((((*(&((__GLOBAL__).lastcol)))-(*(&((__GLOBAL__).firstcol))))+1)+1)-1)))/((double)(1))))))*1)));
	};
	{
		for(int var_212 = 1; var_212 < ((cgitmax)+1); var_212 += 1) {
			{
				((*(&((__GLOBAL__).rho0))) = (*(&((__GLOBAL__).rho))));
				((*(&((__GLOBAL__).d))) = 0.0);
				((*(&((__GLOBAL__).rho))) = 0.0);
			};
			{
				for(int var_198 = 1; var_198 < ((((*(&((__GLOBAL__).lastrow)))-(*(&((__GLOBAL__).firstrow))))+1)+1); var_198 += 1) {
					((*(&((__GLOBAL__).sum))) = 0.0);
					{
						for(int var_196 = (((*rowstr).data[((unsigned int)(var_198))])); var_196 < (((*rowstr).data[((unsigned int)((var_198+1)))])); var_196 += 1)  { ((*(&((__GLOBAL__).sum))) = ((*(&((__GLOBAL__).sum)))+((((*a).data[((unsigned int)(var_196))]))*(((*p).data[((unsigned int)((((*colidx).data[((unsigned int)(var_196))]))))]))))); };
						((k) = ((((*rowstr).data[((unsigned int)(var_198))]))+(((int)(ceil((((double)(((((*rowstr).data[((unsigned int)((var_198+1)))]))-(((*rowstr).data[((unsigned int)(var_198))])))))/((double)(1))))))*1)));
					};
					((((*w).data[((unsigned int)(var_198))])) = (*(&((__GLOBAL__).sum))));
				};
				((j) = (1+(((int)(ceil((((double)((((((*(&((__GLOBAL__).lastrow)))-(*(&((__GLOBAL__).firstrow))))+1)+1)-1)))/((double)(1))))))*1)));
			};
			{
				for(int var_200 = 1; var_200 < ((((*(&((__GLOBAL__).lastcol)))-(*(&((__GLOBAL__).firstcol))))+1)+1); var_200 += 1)  { ((((*q).data[((unsigned int)(var_200))])) = (((*w).data[((unsigned int)(var_200))]))); };
				((j) = (1+(((int)(ceil((((double)((((((*(&((__GLOBAL__).lastcol)))-(*(&((__GLOBAL__).firstcol))))+1)+1)-1)))/((double)(1))))))*1)));
			};
			{
				for(int var_202 = 1; var_202 < ((((*(&((__GLOBAL__).lastcol)))-(*(&((__GLOBAL__).firstcol))))+1)+1); var_202 += 1)  { ((((*w).data[((unsigned int)(var_202))])) = 0.0); };
				((j) = (1+(((int)(ceil((((double)((((((*(&((__GLOBAL__).lastcol)))-(*(&((__GLOBAL__).firstcol))))+1)+1)-1)))/((double)(1))))))*1)));
			};
			{
				for(int var_204 = 1; var_204 < ((((*(&((__GLOBAL__).lastcol)))-(*(&((__GLOBAL__).firstcol))))+1)+1); var_204 += 1)  { ((*(&((__GLOBAL__).d))) = ((*(&((__GLOBAL__).d)))+((((*p).data[((unsigned int)(var_204))]))*(((*q).data[((unsigned int)(var_204))]))))); };
				((j) = (1+(((int)(ceil((((double)((((((*(&((__GLOBAL__).lastcol)))-(*(&((__GLOBAL__).firstcol))))+1)+1)-1)))/((double)(1))))))*1)));
			};
			((*(&((__GLOBAL__).alpha))) = ((*(&((__GLOBAL__).rho0)))/(*(&((__GLOBAL__).d)))));
			{
				for(int var_206 = 1; var_206 < ((((*(&((__GLOBAL__).lastcol)))-(*(&((__GLOBAL__).firstcol))))+1)+1); var_206 += 1) {
					((((*z).data[((unsigned int)(var_206))])) = ((((*z).data[((unsigned int)(var_206))]))+((*(&((__GLOBAL__).alpha)))*(((*p).data[((unsigned int)(var_206))])))));
					((((*r).data[((unsigned int)(var_206))])) = ((((*r).data[((unsigned int)(var_206))]))-((*(&((__GLOBAL__).alpha)))*(((*q).data[((unsigned int)(var_206))])))));
				};
				((j) = (1+(((int)(ceil((((double)((((((*(&((__GLOBAL__).lastcol)))-(*(&((__GLOBAL__).firstcol))))+1)+1)-1)))/((double)(1))))))*1)));
			};
			{
				for(int var_208 = 1; var_208 < ((((*(&((__GLOBAL__).lastcol)))-(*(&((__GLOBAL__).firstcol))))+1)+1); var_208 += 1)  { ((*(&((__GLOBAL__).rho))) = ((*(&((__GLOBAL__).rho)))+((((*r).data[((unsigned int)(var_208))]))*(((*r).data[((unsigned int)(var_208))]))))); };
				((j) = (1+(((int)(ceil((((double)((((((*(&((__GLOBAL__).lastcol)))-(*(&((__GLOBAL__).firstcol))))+1)+1)-1)))/((double)(1))))))*1)));
			};
			((*(&((__GLOBAL__).beta))) = ((*(&((__GLOBAL__).rho)))/(*(&((__GLOBAL__).rho0)))));
			{
				for(int var_210 = 1; var_210 < ((((*(&((__GLOBAL__).lastcol)))-(*(&((__GLOBAL__).firstcol))))+1)+1); var_210 += 1)  { ((((*p).data[((unsigned int)(var_210))])) = ((((*r).data[((unsigned int)(var_210))]))+((*(&((__GLOBAL__).beta)))*(((*p).data[((unsigned int)(var_210))]))))); };
				((j) = (1+(((int)(ceil((((double)((((((*(&((__GLOBAL__).lastcol)))-(*(&((__GLOBAL__).firstcol))))+1)+1)-1)))/((double)(1))))))*1)));
			};
		};
		((cgit) = (1+(((int)(ceil((((double)((((cgitmax)+1)-1)))/((double)(1))))))*1)));
	};
	((*(&((__GLOBAL__).sum))) = 0.0);
	{
		for(int var_216 = 1; var_216 < ((((*(&((__GLOBAL__).lastrow)))-(*(&((__GLOBAL__).firstrow))))+1)+1); var_216 += 1) {
			((*(&((__GLOBAL__).d))) = 0.0);
			{
				for(int var_214 = (((*rowstr).data[((unsigned int)(var_216))])); var_214 < (((((*rowstr).data[((unsigned int)((var_216+1)))]))-1)+1); var_214 += 1)  { ((*(&((__GLOBAL__).d))) = ((*(&((__GLOBAL__).d)))+((((*a).data[((unsigned int)(var_214))]))*(((*z).data[((unsigned int)((((*colidx).data[((unsigned int)(var_214))]))))]))))); };
				((k) = ((((*rowstr).data[((unsigned int)(var_216))]))+(((int)(ceil((((double)(((((((*rowstr).data[((unsigned int)((var_216+1)))]))-1)+1)-(((*rowstr).data[((unsigned int)(var_216))])))))/((double)(1))))))*1)));
			};
			((((*w).data[((unsigned int)(var_216))])) = (*(&((__GLOBAL__).d))));
		};
		((j) = (1+(((int)(ceil((((double)((((((*(&((__GLOBAL__).lastrow)))-(*(&((__GLOBAL__).firstrow))))+1)+1)-1)))/((double)(1))))))*1)));
	};
	{
		for(int var_218 = 1; var_218 < ((((*(&((__GLOBAL__).lastcol)))-(*(&((__GLOBAL__).firstcol))))+1)+1); var_218 += 1)  { ((((*r).data[((unsigned int)(var_218))])) = (((*w).data[((unsigned int)(var_218))]))); };
		((j) = (1+(((int)(ceil((((double)((((((*(&((__GLOBAL__).lastcol)))-(*(&((__GLOBAL__).firstcol))))+1)+1)-1)))/((double)(1))))))*1)));
	};
	{
		for(int var_220 = 1; var_220 < ((((*(&((__GLOBAL__).lastcol)))-(*(&((__GLOBAL__).firstcol))))+1)+1); var_220 += 1) {
			((*(&((__GLOBAL__).d))) = ((((*x).data[((unsigned int)(var_220))]))-(((*r).data[((unsigned int)(var_220))]))));
			((*(&((__GLOBAL__).sum))) = ((*(&((__GLOBAL__).sum)))+((*(&((__GLOBAL__).d)))*(*(&((__GLOBAL__).d))))));
		};
		((j) = (1+(((int)(ceil((((double)((((((*(&((__GLOBAL__).lastcol)))-(*(&((__GLOBAL__).firstcol))))+1)+1)-1)))/((double)(1))))))*1)));
	};
	 { ((((*rnorm).data[0])) = sqrt((*(&((__GLOBAL__).sum))))); };
}
static void conj_grad_wrap(void* _closure, __insieme_type_15* colidx, __insieme_type_15* rowstr, __insieme_type_13* x, __insieme_type_13* z, __insieme_type_13* a, __insieme_type_13* p, __insieme_type_13* q, __insieme_type_13* r, __insieme_type_13* w, __insieme_type_13* rnorm) { conj_grad(colidx, rowstr, x, z, a, p, q, r, w, rnorm); }

// start code fragment :: Definition of timer_clear ... type: ((int<4>)->unit) //
void timer_clear(int n) { ((((*(&((__GLOBAL__).elapsed))).data[((unsigned int)(n))])) = 0.0); }
static void timer_clear_wrap(void* _closure, int n) { timer_clear(n); }

// start code fragment :: type_declaration_timeval //
struct timeval { 
    long tv_sec;
    long tv_usec;
};

// start code fragment :: array type definition of __insieme_type_18 <=> array<struct<tv_sec:int<8>,tv_usec:int<8>>,1> //
typedef struct ___insieme_type_18 { 
    struct timeval* data;
} __insieme_type_18;

// start code fragment :: type_declaration_timezone //
struct timezone { 
    int tz_minuteswest;
    int tz_dsttime;
};

// start code fragment :: array type definition of __timezone_ptr_t <=> array<struct<tz_minuteswest:int<4>,tz_dsttime:int<4>>,1> //
typedef struct ___timezone_ptr_t { 
    struct timezone* data;
} __timezone_ptr_t;

// start code fragment :: Prototype for external function: gettimeofday ... type: ((ref<array<struct<tv_sec:int<8>,tv_usec:int<8>>,1>>,ref<array<struct<tz_minuteswest:int<4>,tz_dsttime:int<4>>,1>>)->int<4>) //
int gettimeofday(struct timeval*, struct timezone*);
static int gettimeofday_wrap(void* _closure, __insieme_type_18* var_287, __timezone_ptr_t* var_288) { return gettimeofday(((struct timeval*)((*(var_287)).data)), ((struct timezone*)((*(var_288)).data))); }

// start code fragment :: Definition of wtime ... type: ((ref<array<real<8>,1>>)->unit) //
void wtime(__insieme_type_13* t){
	struct timeval tv;
	gettimeofday(((struct timeval*)((*((&((__insieme_type_18){&tv})))).data)), ((struct timezone*)((*(((__timezone_ptr_t*)memcpy(alloca(sizeof(__timezone_ptr_t)), &((__timezone_ptr_t){0}), sizeof(__timezone_ptr_t))))).data)));
	if(((*(&((__GLOBAL__).sec)))<0)) { ((*(&((__GLOBAL__).sec))) = ((int)((*(&((tv).tv_sec)))))); };
	((((*t).data[0])) = (((double)(((*(&((tv).tv_sec)))-((long)((*(&((__GLOBAL__).sec))))))))+(1.0e-6*((double)((*(&((tv).tv_usec))))))));
}
static void wtime_wrap(void* _closure, __insieme_type_13* t) { wtime(t); }

// start code fragment :: Definition of elapsed_time ... type: (()->real<8>) //
double elapsed_time(){
	double t = 0.0;
	wtime((&((__insieme_type_13){&t})));
	return (t);
}
static double elapsed_time_wrap(void* _closure) { return elapsed_time(); }

// start code fragment :: Definition of timer_start ... type: ((int<4>)->unit) //
void timer_start(int n) { ((((*(&((__GLOBAL__).start))).data[((unsigned int)(n))])) = elapsed_time()); }
static void timer_start_wrap(void* _closure, int n) { timer_start(n); }

// start code fragment :: Definition of timer_stop ... type: ((int<4>)->unit) //
void timer_stop(int n){
	double t = 0.0;
	double now = 0.0;
	((now) = elapsed_time());
	((t) = ((now)-(((*(&((__GLOBAL__).start))).data[((unsigned int)(n))]))));
	((((*(&((__GLOBAL__).elapsed))).data[((unsigned int)(n))])) = ((((*(&((__GLOBAL__).elapsed))).data[((unsigned int)(n))]))+(t)));
}
static void timer_stop_wrap(void* _closure, int n) { timer_stop(n); }

// start code fragment :: Definition of timer_read ... type: ((int<4>)->real<8>) //
double timer_read(int n) { return (((*(&((__GLOBAL__).elapsed))).data[((unsigned int)(n))])); }
static double timer_read_wrap(void* _closure, int n) { return timer_read(n); }

// start code fragment :: Prototype for external function: fabs ... type: ((real<8>)->real<8>) //
double fabs(double);
static double fabs_wrap(void* _closure, double var_289) { return fabs(var_289); }

// start code fragment :: Definition of c_print_results ... type: ((ref<array<char,1>>,char,int<4>,int<4>,int<4>,int<4>,int<4>,real<8>,real<8>,ref<array<char,1>>,int<4>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>)->unit) //
void c_print_results(__insieme_type_1* name, char class, int n1, int n2, int n3, int niter, int nthreads, double t, double mops, __insieme_type_1* optype, int passed_verification, __insieme_type_1* npbversion, __insieme_type_1* compiletime, __insieme_type_1* cc, __insieme_type_1* clink, __insieme_type_1* c_lib, __insieme_type_1* c_inc, __insieme_type_1* cflags, __insieme_type_1* clinkflags, __insieme_type_1* rand){
	__insieme_type_1 evalue = ((__insieme_type_1){"1000"});
	printf(((char*)((*(&((__insieme_type_1){"\n\n %s Benchmark Completed\n"}))).data)), ((char*)((*(name)).data)));
	printf(((char*)((*(&((__insieme_type_1){" Class           =                        %c\n"}))).data)), ((int)(class)));
	if(((n2==0)&&(n3==0))) { printf(((char*)((*(&((__insieme_type_1){" Size            =             %12d\n"}))).data)), n1); } else  { printf(((char*)((*(&((__insieme_type_1){" Size            =              %3dx%3dx%3d\n"}))).data)), n1, n2, n3); };
	printf(((char*)((*(&((__insieme_type_1){" Iterations      =             %12d\n"}))).data)), niter);
	printf(((char*)((*(&((__insieme_type_1){" Threads         =             %12d\n"}))).data)), nthreads);
	printf(((char*)((*(&((__insieme_type_1){" Time in seconds =             %12.2f\n"}))).data)), 0.0);
	printf(((char*)((*(&((__insieme_type_1){" Mop/s total     =             %12.2f\n"}))).data)), 0.0);
	printf(((char*)((*(&((__insieme_type_1){" Operation type  = %24s\n"}))).data)), ((char*)((*(optype)).data)));
	if((passed_verification!=0)) { printf(((char*)((*(&((__insieme_type_1){" Verification    =               SUCCESSFUL\n"}))).data)), 0); } else  { printf(((char*)((*(&((__insieme_type_1){" Verification    =             UNSUCCESSFUL\n"}))).data)), 0); };
	printf(((char*)((*(&((__insieme_type_1){" Version         =             %12s\n"}))).data)), ((char*)((*(npbversion)).data)));
	printf(((char*)((*(&((__insieme_type_1){" Compile date    =             %12s\n"}))).data)), ((char*)((*(compiletime)).data)));
	printf(((char*)((*(&((__insieme_type_1){"\n Compile options:\n"}))).data)), 0);
	printf(((char*)((*(&((__insieme_type_1){"    CC           = %s\n"}))).data)), ((char*)((*(cc)).data)));
	printf(((char*)((*(&((__insieme_type_1){"    CLINK        = %s\n"}))).data)), ((char*)((*(clink)).data)));
	printf(((char*)((*(&((__insieme_type_1){"    C_LIB        = %s\n"}))).data)), ((char*)((*(c_lib)).data)));
	printf(((char*)((*(&((__insieme_type_1){"    C_INC        = %s\n"}))).data)), ((char*)((*(c_inc)).data)));
	printf(((char*)((*(&((__insieme_type_1){"    CFLAGS       = %s\n"}))).data)), ((char*)((*(cflags)).data)));
	printf(((char*)((*(&((__insieme_type_1){"    CLINKFLAGS   = %s\n"}))).data)), ((char*)((*(clinkflags)).data)));
	printf(((char*)((*(&((__insieme_type_1){"    RAND         = %s\n"}))).data)), ((char*)((*(rand)).data)));
}
static void c_print_results_wrap(void* _closure, __insieme_type_1* name, char class, int n1, int n2, int n3, int niter, int nthreads, double t, double mops, __insieme_type_1* optype, int passed_verification, __insieme_type_1* npbversion, __insieme_type_1* compiletime, __insieme_type_1* cc, __insieme_type_1* clink, __insieme_type_1* c_lib, __insieme_type_1* c_inc, __insieme_type_1* cflags, __insieme_type_1* clinkflags, __insieme_type_1* rand) { c_print_results(name, class, n1, n2, n3, niter, nthreads, t, mops, optype, passed_verification, npbversion, compiletime, cc, clink, c_lib, c_inc, cflags, clinkflags, rand); }

// start code fragment :: main function //
int main(int __argc, char** __argv) {
	
	// encapsulating arguments within Insieme Types ...
	int argc = __argc;
	__insieme_type_0 argv = (__insieme_type_0){alloca(sizeof(__insieme_type_1) * argc)};
	for(int i=0; i<argc; ++i) {
		argv.data[i] = (__insieme_type_1){__argv[i]};
	}
	
	// ---- begin of actual code body ----
	{
		;
		((*(&((__GLOBAL__).naa))) = 0);
		((*(&((__GLOBAL__).nzz))) = 0);
		((*(&((__GLOBAL__).firstrow))) = 0);
		((*(&((__GLOBAL__).lastrow))) = 0);
		((*(&((__GLOBAL__).firstcol))) = 0);
		((*(&((__GLOBAL__).lastcol))) = 0);
		((*(&((__GLOBAL__).amult))) = 0.0);
		((*(&((__GLOBAL__).tran))) = 0.0);
		((*(&((__GLOBAL__).d))) = 0.0);
		((*(&((__GLOBAL__).sum))) = 0.0);
		((*(&((__GLOBAL__).rho))) = 0.0);
		((*(&((__GLOBAL__).rho0))) = 0.0);
		((*(&((__GLOBAL__).alpha))) = 0.0);
		((*(&((__GLOBAL__).beta))) = 0.0);
		((*(&((__GLOBAL__).sec))) = (((int)(0))-1));
		int i = 0;
		int j = 0;
		int k = 0;
		int it = 0;
		int nthreads = 1;
		double zeta = 0.0;
		double rnorm = 0.0;
		double norm_temp11 = 0.0;
		double norm_temp12 = 0.0;
		double t = 0.0;
		double mflops = 0.0;
		char class = '\0';
		int verified = 0;
		double zeta_verify_value = 0.0;
		double epsilon = 0.0;
		((*(&((__GLOBAL__).firstrow))) = 1);
		((*(&((__GLOBAL__).lastrow))) = 7000);
		((*(&((__GLOBAL__).firstcol))) = 1);
		((*(&((__GLOBAL__).lastcol))) = 7000);
		if(((((7000==1400)&&(8==7))&&(15==15))&&(12.0==10.0))){
			((class) = 'S');
			((zeta_verify_value) = 8.5971775078648);
		} else  { if(((((7000==7000)&&(8==8))&&(15==15))&&(12.0==12.0))){
			((class) = 'W');
			((zeta_verify_value) = 10.362595087124);
		} else  { if(((((7000==14000)&&(8==11))&&(15==15))&&(12.0==20.0))){
			((class) = 'A');
			((zeta_verify_value) = 17.130235054029);
		} else  { if(((((7000==75000)&&(8==13))&&(15==75))&&(12.0==60.0))){
			((class) = 'B');
			((zeta_verify_value) = 22.712745482631);
		} else  { if(((((7000==150000)&&(8==15))&&(15==75))&&(12.0==110.0))){
			((class) = 'C');
			((zeta_verify_value) = 28.973605592845);
		} else  { ((class) = 'U'); }; }; }; }; };
		printf(((char*)((*(&((__insieme_type_1){"\n\n NAS Parallel Benchmarks 2.3 OpenMP C version - CG Benchmark\n"}))).data)), 0);
		printf(((char*)((*(&((__insieme_type_1){" Size: %10d\n"}))).data)), 7000);
		printf(((char*)((*(&((__insieme_type_1){" Iterations: %5d\n"}))).data)), 15);
		((*(&((__GLOBAL__).naa))) = 7000);
		((*(&((__GLOBAL__).nzz))) = (((7000*(8+1))*(8+1))+(7000*(8+2))));
		((*(&((__GLOBAL__).tran))) = 314159265.0);
		((*(&((__GLOBAL__).amult))) = 1220703125.0);
		((zeta) = randlc((&((__insieme_type_13){(&((__GLOBAL__).tran))})), (*(&((__GLOBAL__).amult)))));
		makea((*(&((__GLOBAL__).naa))), (*(&((__GLOBAL__).nzz))), (&((__insieme_type_13){(*(&((__GLOBAL__).a))).data})), (&((__insieme_type_15){(*(&((__GLOBAL__).colidx))).data})), (&((__insieme_type_15){(*(&((__GLOBAL__).rowstr))).data})), 8, (*(&((__GLOBAL__).firstrow))), (*(&((__GLOBAL__).lastrow))), (*(&((__GLOBAL__).firstcol))), (*(&((__GLOBAL__).lastcol))), 1.0e-1, (&((__insieme_type_15){(*(&((__GLOBAL__).arow))).data})), (&((__insieme_type_15){(*(&((__GLOBAL__).acol))).data})), (&((__insieme_type_13){(*(&((__GLOBAL__).aelt))).data})), (&((__insieme_type_13){(*(&((__GLOBAL__).v))).data})), (&((__insieme_type_15){(*(&((__GLOBAL__).iv))).data})), 12.0);
		{
			{
				for(int var_172 = 1; var_172 < ((((*(&((__GLOBAL__).lastrow)))-(*(&((__GLOBAL__).firstrow))))+1)+1); var_172 += 1)  { {
					for(int var_170 = (((*(&((__GLOBAL__).rowstr))).data[((unsigned int)(var_172))])); var_170 < (((*(&((__GLOBAL__).rowstr))).data[((unsigned int)((var_172+1)))])); var_170 += 1)  { ((((*(&((__GLOBAL__).colidx))).data[((unsigned int)(var_170))])) = (((((*(&((__GLOBAL__).colidx))).data[((unsigned int)(var_170))]))-(*(&((__GLOBAL__).firstcol))))+1)); };
					((k) = ((((*(&((__GLOBAL__).rowstr))).data[((unsigned int)(var_172))]))+(((int)(ceil((((double)(((((*(&((__GLOBAL__).rowstr))).data[((unsigned int)((var_172+1)))]))-(((*(&((__GLOBAL__).rowstr))).data[((unsigned int)(var_172))])))))/((double)(1))))))*1)));
				}; };
				((j) = (1+(((int)(ceil((((double)((((((*(&((__GLOBAL__).lastrow)))-(*(&((__GLOBAL__).firstrow))))+1)+1)-1)))/((double)(1))))))*1)));
			};
			{
				for(int var_174 = 1; var_174 < ((7000+1)+1); var_174 += 1)  { ((((*(&((__GLOBAL__).x))).data[((unsigned int)(var_174))])) = 1.0); };
				((i) = (1+(((int)(ceil((((double)((((7000+1)+1)-1)))/((double)(1))))))*1)));
			};
			((zeta) = 0.0);
			{
				for(int var_227 = 1; var_227 < (1+1); var_227 += 1) {
					conj_grad((&((__insieme_type_15){(*(&((__GLOBAL__).colidx))).data})), (&((__insieme_type_15){(*(&((__GLOBAL__).rowstr))).data})), (&((__insieme_type_13){(*(&((__GLOBAL__).x))).data})), (&((__insieme_type_13){(*(&((__GLOBAL__).z))).data})), (&((__insieme_type_13){(*(&((__GLOBAL__).a))).data})), (&((__insieme_type_13){(*(&((__GLOBAL__).p))).data})), (&((__insieme_type_13){(*(&((__GLOBAL__).q))).data})), (&((__insieme_type_13){(*(&((__GLOBAL__).r))).data})), (&((__insieme_type_13){(*(&((__GLOBAL__).w))).data})), (&((__insieme_type_13){&rnorm})));
					{
						((norm_temp11) = 0.0);
						((norm_temp12) = 0.0);
					};
					{
						for(int var_223 = 1; var_223 < ((((*(&((__GLOBAL__).lastcol)))-(*(&((__GLOBAL__).firstcol))))+1)+1); var_223 += 1) {
							((norm_temp11) = ((norm_temp11)+((((*(&((__GLOBAL__).x))).data[((unsigned int)(var_223))]))*(((*(&((__GLOBAL__).z))).data[((unsigned int)(var_223))])))));
							((norm_temp12) = ((norm_temp12)+((((*(&((__GLOBAL__).z))).data[((unsigned int)(var_223))]))*(((*(&((__GLOBAL__).z))).data[((unsigned int)(var_223))])))));
						};
						((j) = (1+(((int)(ceil((((double)((((((*(&((__GLOBAL__).lastcol)))-(*(&((__GLOBAL__).firstcol))))+1)+1)-1)))/((double)(1))))))*1)));
					};
					((norm_temp12) = (1.0/sqrt((norm_temp12))));
					{
						for(int var_225 = 1; var_225 < ((((*(&((__GLOBAL__).lastcol)))-(*(&((__GLOBAL__).firstcol))))+1)+1); var_225 += 1)  { ((((*(&((__GLOBAL__).x))).data[((unsigned int)(var_225))])) = ((norm_temp12)*(((*(&((__GLOBAL__).z))).data[((unsigned int)(var_225))])))); };
						((j) = (1+(((int)(ceil((((double)((((((*(&((__GLOBAL__).lastcol)))-(*(&((__GLOBAL__).firstcol))))+1)+1)-1)))/((double)(1))))))*1)));
					};
				};
				((it) = (1+(((int)(ceil((((double)(((1+1)-1)))/((double)(1))))))*1)));
			};
			{
				for(int var_229 = 1; var_229 < ((7000+1)+1); var_229 += 1)  { ((((*(&((__GLOBAL__).x))).data[((unsigned int)(var_229))])) = 1.0); };
				((i) = (1+(((int)(ceil((((double)((((7000+1)+1)-1)))/((double)(1))))))*1)));
			};
			((zeta) = 0.0);
		};
		timer_clear(1);
		timer_start(1);
		 { {
			for(int var_248 = 1; var_248 < (15+1); var_248 += 1) {
				conj_grad((&((__insieme_type_15){(*(&((__GLOBAL__).colidx))).data})), (&((__insieme_type_15){(*(&((__GLOBAL__).rowstr))).data})), (&((__insieme_type_13){(*(&((__GLOBAL__).x))).data})), (&((__insieme_type_13){(*(&((__GLOBAL__).z))).data})), (&((__insieme_type_13){(*(&((__GLOBAL__).a))).data})), (&((__insieme_type_13){(*(&((__GLOBAL__).p))).data})), (&((__insieme_type_13){(*(&((__GLOBAL__).q))).data})), (&((__insieme_type_13){(*(&((__GLOBAL__).r))).data})), (&((__insieme_type_13){(*(&((__GLOBAL__).w))).data})), (&((__insieme_type_13){&rnorm})));
				{
					((norm_temp11) = 0.0);
					((norm_temp12) = 0.0);
				};
				{
					for(int var_244 = 1; var_244 < ((((*(&((__GLOBAL__).lastcol)))-(*(&((__GLOBAL__).firstcol))))+1)+1); var_244 += 1) {
						((norm_temp11) = ((norm_temp11)+((((*(&((__GLOBAL__).x))).data[((unsigned int)(var_244))]))*(((*(&((__GLOBAL__).z))).data[((unsigned int)(var_244))])))));
						((norm_temp12) = ((norm_temp12)+((((*(&((__GLOBAL__).z))).data[((unsigned int)(var_244))]))*(((*(&((__GLOBAL__).z))).data[((unsigned int)(var_244))])))));
					};
					((j) = (1+(((int)(ceil((((double)((((((*(&((__GLOBAL__).lastcol)))-(*(&((__GLOBAL__).firstcol))))+1)+1)-1)))/((double)(1))))))*1)));
				};
				{
					((norm_temp12) = (1.0/sqrt((norm_temp12))));
					((zeta) = (12.0+(1.0/(norm_temp11))));
				};
				{
					if((var_248==1)) { printf(((char*)((*(&((__insieme_type_1){"   iteration           ||r||                 zeta\n"}))).data)), 0); };
					printf(((char*)((*(&((__insieme_type_1){"    %5d       %20.14e%20.13e\n"}))).data)), var_248, (rnorm), (zeta));
				};
				{
					for(int var_246 = 1; var_246 < ((((*(&((__GLOBAL__).lastcol)))-(*(&((__GLOBAL__).firstcol))))+1)+1); var_246 += 1)  { ((((*(&((__GLOBAL__).x))).data[((unsigned int)(var_246))])) = ((norm_temp12)*(((*(&((__GLOBAL__).z))).data[((unsigned int)(var_246))])))); };
					((j) = (1+(((int)(ceil((((double)((((((*(&((__GLOBAL__).lastcol)))-(*(&((__GLOBAL__).firstcol))))+1)+1)-1)))/((double)(1))))))*1)));
				};
			};
			((it) = (1+(((int)(ceil((((double)(((15+1)-1)))/((double)(1))))))*1)));
		}; };
		timer_stop(1);
		((t) = timer_read(1));
		printf(((char*)((*(&((__insieme_type_1){" Benchmark completed\n"}))).data)), 0);
		((epsilon) = 1.0e-10);
		if(((class)!='U')) { if((fabs(((zeta)-(zeta_verify_value)))<=(epsilon))){
			((verified) = 1);
			printf(((char*)((*(&((__insieme_type_1){" VERIFICATION SUCCESSFUL\n"}))).data)), 0);
			printf(((char*)((*(&((__insieme_type_1){" Zeta is    %20.12e\n"}))).data)), (zeta));
			printf(((char*)((*(&((__insieme_type_1){" Error is   %20.12e\n"}))).data)), ((zeta)-(zeta_verify_value)));
		} else {
			((verified) = 0);
			printf(((char*)((*(&((__insieme_type_1){" VERIFICATION FAILED\n"}))).data)), 0);
			printf(((char*)((*(&((__insieme_type_1){" Zeta                %20.12e\n"}))).data)), (zeta));
			printf(((char*)((*(&((__insieme_type_1){" The correct zeta is %20.12e\n"}))).data)), (zeta_verify_value));
		}; } else {
			((verified) = 0);
			printf(((char*)((*(&((__insieme_type_1){" Problem size unknown\n"}))).data)), 0);
			printf(((char*)((*(&((__insieme_type_1){" NO VERIFICATION PERFORMED\n"}))).data)), 0);
		};
		if(((t)!=0.0)) { ((mflops) = (((((2.0*((double)(15)))*((double)(7000)))*(((3.0+((double)((8*(8+1)))))+(25.0*(5.0+((double)((8*(8+1)))))))+3.0))/(t))/1000000.0)); } else  { ((mflops) = 0.0); };
		c_print_results(&((__insieme_type_1){"CG"}), (class), 7000, 0, 0, 15, (nthreads), (t), (mflops), &((__insieme_type_1){"          floating point"}), (verified), &((__insieme_type_1){"2.3"}), &((__insieme_type_1){"02 Dec 2010"}), &((__insieme_type_1){"cc"}), &((__insieme_type_1){"cc"}), &((__insieme_type_1){"-lm"}), &((__insieme_type_1){"-I../common"}), &((__insieme_type_1){"-O3 "}), &((__insieme_type_1){"-lm"}), &((__insieme_type_1){"randdp"}));
	}
	// ----  end of actual code body  ----
	
}

