// --- Generated Inspire Code ---
#include <alloca.h>
#include <stddef.h>
#include <stdlib.h>
#define bool int
#define true 1
#define false 0
#define null 0
// --- Entry Point ---

// start code fragment :: type_declaration___insieme_globals //
struct __insieme_globals { 
    int naa;
    int nzz;
    int firstrow;
    int lastrow;
    int firstcol;
    int lastcol;
    int(* colidx)[637001];
    int(* rowstr)[7002];
    int(* iv)[14002];
    int(* arow)[637001];
    int(* acol)[637001];
    double(* v)[7002];
    double(* aelt)[637001];
    double(* a)[637001];
    double(* x)[7003];
    double(* z)[7003];
    double(* p)[7003];
    double(* q)[7003];
    double(* r)[7003];
    double(* w)[7003];
    double amult;
    double tran;
    double d;
    double sum;
    double rho;
    double rho0;
    double alpha;
    double beta;
    double(* start)[64];
    double(* elapsed)[64];
    int sec;
};

// start code fragment :: Prototype for external function: printf //
int printf(char*, ...);

// start code fragment :: Definition of randlc //
double randlc(double* x, double a) {
	{
		double t1 = 0.0;
		double t2 = 0.0;
		double t3 = 0.0;
		double t4 = 0.0;
		double a1 = 0.0;
		double a2 = 0.0;
		double x1 = 0.0;
		double x2 = 0.0;
		double z = 0.0;
		((t1) = (((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*a));
		((a1) = ((double)(((int)((t1))))));
		((a2) = (a-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(a1))));
		((t1) = (((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((x[0]))));
		((x1) = ((double)(((int)((t1))))));
		((x2) = (((x[0]))-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(x1))));
		((t1) = (((a1)*(x2))+((a2)*(x1))));
		((t2) = ((double)(((int)((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*(t1)))))));
		((z) = ((t1)-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(t2))));
		((t3) = ((((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(z))+((a2)*(x2))));
		((t4) = ((double)(((int)(((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5))*(t3)))))));
		(((x[0])) = ((t3)-((((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0))*(t4))));
		return ((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5))*((x[0])));;
	}
}


// start code fragment :: Definitions for function type: __insieme_funType_type_0 //
// Abstract prototype for lambdas of type __insieme_funType_type_0
struct __insieme_funType_type_0 { 
    void(*fun)(void*,int,int,double*,int*,int*,int,int,int,int,int,double,int*,int*,double*,double*,int*,double);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_0
void call__insieme_funType_type_0(struct __insieme_funType_type_0* lambda,int p1,int p2,double* p3,int* p4,int* p5,int p6,int p7,int p8,int p9,int p10,double p11,int* p12,int* p13,double* p14,double* p15,int* p16,double p17) { return lambda->fun(lambda,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17); }

// start code fragment :: Definitions for function type: __insieme_funType_type_1 //
// Abstract prototype for lambdas of type __insieme_funType_type_1
struct __insieme_funType_type_1 { 
    void(*fun)(void*,int,int,double*,int*,int*,int,int,int,int,int,double,int*,int*,double*,double*,int*,double);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: Prototype for external function: pow //
double pow(double, double);

// start code fragment :: Prototype for external function: ceil //
double ceil(double);

// start code fragment :: Definitions for function type: __insieme_funType_type_2 //
// Abstract prototype for lambdas of type __insieme_funType_type_2
struct __insieme_funType_type_2 { 
    void(*fun)(void*,int,int,double*,int*,int*,int*);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_2
void call__insieme_funType_type_2(struct __insieme_funType_type_2* lambda,int p1,int p2,double* p3,int* p4,int* p5,int* p6) { return lambda->fun(lambda,p1,p2,p3,p4,p5,p6); }

// start code fragment :: Definitions for function type: __insieme_funType_type_3 //
// Abstract prototype for lambdas of type __insieme_funType_type_3
struct __insieme_funType_type_3 { 
    void(*fun)(void*,int,int,double*,int*,int*,int*);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: Definition of icnvrt //
int icnvrt(double x, int ipwr2) {
	{
		return ((int)((((double)(ipwr2))*x)));;
	}
}


// start code fragment :: Definition of sprnvc //
void sprnvc(void* _capture, int n, int nz, double* v, int* iv, int* nzloc, int* mark) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_67 = ((struct __insieme_funType_type_3*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		int nn1 = 0;
		int nzrow = 0;
		int nzv = 0;
		int ii = 0;
		int i = 0;
		double vecelt = 0.0;
		double vecloc = 0.0;
		((nzv) = 0);
		((nzrow) = 0);
		((nn1) = 1);
		{
			((nn1) = (2*(nn1)));
			while(((nn1)<n)) {
				((nn1) = (2*(nn1)));
			};
		};
		while(((nzv)<nz)) {
			((vecelt) = randlc(&((*var_67).tran), (((*var_67).amult))));
			((vecloc) = randlc(&((*var_67).tran), (((*var_67).amult))));
			((i) = (icnvrt((vecloc), (nn1))+1));
			if(((i)>n)) continue;
			if((((mark[((unsigned int)((i)))]))==0)) {
				(((mark[((unsigned int)((i)))])) = 1);
				((nzrow) = ((nzrow)+1));
				(((nzloc[((unsigned int)((nzrow)))])) = (i));
				((nzv) = ((nzv)+1));
				(((v[((unsigned int)((nzv)))])) = (vecelt));
				(((iv[((unsigned int)((nzv)))])) = (i));
			};
		};
		{
			for(int var_78 = 1; var_78 < ((nzrow)+1); var_78 += 1) {
				((i) = ((nzloc[((unsigned int)((var_78)))])));
				(((mark[((unsigned int)((i)))])) = 0);
			};
			((ii) = (1+(((int)(ceil((((double)((((nzrow)+1)-1)))/((double)(1))))))*1)));
		};
	}
}


// start code fragment :: Definition of vecset //
void vecset(int n, double* v, int* iv, int* nzv, int i, double val) {
	{
		int k = 0;
		int set = 0;
		((set) = 0);
		{
			for(int var_88 = 1; var_88 < (((nzv[0]))+1); var_88 += 1) {
				if((((iv[((unsigned int)((var_88)))]))==i)) {
					(((v[((unsigned int)((var_88)))])) = val);
					((set) = 1);
				};
			};
			((k) = (1+(((int)(ceil((((double)(((((nzv[0]))+1)-1)))/((double)(1))))))*1)));
		};
		if(((set)==0)) {
			(((nzv[0])) = (((nzv[0]))+1));
			(((v[((unsigned int)(((nzv[0]))))])) = val);
			(((iv[((unsigned int)(((nzv[0]))))])) = i);
		};
	}
}


// start code fragment :: Prototype for external function: exit //
void exit(int);

// start code fragment :: Definition of sparse //
void sparse(double* a, int* colidx, int* rowstr, int n, int* arow, int* acol, double* aelt, int firstrow, int lastrow, double* x, int* mark, int* nzloc, int nnza) {
	{
		int nrows = 0;
		int i = 0;
		int j = 0;
		int jajp1 = 0;
		int nza = 0;
		int k = 0;
		int nzrow = 0;
		double xi = 0.0;
		((nrows) = ((lastrow-firstrow)+1));
		{
			for(int var_115 = 1; var_115 < (n+1); var_115 += 1) {
				(((rowstr[((unsigned int)((var_115)))])) = 0);
				(((mark[((unsigned int)((var_115)))])) = 0);
			};
			((j) = (1+(((int)(ceil((((double)(((n+1)-1)))/((double)(1))))))*1)));
		};
		(((rowstr[((unsigned int)((n+1)))])) = 0);
		{
			for(int var_116 = 1; var_116 < (nnza+1); var_116 += 1) {
				((j) = (((((arow[((unsigned int)((var_116)))]))-firstrow)+1)+1));
				(((rowstr[((unsigned int)((j)))])) = (((rowstr[((unsigned int)((j)))]))+1));
			};
			((nza) = (1+(((int)(ceil((((double)(((nnza+1)-1)))/((double)(1))))))*1)));
		};
		(((rowstr[((unsigned int)(1))])) = 1);
		{
			for(int var_117 = 2; var_117 < (((nrows)+1)+1); var_117 += 1) {
				(((rowstr[((unsigned int)((var_117)))])) = (((rowstr[((unsigned int)((var_117)))]))+((rowstr[((unsigned int)(((var_117)-1)))]))));
			};
			((j) = (2+(((int)(ceil((((double)(((((nrows)+1)+1)-2)))/((double)(1))))))*1)));
		};
		{
			for(int var_118 = 1; var_118 < (nnza+1); var_118 += 1) {
				((j) = ((((arow[((unsigned int)((var_118)))]))-firstrow)+1));
				((k) = ((rowstr[((unsigned int)((j)))])));
				(((a[((unsigned int)((k)))])) = ((aelt[((unsigned int)((var_118)))])));
				(((colidx[((unsigned int)((k)))])) = ((acol[((unsigned int)((var_118)))])));
				(((rowstr[((unsigned int)((j)))])) = (((rowstr[((unsigned int)((j)))]))+1));
			};
			((nza) = (1+(((int)(ceil((((double)(((nnza+1)-1)))/((double)(1))))))*1)));
		};
		{
			for(int var_119 = (((int)(0))-(nrows)); var_119 < ((((int)(0))-1)+1); var_119 += 1) {
				(((rowstr[((unsigned int)(((((int)(0))-(var_119))+1)))])) = ((rowstr[((unsigned int)((((int)(0))-(var_119))))])));
			};
			((j) = ((nrows)+(((int)(ceil((((double)((((((int)(0))-1)+1)-(nrows))))/((double)(1))))))*1)));
		};
		(((rowstr[((unsigned int)(1))])) = 1);
		((nza) = 0);
		{
			for(int var_120 = 1; var_120 < (n+1); var_120 += 1) {
				(((x[((unsigned int)((var_120)))])) = 0.0);
				(((mark[((unsigned int)((var_120)))])) = 0);
			};
			((i) = (1+(((int)(ceil((((double)(((n+1)-1)))/((double)(1))))))*1)));
		};
		((jajp1) = ((rowstr[((unsigned int)(1))])));
		{
			for(int var_123 = 1; var_123 < ((nrows)+1); var_123 += 1) {
				((nzrow) = 0);
				{
					for(int var_121 = (jajp1); var_121 < ((rowstr[((unsigned int)(((var_123)+1)))])); var_121 += 1) {
						((i) = ((colidx[((unsigned int)((var_121)))])));
						(((x[((unsigned int)((i)))])) = (((x[((unsigned int)((i)))]))+((a[((unsigned int)((var_121)))]))));
						if(((((mark[((unsigned int)((i)))]))==0)&&(((x[((unsigned int)((i)))]))!=0.0))) {
							(((mark[((unsigned int)((i)))])) = 1);
							((nzrow) = ((nzrow)+1));
							(((nzloc[((unsigned int)((nzrow)))])) = (i));
						};
					};
					((k) = ((jajp1)+(((int)(ceil((((double)((((rowstr[((unsigned int)(((var_123)+1)))]))-(jajp1))))/((double)(1))))))*1)));
				};
				{
					for(int var_122 = 1; var_122 < ((nzrow)+1); var_122 += 1) {
						((i) = ((nzloc[((unsigned int)((var_122)))])));
						(((mark[((unsigned int)((i)))])) = 0);
						((xi) = ((x[((unsigned int)((i)))])));
						(((x[((unsigned int)((i)))])) = 0.0);
						if(((xi)!=0.0)) {
							((nza) = ((nza)+1));
							(((a[((unsigned int)((nza)))])) = (xi));
							(((colidx[((unsigned int)((nza)))])) = (i));
						};
					};
					((k) = (1+(((int)(ceil((((double)((((nzrow)+1)-1)))/((double)(1))))))*1)));
				};
				((jajp1) = ((rowstr[((unsigned int)(((var_123)+1)))])));
				(((rowstr[((unsigned int)(((var_123)+1)))])) = ((nza)+((rowstr[((unsigned int)(1))]))));
			};
			((j) = (1+(((int)(ceil((((double)((((nrows)+1)-1)))/((double)(1))))))*1)));
		};
	}
}


// start code fragment :: Definition of makea //
void makea(void* _capture, int n, int nz, double* a, int* colidx, int* rowstr, int nonzer, int firstrow, int lastrow, int firstcol, int lastcol, double rcond, int* arow, int* acol, double* aelt, double* v, int* iv, double shift) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_48 = ((struct __insieme_funType_type_1*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		int i = 0;
		int nnza = 0;
		int iouter = 0;
		int ivelt = 0;
		int ivelt1 = 0;
		int irow = 0;
		int nzv = 0;
		double size = 0.0;
		double ratio = 0.0;
		double scale = 0.0;
		int jcol = 0;
		((size) = 1.0);
		((ratio) = pow(rcond, (1.0/((double)(n)))));
		((nnza) = 0);
		{
			for(int var_60 = 1; var_60 < (n+1); var_60 += 1) {
				(((colidx[((unsigned int)((n+(var_60))))])) = 0);
			};
			((i) = (1+(((int)(ceil((((double)(((n+1)-1)))/((double)(1))))))*1)));
		};
		{
			for(int var_92 = 1; var_92 < (n+1); var_92 += 1) {
				((nzv) = nonzer);
				call__insieme_funType_type_2(((struct __insieme_funType_type_2*)(&((struct __insieme_funType_type_3){&sprnvc, 0, var_48}))), n, (nzv), v, iv, &(colidx[((unsigned int)(0))]), &(colidx[((unsigned int)(n))]));
				vecset(n, v, iv, &nzv, (var_92), 0.5);
				{
					for(int var_91 = 1; var_91 < ((nzv)+1); var_91 += 1) {
						((jcol) = ((iv[((unsigned int)((var_91)))])));
						if((((jcol)>=firstcol)&&((jcol)<=lastcol))) {
							((scale) = ((size)*((v[((unsigned int)((var_91)))]))));
							{
								for(int var_90 = 1; var_90 < ((nzv)+1); var_90 += 1) {
									((irow) = ((iv[((unsigned int)((var_90)))])));
									if((((irow)>=firstrow)&&((irow)<=lastrow))) {
										((nnza) = ((nnza)+1));
										if(((nnza)>nz)) {
											printf("Space for matrix elements exceeded in", 0);
											printf("nnza, nzmax = %d, %d\n", (nnza), nz);
											printf("iouter = %d\n", (var_92));
											exit(1);
										};
										(((acol[((unsigned int)((nnza)))])) = (jcol));
										(((arow[((unsigned int)((nnza)))])) = (irow));
										(((aelt[((unsigned int)((nnza)))])) = (((v[((unsigned int)((var_90)))]))*(scale)));
									};
								};
								((ivelt1) = (1+(((int)(ceil((((double)((((nzv)+1)-1)))/((double)(1))))))*1)));
							};
						};
					};
					((ivelt) = (1+(((int)(ceil((((double)((((nzv)+1)-1)))/((double)(1))))))*1)));
				};
				((size) = ((size)*(ratio)));
			};
			((iouter) = (1+(((int)(ceil((((double)(((n+1)-1)))/((double)(1))))))*1)));
		};
		{
			for(int var_93 = firstrow; var_93 < (lastrow+1); var_93 += 1) {
				if((((var_93)>=firstcol)&&((var_93)<=lastcol))) {
					((iouter) = (n+(var_93)));
					((nnza) = ((nnza)+1));
					if(((nnza)>nz)) {
						printf("Space for matrix elements exceeded in makea\n", 0);
						printf("nnza, nzmax = %d, %d\n", (nnza), nz);
						printf("iouter = %d\n", (iouter));
						exit(1);
					};
					(((acol[((unsigned int)((nnza)))])) = (var_93));
					(((arow[((unsigned int)((nnza)))])) = (var_93));
					(((aelt[((unsigned int)((nnza)))])) = (rcond-shift));
				};
			};
			((i) = (firstrow+(((int)(ceil((((double)(((lastrow+1)-firstrow)))/((double)(1))))))*1)));
		};
		sparse(a, colidx, rowstr, n, arow, acol, aelt, firstrow, lastrow, v, &(iv[((unsigned int)(0))]), &(iv[((unsigned int)(n))]), (nnza));
	}
}


// start code fragment :: Definitions for function type: __insieme_funType_type_4 //
// Abstract prototype for lambdas of type __insieme_funType_type_4
struct __insieme_funType_type_4 { 
    void(*fun)(void*,int*,int*,double*,double*,double*,double*,double*,double*,double*,double*);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_4
void call__insieme_funType_type_4(struct __insieme_funType_type_4* lambda,int* p1,int* p2,double* p3,double* p4,double* p5,double* p6,double* p7,double* p8,double* p9,double* p10) { return lambda->fun(lambda,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10); }

// start code fragment :: Definitions for function type: __insieme_funType_type_5 //
// Abstract prototype for lambdas of type __insieme_funType_type_5
struct __insieme_funType_type_5 { 
    void(*fun)(void*,int*,int*,double*,double*,double*,double*,double*,double*,double*,double*);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: Prototype for external function: sqrt //
double sqrt(double);

// start code fragment :: Definition of conj_grad //
void conj_grad(void* _capture, int* colidx, int* rowstr, double* x, double* z, double* a, double* p, double* q, double* r, double* w, double* rnorm) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_139 = ((struct __insieme_funType_type_5*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		int i = 0;
		int j = 0;
		int k = 0;
		int cgit = 0;
		int cgitmax = 25;
		((((*var_139).rho)) = 0.0);
		{
			for(int var_145 = 1; var_145 < (((((*var_139).naa))+1)+1); var_145 += 1) {
				(((q[((unsigned int)((var_145)))])) = 0.0);
				(((z[((unsigned int)((var_145)))])) = 0.0);
				(((r[((unsigned int)((var_145)))])) = ((x[((unsigned int)((var_145)))])));
				(((p[((unsigned int)((var_145)))])) = ((r[((unsigned int)((var_145)))])));
				(((w[((unsigned int)((var_145)))])) = 0.0);
			};
			((j) = (1+(((int)(ceil((((double)(((((((*var_139).naa))+1)+1)-1)))/((double)(1))))))*1)));
		};
		{
			for(int var_146 = 1; var_146 < ((((((*var_139).lastcol))-(((*var_139).firstcol)))+1)+1); var_146 += 1) {
				((((*var_139).rho)) = ((((*var_139).rho))+(((x[((unsigned int)((var_146)))]))*((x[((unsigned int)((var_146)))])))));
			};
			((j) = (1+(((int)(ceil((((double)((((((((*var_139).lastcol))-(((*var_139).firstcol)))+1)+1)-1)))/((double)(1))))))*1)));
		};
		{
			for(int var_155 = 1; var_155 < ((cgitmax)+1); var_155 += 1) {
				{
					((((*var_139).rho0)) = (((*var_139).rho)));
					((((*var_139).d)) = 0.0);
					((((*var_139).rho)) = 0.0);
				};
				{
					for(int var_148 = 1; var_148 < ((((((*var_139).lastrow))-(((*var_139).firstrow)))+1)+1); var_148 += 1) {
						((((*var_139).sum)) = 0.0);
						{
							for(int var_147 = ((rowstr[((unsigned int)((var_148)))])); var_147 < ((rowstr[((unsigned int)(((var_148)+1)))])); var_147 += 1) {
								((((*var_139).sum)) = ((((*var_139).sum))+(((a[((unsigned int)((var_147)))]))*((p[((unsigned int)(((colidx[((unsigned int)((var_147)))]))))])))));
							};
							((k) = (((rowstr[((unsigned int)((var_148)))]))+(((int)(ceil((((double)((((rowstr[((unsigned int)(((var_148)+1)))]))-((rowstr[((unsigned int)((var_148)))])))))/((double)(1))))))*1)));
						};
						(((w[((unsigned int)((var_148)))])) = (((*var_139).sum)));
					};
					((j) = (1+(((int)(ceil((((double)((((((((*var_139).lastrow))-(((*var_139).firstrow)))+1)+1)-1)))/((double)(1))))))*1)));
				};
				{
					for(int var_149 = 1; var_149 < ((((((*var_139).lastcol))-(((*var_139).firstcol)))+1)+1); var_149 += 1) {
						(((q[((unsigned int)((var_149)))])) = ((w[((unsigned int)((var_149)))])));
					};
					((j) = (1+(((int)(ceil((((double)((((((((*var_139).lastcol))-(((*var_139).firstcol)))+1)+1)-1)))/((double)(1))))))*1)));
				};
				{
					for(int var_150 = 1; var_150 < ((((((*var_139).lastcol))-(((*var_139).firstcol)))+1)+1); var_150 += 1) {
						(((w[((unsigned int)((var_150)))])) = 0.0);
					};
					((j) = (1+(((int)(ceil((((double)((((((((*var_139).lastcol))-(((*var_139).firstcol)))+1)+1)-1)))/((double)(1))))))*1)));
				};
				{
					for(int var_151 = 1; var_151 < ((((((*var_139).lastcol))-(((*var_139).firstcol)))+1)+1); var_151 += 1) {
						((((*var_139).d)) = ((((*var_139).d))+(((p[((unsigned int)((var_151)))]))*((q[((unsigned int)((var_151)))])))));
					};
					((j) = (1+(((int)(ceil((((double)((((((((*var_139).lastcol))-(((*var_139).firstcol)))+1)+1)-1)))/((double)(1))))))*1)));
				};
				((((*var_139).alpha)) = ((((*var_139).rho0))/(((*var_139).d))));
				{
					for(int var_152 = 1; var_152 < ((((((*var_139).lastcol))-(((*var_139).firstcol)))+1)+1); var_152 += 1) {
						(((z[((unsigned int)((var_152)))])) = (((z[((unsigned int)((var_152)))]))+((((*var_139).alpha))*((p[((unsigned int)((var_152)))])))));
						(((r[((unsigned int)((var_152)))])) = (((r[((unsigned int)((var_152)))]))-((((*var_139).alpha))*((q[((unsigned int)((var_152)))])))));
					};
					((j) = (1+(((int)(ceil((((double)((((((((*var_139).lastcol))-(((*var_139).firstcol)))+1)+1)-1)))/((double)(1))))))*1)));
				};
				{
					for(int var_153 = 1; var_153 < ((((((*var_139).lastcol))-(((*var_139).firstcol)))+1)+1); var_153 += 1) {
						((((*var_139).rho)) = ((((*var_139).rho))+(((r[((unsigned int)((var_153)))]))*((r[((unsigned int)((var_153)))])))));
					};
					((j) = (1+(((int)(ceil((((double)((((((((*var_139).lastcol))-(((*var_139).firstcol)))+1)+1)-1)))/((double)(1))))))*1)));
				};
				((((*var_139).beta)) = ((((*var_139).rho))/(((*var_139).rho0))));
				{
					for(int var_154 = 1; var_154 < ((((((*var_139).lastcol))-(((*var_139).firstcol)))+1)+1); var_154 += 1) {
						(((p[((unsigned int)((var_154)))])) = (((r[((unsigned int)((var_154)))]))+((((*var_139).beta))*((p[((unsigned int)((var_154)))])))));
					};
					((j) = (1+(((int)(ceil((((double)((((((((*var_139).lastcol))-(((*var_139).firstcol)))+1)+1)-1)))/((double)(1))))))*1)));
				};
			};
			((cgit) = (1+(((int)(ceil((((double)((((cgitmax)+1)-1)))/((double)(1))))))*1)));
		};
		((((*var_139).sum)) = 0.0);
		{
			for(int var_157 = 1; var_157 < ((((((*var_139).lastrow))-(((*var_139).firstrow)))+1)+1); var_157 += 1) {
				((((*var_139).d)) = 0.0);
				{
					for(int var_156 = ((rowstr[((unsigned int)((var_157)))])); var_156 < ((((rowstr[((unsigned int)(((var_157)+1)))]))-1)+1); var_156 += 1) {
						((((*var_139).d)) = ((((*var_139).d))+(((a[((unsigned int)((var_156)))]))*((z[((unsigned int)(((colidx[((unsigned int)((var_156)))]))))])))));
					};
					((k) = (((rowstr[((unsigned int)((var_157)))]))+(((int)(ceil((((double)((((((rowstr[((unsigned int)(((var_157)+1)))]))-1)+1)-((rowstr[((unsigned int)((var_157)))])))))/((double)(1))))))*1)));
				};
				(((w[((unsigned int)((var_157)))])) = (((*var_139).d)));
			};
			((j) = (1+(((int)(ceil((((double)((((((((*var_139).lastrow))-(((*var_139).firstrow)))+1)+1)-1)))/((double)(1))))))*1)));
		};
		{
			for(int var_158 = 1; var_158 < ((((((*var_139).lastcol))-(((*var_139).firstcol)))+1)+1); var_158 += 1) {
				(((r[((unsigned int)((var_158)))])) = ((w[((unsigned int)((var_158)))])));
			};
			((j) = (1+(((int)(ceil((((double)((((((((*var_139).lastcol))-(((*var_139).firstcol)))+1)+1)-1)))/((double)(1))))))*1)));
		};
		{
			for(int var_159 = 1; var_159 < ((((((*var_139).lastcol))-(((*var_139).firstcol)))+1)+1); var_159 += 1) {
				((((*var_139).d)) = (((x[((unsigned int)((var_159)))]))-((r[((unsigned int)((var_159)))]))));
				((((*var_139).sum)) = ((((*var_139).sum))+((((*var_139).d))*(((*var_139).d)))));
			};
			((j) = (1+(((int)(ceil((((double)((((((((*var_139).lastcol))-(((*var_139).firstcol)))+1)+1)-1)))/((double)(1))))))*1)));
		};
		{
			(((rnorm[0])) = sqrt((((*var_139).sum))));
		};
	}
}


// start code fragment :: Definitions for function type: __insieme_funType_type_6 //
// Abstract prototype for lambdas of type __insieme_funType_type_6
struct __insieme_funType_type_6 { 
    void(*fun)(void*,int);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_6
void call__insieme_funType_type_6(struct __insieme_funType_type_6* lambda,int p1) { return lambda->fun(lambda,p1); }

// start code fragment :: Definitions for function type: __insieme_funType_type_7 //
// Abstract prototype for lambdas of type __insieme_funType_type_7
struct __insieme_funType_type_7 { 
    void(*fun)(void*,int);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: Definition of timer_clear //
void timer_clear(void* _capture, int n) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_166 = ((struct __insieme_funType_type_7*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		((((*((*var_166).elapsed))[((unsigned int)(n))])) = 0.0);
	}
}


// start code fragment :: Definitions for function type: __insieme_funType_type_8 //
// Abstract prototype for lambdas of type __insieme_funType_type_8
struct __insieme_funType_type_8 { 
    double(*fun)(void*);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_8
double call__insieme_funType_type_8(struct __insieme_funType_type_8* lambda) { return lambda->fun(lambda); }

// start code fragment :: Definitions for function type: __insieme_funType_type_9 //
// Abstract prototype for lambdas of type __insieme_funType_type_9
struct __insieme_funType_type_9 { 
    double(*fun)(void*);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: Definitions for function type: __insieme_funType_type_10 //
// Abstract prototype for lambdas of type __insieme_funType_type_10
struct __insieme_funType_type_10 { 
    void(*fun)(void*,double*);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_10
void call__insieme_funType_type_10(struct __insieme_funType_type_10* lambda,double* p1) { return lambda->fun(lambda,p1); }

// start code fragment :: Definitions for function type: __insieme_funType_type_11 //
// Abstract prototype for lambdas of type __insieme_funType_type_11
struct __insieme_funType_type_11 { 
    void(*fun)(void*,double*);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: type_declaration_timeval //
struct timeval { 
    long tv_sec;
    long tv_usec;
};

// start code fragment :: type_declaration_timezone //
struct timezone { 
    int tz_minuteswest;
    int tz_dsttime;
};

// start code fragment :: Prototype for external function: gettimeofday //
int gettimeofday(struct timeval*, struct timezone*);

// start code fragment :: Definition of wtime //
void wtime(void* _capture, double* t) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_173 = ((struct __insieme_funType_type_11*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		struct timeval tv;
		gettimeofday(&tv, null);
		if(((((*var_173).sec))<0)) {
			((((*var_173).sec)) = ((int)((((tv).tv_sec)))));
		};
		(((t[0])) = (((double)(((((tv).tv_sec))-((long)((((*var_173).sec)))))))+(1.0e-6*((double)((((tv).tv_usec)))))));
	}
}


// start code fragment :: Definition of elapsed_time //
double elapsed_time(void* _capture) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_170 = ((struct __insieme_funType_type_9*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		double t = 0.0;
		call__insieme_funType_type_10(((struct __insieme_funType_type_10*)(&((struct __insieme_funType_type_11){&wtime, 0, var_170}))), &t);
		return (t);;
	}
}


// start code fragment :: Definition of timer_start //
void timer_start(void* _capture, int n) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_169 = ((struct __insieme_funType_type_7*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		((((*((*var_169).start))[((unsigned int)(n))])) = call__insieme_funType_type_8(((struct __insieme_funType_type_8*)(&((struct __insieme_funType_type_9){&elapsed_time, 0, var_169})))));
	}
}


// start code fragment :: Definition of timer_stop //
void timer_stop(void* _capture, int n) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_182 = ((struct __insieme_funType_type_7*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		double t = 0.0;
		double now = 0.0;
		((now) = call__insieme_funType_type_8(((struct __insieme_funType_type_8*)(&((struct __insieme_funType_type_9){&elapsed_time, 0, var_182})))));
		((t) = ((now)-(((*((*var_182).start))[((unsigned int)(n))]))));
		((((*((*var_182).elapsed))[((unsigned int)(n))])) = ((((*((*var_182).elapsed))[((unsigned int)(n))]))+(t)));
	}
}


// start code fragment :: Definitions for function type: __insieme_funType_type_12 //
// Abstract prototype for lambdas of type __insieme_funType_type_12
struct __insieme_funType_type_12 { 
    double(*fun)(void*,int);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_12
double call__insieme_funType_type_12(struct __insieme_funType_type_12* lambda,int p1) { return lambda->fun(lambda,p1); }

// start code fragment :: Definitions for function type: __insieme_funType_type_13 //
// Abstract prototype for lambdas of type __insieme_funType_type_13
struct __insieme_funType_type_13 { 
    double(*fun)(void*,int);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: Definition of timer_read //
double timer_read(void* _capture, int n) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_187 = ((struct __insieme_funType_type_13*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		return (((*((*var_187).elapsed))[((unsigned int)(n))]));;
	}
}


// start code fragment :: Prototype for external function: fabs //
double fabs(double);

// start code fragment :: Definition of c_print_results //
void c_print_results(char* name, char class, int n1, int n2, int n3, int niter, int nthreads, double t, double mops, char* optype, int passed_verification, char* npbversion, char* compiletime, char* cc, char* clink, char* c_lib, char* c_inc, char* cflags, char* clinkflags, char* rand) {
	{
		char* evalue = "1000";
		printf("\n\n %s Benchmark Completed\n", name);
		printf(" Class           =                        %c\n", ((int)(class)));
		if(((n2==0)&&(n3==0))) {
			printf(" Size            =             %12d\n", n1);
		} else {
			printf(" Size            =              %3dx%3dx%3d\n", n1, n2, n3);
		};
		printf(" Iterations      =             %12d\n", niter);
		printf(" Threads         =             %12d\n", nthreads);
		printf(" Time in seconds =             %12.2f\n", 0.0);
		printf(" Mop/s total     =             %12.2f\n", 0.0);
		printf(" Operation type  = %24s\n", optype);
		if(((bool)(passed_verification))) {
			printf(" Verification    =               SUCCESSFUL\n", 0);
		} else {
			printf(" Verification    =             UNSUCCESSFUL\n", 0);
		};
		printf(" Version         =             %12s\n", npbversion);
		printf(" Compile date    =             %12s\n", compiletime);
		printf("\n Compile options:\n", 0);
		printf("    CC           = %s\n", cc);
		printf("    CLINK        = %s\n", clink);
		printf("    C_LIB        = %s\n", c_lib);
		printf("    C_INC        = %s\n", c_inc);
		printf("    CFLAGS       = %s\n", cflags);
		printf("    CLINKFLAGS   = %s\n", clinkflags);
		printf("    RAND         = %s\n", rand);
	}
}


// start code fragment :: Definition of main //
int main(int argc, char** argv) {
	{
		struct __insieme_globals var_1 = ((struct __insieme_globals){0,
			0,
			0,
			0,
			0,
			0,
			calloc(sizeof(int[637001]), 1),
			calloc(sizeof(int[7002]), 1),
			calloc(sizeof(int[14002]), 1),
			calloc(sizeof(int[637001]), 1),
			calloc(sizeof(int[637001]), 1),
			calloc(sizeof(double[7002]), 1),
			calloc(sizeof(double[637001]), 1),
			calloc(sizeof(double[637001]), 1),
			calloc(sizeof(double[7003]), 1),
			calloc(sizeof(double[7003]), 1),
			calloc(sizeof(double[7003]), 1),
			calloc(sizeof(double[7003]), 1),
			calloc(sizeof(double[7003]), 1),
			calloc(sizeof(double[7003]), 1),
			0.0,
			0.0,
			0.0,
			0.0,
			0.0,
			0.0,
			0.0,
			0.0,
			calloc(sizeof(double[64]), 1),
			calloc(sizeof(double[64]), 1),
			(((int)(0))-1)
		});
		int i = 0;
		int j = 0;
		int k = 0;
		int it = 0;
		int nthreads = 1;
		double zeta = 0.0;
		double rnorm = 0.0;
		double norm_temp11 = 0.0;
		double norm_temp12 = 0.0;
		double t = 0.0;
		double mflops = 0.0;
		char class = '\0';
		int verified = 0;
		double zeta_verify_value = 0.0;
		double epsilon = 0.0;
		((((var_1).firstrow)) = 1);
		((((var_1).lastrow)) = 7000);
		((((var_1).firstcol)) = 1);
		((((var_1).lastcol)) = 7000);
		if(((((7000==1400)&&(8==7))&&(15==15))&&(12.0==10.0))) {
			((class) = ((char)('S')));
			((zeta_verify_value) = 8.5971775078648);
		} else if(((((7000==7000)&&(8==8))&&(15==15))&&(12.0==12.0))) {
			((class) = ((char)('W')));
			((zeta_verify_value) = 10.362595087124);
		} else if(((((7000==14000)&&(8==11))&&(15==15))&&(12.0==20.0))) {
			((class) = ((char)('A')));
			((zeta_verify_value) = 17.130235054029);
		} else if(((((7000==75000)&&(8==13))&&(15==75))&&(12.0==60.0))) {
			((class) = ((char)('B')));
			((zeta_verify_value) = 22.712745482631);
		} else if(((((7000==150000)&&(8==15))&&(15==75))&&(12.0==110.0))) {
			((class) = ((char)('C')));
			((zeta_verify_value) = 28.973605592845);
		} else {
			((class) = ((char)('U')));
		};
		printf("\n\n NAS Parallel Benchmarks 2.3 OpenMP C version - CG Benchmark\n", 0);
		printf(" Size: %10d\n", 7000);
		printf(" Iterations: %5d\n", 15);
		((((var_1).naa)) = 7000);
		((((var_1).nzz)) = (((7000*(8+1))*(8+1))+(7000*(8+2))));
		((((var_1).tran)) = 314159265.0);
		((((var_1).amult)) = 1220703125.0);
		((zeta) = randlc(&((var_1).tran), (((var_1).amult))));
		call__insieme_funType_type_0(((struct __insieme_funType_type_0*)(&((struct __insieme_funType_type_1){&makea, 0, &var_1}))), (((var_1).naa)), (((var_1).nzz)), (*((var_1).a)), (*((var_1).colidx)), (*((var_1).rowstr)), 8, (((var_1).firstrow)), (((var_1).lastrow)), (((var_1).firstcol)), (((var_1).lastcol)), 1.0e-1, (*((var_1).arow)), (*((var_1).acol)), (*((var_1).aelt)), (*((var_1).v)), (*((var_1).iv)), 12.0);
		{
			{
				for(int var_127 = 1; var_127 < ((((((var_1).lastrow))-(((var_1).firstrow)))+1)+1); var_127 += 1) {
					{
						for(int var_126 = (((*((var_1).rowstr))[((unsigned int)((var_127)))])); var_126 < (((*((var_1).rowstr))[((unsigned int)(((var_127)+1)))])); var_126 += 1) {
							((((*((var_1).colidx))[((unsigned int)((var_126)))])) = (((((*((var_1).colidx))[((unsigned int)((var_126)))]))-(((var_1).firstcol)))+1));
						};
						((k) = ((((*((var_1).rowstr))[((unsigned int)((var_127)))]))+(((int)(ceil((((double)(((((*((var_1).rowstr))[((unsigned int)(((var_127)+1)))]))-(((*((var_1).rowstr))[((unsigned int)((var_127)))])))))/((double)(1))))))*1)));
					};
				};
				((j) = (1+(((int)(ceil((((double)((((((((var_1).lastrow))-(((var_1).firstrow)))+1)+1)-1)))/((double)(1))))))*1)));
			};
			{
				for(int var_128 = 1; var_128 < ((7000+1)+1); var_128 += 1) {
					((((*((var_1).x))[((unsigned int)((var_128)))])) = 1.0);
				};
				((i) = (1+(((int)(ceil((((double)((((7000+1)+1)-1)))/((double)(1))))))*1)));
			};
			((zeta) = 0.0);
			{
				for(int var_163 = 1; var_163 < (1+1); var_163 += 1) {
					call__insieme_funType_type_4(((struct __insieme_funType_type_4*)(&((struct __insieme_funType_type_5){&conj_grad, 0, &var_1}))), (*((var_1).colidx)), (*((var_1).rowstr)), (*((var_1).x)), (*((var_1).z)), (*((var_1).a)), (*((var_1).p)), (*((var_1).q)), (*((var_1).r)), (*((var_1).w)), &rnorm);
					{
						((norm_temp11) = 0.0);
						((norm_temp12) = 0.0);
					};
					{
						for(int var_161 = 1; var_161 < ((((((var_1).lastcol))-(((var_1).firstcol)))+1)+1); var_161 += 1) {
							((norm_temp11) = ((norm_temp11)+((((*((var_1).x))[((unsigned int)((var_161)))]))*(((*((var_1).z))[((unsigned int)((var_161)))])))));
							((norm_temp12) = ((norm_temp12)+((((*((var_1).z))[((unsigned int)((var_161)))]))*(((*((var_1).z))[((unsigned int)((var_161)))])))));
						};
						((j) = (1+(((int)(ceil((((double)((((((((var_1).lastcol))-(((var_1).firstcol)))+1)+1)-1)))/((double)(1))))))*1)));
					};
					((norm_temp12) = (1.0/sqrt((norm_temp12))));
					{
						for(int var_162 = 1; var_162 < ((((((var_1).lastcol))-(((var_1).firstcol)))+1)+1); var_162 += 1) {
							((((*((var_1).x))[((unsigned int)((var_162)))])) = ((norm_temp12)*(((*((var_1).z))[((unsigned int)((var_162)))]))));
						};
						((j) = (1+(((int)(ceil((((double)((((((((var_1).lastcol))-(((var_1).firstcol)))+1)+1)-1)))/((double)(1))))))*1)));
					};
				};
				((it) = (1+(((int)(ceil((((double)(((1+1)-1)))/((double)(1))))))*1)));
			};
			{
				for(int var_164 = 1; var_164 < ((7000+1)+1); var_164 += 1) {
					((((*((var_1).x))[((unsigned int)((var_164)))])) = 1.0);
				};
				((i) = (1+(((int)(ceil((((double)((((7000+1)+1)-1)))/((double)(1))))))*1)));
			};
			((zeta) = 0.0);
		};
		call__insieme_funType_type_6(((struct __insieme_funType_type_6*)(&((struct __insieme_funType_type_7){&timer_clear, 0, &var_1}))), 1);
		call__insieme_funType_type_6(((struct __insieme_funType_type_6*)(&((struct __insieme_funType_type_7){&timer_start, 0, &var_1}))), 1);
		{
			{
				for(int var_180 = 1; var_180 < (15+1); var_180 += 1) {
					call__insieme_funType_type_4(((struct __insieme_funType_type_4*)(&((struct __insieme_funType_type_5){&conj_grad, 0, &var_1}))), (*((var_1).colidx)), (*((var_1).rowstr)), (*((var_1).x)), (*((var_1).z)), (*((var_1).a)), (*((var_1).p)), (*((var_1).q)), (*((var_1).r)), (*((var_1).w)), &rnorm);
					{
						((norm_temp11) = 0.0);
						((norm_temp12) = 0.0);
					};
					{
						for(int var_178 = 1; var_178 < ((((((var_1).lastcol))-(((var_1).firstcol)))+1)+1); var_178 += 1) {
							((norm_temp11) = ((norm_temp11)+((((*((var_1).x))[((unsigned int)((var_178)))]))*(((*((var_1).z))[((unsigned int)((var_178)))])))));
							((norm_temp12) = ((norm_temp12)+((((*((var_1).z))[((unsigned int)((var_178)))]))*(((*((var_1).z))[((unsigned int)((var_178)))])))));
						};
						((j) = (1+(((int)(ceil((((double)((((((((var_1).lastcol))-(((var_1).firstcol)))+1)+1)-1)))/((double)(1))))))*1)));
					};
					{
						((norm_temp12) = (1.0/sqrt((norm_temp12))));
						((zeta) = (12.0+(1.0/(norm_temp11))));
					};
					{
						if(((var_180)==1)) {
							printf("   iteration           ||r||                 zeta\n", 0);
						};
						printf("    %5d       %20.14e%20.13e\n", (var_180), (rnorm), (zeta));
					};
					{
						for(int var_179 = 1; var_179 < ((((((var_1).lastcol))-(((var_1).firstcol)))+1)+1); var_179 += 1) {
							((((*((var_1).x))[((unsigned int)((var_179)))])) = ((norm_temp12)*(((*((var_1).z))[((unsigned int)((var_179)))]))));
						};
						((j) = (1+(((int)(ceil((((double)((((((((var_1).lastcol))-(((var_1).firstcol)))+1)+1)-1)))/((double)(1))))))*1)));
					};
				};
				((it) = (1+(((int)(ceil((((double)(((15+1)-1)))/((double)(1))))))*1)));
			};
		};
		call__insieme_funType_type_6(((struct __insieme_funType_type_6*)(&((struct __insieme_funType_type_7){&timer_stop, 0, &var_1}))), 1);
		((t) = call__insieme_funType_type_12(((struct __insieme_funType_type_12*)(&((struct __insieme_funType_type_13){&timer_read, 0, &var_1}))), 1));
		printf(" Benchmark completed\n", 0);
		((epsilon) = 1.0e-10);
		if((((int)((class)))!='U')) {
			if((fabs(((zeta)-(zeta_verify_value)))<=(epsilon))) {
				((verified) = 1);
				printf(" VERIFICATION SUCCESSFUL\n", 0);
				printf(" Zeta is    %20.12e\n", (zeta));
				printf(" Error is   %20.12e\n", ((zeta)-(zeta_verify_value)));
			} else {
				((verified) = 0);
				printf(" VERIFICATION FAILED\n", 0);
				printf(" Zeta                %20.12e\n", (zeta));
				printf(" The correct zeta is %20.12e\n", (zeta_verify_value));
			};
		} else {
			((verified) = 0);
			printf(" Problem size unknown\n", 0);
			printf(" NO VERIFICATION PERFORMED\n", 0);
		};
		if(((t)!=0.0)) {
			((mflops) = (((((2.0*((double)(15)))*((double)(7000)))*(((3.0+((double)((8*(8+1)))))+(25.0*(5.0+((double)((8*(8+1)))))))+3.0))/(t))/1000000.0));
		} else {
			((mflops) = 0.0);
		};
		c_print_results("CG", (class), 7000, 0, 0, 15, (nthreads), (t), (mflops), "          floating point", (verified), "2.3", "02 Dec 2010", "cc", "cc", "-lm", "-I../common", "-O3 ", "-lm", "randdp");
	}
}

