// --- Generated Inspire Code ---
#include <alloca.h>
#include <stddef.h>
#include <stdlib.h>
#include <runtime.h>
#define bool int
#define true 1
#define false 0
#define null 0
// --- Entry Point ---

// start code fragment :: type_declaration___insieme_globals //
struct __insieme_globals { 
    int naa;
    int nzz;
    int firstrow;
    int lastrow;
    int firstcol;
    int lastcol;
    int colidx[637001];
    int rowstr[7002];
    int iv[14002];
    int arow[637001];
    int acol[637001];
    double v[7002];
    double aelt[637001];
    double a[637001];
    double x[7003];
    double z[7003];
    double p[7003];
    double q[7003];
    double r[7003];
    double w[7003];
    double amult;
    double tran;
    double d;
    double sum;
    double rho;
    double rho0;
    double alpha;
    double beta;
    double elapsed[64];
    double start[64];
    int sec;
};

// start code fragment :: Prototype for external function: printf ... type: ((ref<array<char,1>>,var_list)->int<4>) //
int printf(char*, ...);

// start code fragment :: Definition of randlc //
double randlc(double* x, double a) {
	{
		double t1 = 0.0;
		double t2 = 0.0;
		double t3 = 0.0;
		double t4 = 0.0;
		double a1 = 0.0;
		double a2 = 0.0;
		double x1 = 0.0;
		double x2 = 0.0;
		double z = 0.0;
		((t1) = (((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*a));
		((a1) = ((double)(((int)((t1))))));
		((a2) = (a-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(a1))));
		((t1) = (((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((x[0]))));
		((x1) = ((double)(((int)((t1))))));
		((x2) = (((x[0]))-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(x1))));
		((t1) = (((a1)*(x2))+((a2)*(x1))));
		((t2) = ((double)(((int)((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*(t1)))))));
		((z) = ((t1)-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(t2))));
		((t3) = ((((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(z))+((a2)*(x2))));
		((t4) = ((double)(((int)(((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5))*(t3)))))));
		(((x[0])) = ((t3)-((((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0))*(t4))));
		return ((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5))*((x[0])));;
	}
}


// start code fragment :: Prototype for external function: pow ... type: ((real<8>,real<8>)->real<8>) //
double pow(double, double);

// start code fragment :: Prototype for external function: ceil ... type: ((real<8>)->real<8>) //
double ceil(double);

// start code fragment :: Definition of icnvrt //
int icnvrt(double x, int ipwr2) {
	{
		return ((int)((((double)(ipwr2))*x)));;
	}
}


// start code fragment :: Definition of sprnvc //
void sprnvc(struct __insieme_globals var_76, int n, int nz, double* v, int* iv, int* nzloc, int* mark) {
	{
		int nn1 = 0;
		int nzrow = 0;
		int nzv = 0;
		int ii = 0;
		int i = 0;
		double vecelt = 0.0;
		double vecloc = 0.0;
		((nzv) = 0);
		((nzrow) = 0);
		((nn1) = 1);
		{
			((nn1) = (2*(nn1)));
			while(((nn1)<n)) {
				((nn1) = (2*(nn1)));
			};
		};
		while(((nzv)<nz)) {
			((vecelt) = randlc(((&((var_76).tran))), (*(&((var_76).amult)))));
			((vecloc) = randlc(((&((var_76).tran))), (*(&((var_76).amult)))));
			((i) = (icnvrt((vecloc), (nn1))+1));
			if(((i)>n)) continue;
			if((((mark[((unsigned int)((i)))]))==0)) {
				(((mark[((unsigned int)((i)))])) = 1);
				((nzrow) = ((nzrow)+1));
				(((nzloc[((unsigned int)((nzrow)))])) = (i));
				((nzv) = ((nzv)+1));
				(((v[((unsigned int)((nzv)))])) = (vecelt));
				(((iv[((unsigned int)((nzv)))])) = (i));
			};
		};
		{
			for(int var_93 = 1; var_93 < ((nzrow)+1); var_93 += 1) {
				((i) = ((nzloc[((unsigned int)((var_93)))])));
				(((mark[((unsigned int)((i)))])) = 0);
			};
			((ii) = (1+(((int)(ceil((((double)((((nzrow)+1)-1)))/((double)(1))))))*1)));
		};
	}
}


// start code fragment :: Definition of vecset //
void vecset(int n, double* v, int* iv, int* nzv, int i, double val) {
	{
		int k = 0;
		int set = 0;
		((set) = 0);
		{
			for(int var_103 = 1; var_103 < (((nzv[0]))+1); var_103 += 1) {
				if((((iv[((unsigned int)((var_103)))]))==i)) {
					(((v[((unsigned int)((var_103)))])) = val);
					((set) = 1);
				};
			};
			((k) = (1+(((int)(ceil((((double)(((((nzv[0]))+1)-1)))/((double)(1))))))*1)));
		};
		if(((set)==0)) {
			(((nzv[0])) = (((nzv[0]))+1));
			(((v[((unsigned int)(((nzv[0]))))])) = val);
			(((iv[((unsigned int)(((nzv[0]))))])) = i);
		};
	}
}


// start code fragment :: Prototype for external function: exit ... type: ((int<4>)->unit) //
void exit(int);

// start code fragment :: Definition of sparse //
void sparse(double* a, int* colidx, int* rowstr, int n, int* arow, int* acol, double* aelt, int firstrow, int lastrow, double* x, int* mark, int* nzloc, int nnza) {
	{
		int nrows = 0;
		int i = 0;
		int j = 0;
		int jajp1 = 0;
		int nza = 0;
		int k = 0;
		int nzrow = 0;
		double xi = 0.0;
		((nrows) = ((lastrow-firstrow)+1));
		{
			for(int var_139 = 1; var_139 < (n+1); var_139 += 1) {
				(((rowstr[((unsigned int)((var_139)))])) = 0);
				(((mark[((unsigned int)((var_139)))])) = 0);
			};
			((j) = (1+(((int)(ceil((((double)(((n+1)-1)))/((double)(1))))))*1)));
		};
		(((rowstr[((unsigned int)((n+1)))])) = 0);
		{
			for(int var_140 = 1; var_140 < (nnza+1); var_140 += 1) {
				((j) = (((((arow[((unsigned int)((var_140)))]))-firstrow)+1)+1));
				(((rowstr[((unsigned int)((j)))])) = (((rowstr[((unsigned int)((j)))]))+1));
			};
			((nza) = (1+(((int)(ceil((((double)(((nnza+1)-1)))/((double)(1))))))*1)));
		};
		(((rowstr[((unsigned int)(1))])) = 1);
		{
			for(int var_141 = 2; var_141 < (((nrows)+1)+1); var_141 += 1) {
				(((rowstr[((unsigned int)((var_141)))])) = (((rowstr[((unsigned int)((var_141)))]))+((rowstr[((unsigned int)(((var_141)-1)))]))));
			};
			((j) = (2+(((int)(ceil((((double)(((((nrows)+1)+1)-2)))/((double)(1))))))*1)));
		};
		{
			for(int var_142 = 1; var_142 < (nnza+1); var_142 += 1) {
				((j) = ((((arow[((unsigned int)((var_142)))]))-firstrow)+1));
				((k) = ((rowstr[((unsigned int)((j)))])));
				(((a[((unsigned int)((k)))])) = ((aelt[((unsigned int)((var_142)))])));
				(((colidx[((unsigned int)((k)))])) = ((acol[((unsigned int)((var_142)))])));
				(((rowstr[((unsigned int)((j)))])) = (((rowstr[((unsigned int)((j)))]))+1));
			};
			((nza) = (1+(((int)(ceil((((double)(((nnza+1)-1)))/((double)(1))))))*1)));
		};
		{
			for(int var_143 = (((int)(0))-(nrows)); var_143 < ((((int)(0))-1)+1); var_143 += 1) {
				(((rowstr[((unsigned int)(((((int)(0))-(var_143))+1)))])) = ((rowstr[((unsigned int)((((int)(0))-(var_143))))])));
			};
			((j) = ((nrows)+(((int)(ceil((((double)((((((int)(0))-1)+1)-(nrows))))/((double)(1))))))*1)));
		};
		(((rowstr[((unsigned int)(1))])) = 1);
		((nza) = 0);
		{
			for(int var_144 = 1; var_144 < (n+1); var_144 += 1) {
				(((x[((unsigned int)((var_144)))])) = 0.0);
				(((mark[((unsigned int)((var_144)))])) = 0);
			};
			((i) = (1+(((int)(ceil((((double)(((n+1)-1)))/((double)(1))))))*1)));
		};
		((jajp1) = ((rowstr[((unsigned int)(1))])));
		{
			for(int var_150 = 1; var_150 < ((nrows)+1); var_150 += 1) {
				((nzrow) = 0);
				{
					for(int var_148 = (jajp1); var_148 < ((rowstr[((unsigned int)(((var_150)+1)))])); var_148 += 1) {
						((i) = ((colidx[((unsigned int)((var_148)))])));
						(((x[((unsigned int)((i)))])) = (((x[((unsigned int)((i)))]))+((a[((unsigned int)((var_148)))]))));
						if(((((mark[((unsigned int)((i)))]))==0)&&<?>Unhandled Type of Call Target</?>)) {
							(((mark[((unsigned int)((i)))])) = 1);
							((nzrow) = ((nzrow)+1));
							(((nzloc[((unsigned int)((nzrow)))])) = (i));
						};
					};
					((k) = ((jajp1)+(((int)(ceil((((double)((((rowstr[((unsigned int)(((var_150)+1)))]))-(jajp1))))/((double)(1))))))*1)));
				};
				{
					for(int var_149 = 1; var_149 < ((nzrow)+1); var_149 += 1) {
						((i) = ((nzloc[((unsigned int)((var_149)))])));
						(((mark[((unsigned int)((i)))])) = 0);
						((xi) = ((x[((unsigned int)((i)))])));
						(((x[((unsigned int)((i)))])) = 0.0);
						if(((xi)!=0.0)) {
							((nza) = ((nza)+1));
							(((a[((unsigned int)((nza)))])) = (xi));
							(((colidx[((unsigned int)((nza)))])) = (i));
						};
					};
					((k) = (1+(((int)(ceil((((double)((((nzrow)+1)-1)))/((double)(1))))))*1)));
				};
				((jajp1) = ((rowstr[((unsigned int)(((var_150)+1)))])));
				(((rowstr[((unsigned int)(((var_150)+1)))])) = ((nza)+((rowstr[((unsigned int)(1))]))));
			};
			((j) = (1+(((int)(ceil((((double)((((nrows)+1)-1)))/((double)(1))))))*1)));
		};
	}
}


// start code fragment :: Definition of makea //
void makea(struct __insieme_globals var_46, int n, int nz, double* a, int* colidx, int* rowstr, int nonzer, int firstrow, int lastrow, int firstcol, int lastcol, double rcond, int* arow, int* acol, double* aelt, double* v, int* iv, double shift) {
	{
		int i = 0;
		int nnza = 0;
		int iouter = 0;
		int ivelt = 0;
		int ivelt1 = 0;
		int irow = 0;
		int nzv = 0;
		double size = 0.0;
		double ratio = 0.0;
		double scale = 0.0;
		int jcol = 0;
		((size) = 1.0);
		((ratio) = pow(rcond, (1.0/((double)(n)))));
		((nnza) = 0);
		{
			for(int var_75 = 1; var_75 < (n+1); var_75 += 1) {
				(((colidx[((unsigned int)((n+(var_75))))])) = 0);
			};
			((i) = (1+(((int)(ceil((((double)(((n+1)-1)))/((double)(1))))))*1)));
		};
		{
			for(int var_113 = 1; var_113 < (n+1); var_113 += 1) {
				((nzv) = nonzer);
				sprnvc(&var_46, n, (nzv), v, iv, (&(colidx[((unsigned int)(0))])), (&(colidx[((unsigned int)(n))])));
				vecset(n, v, iv, (&nzv), (var_113), 0.5);
				{
					for(int var_112 = 1; var_112 < ((nzv)+1); var_112 += 1) {
						((jcol) = ((iv[((unsigned int)((var_112)))])));
						if((((jcol)>=firstcol)&&<?>Unhandled Type of Call Target</?>)) {
							((scale) = ((size)*((v[((unsigned int)((var_112)))]))));
							{
								for(int var_108 = 1; var_108 < ((nzv)+1); var_108 += 1) {
									((irow) = ((iv[((unsigned int)((var_108)))])));
									if((((irow)>=firstrow)&&<?>Unhandled Type of Call Target</?>)) {
										((nnza) = ((nnza)+1));
										if(((nnza)>nz)) {
											printf("Space for matrix elements exceeded in", 0);
											printf("nnza, nzmax = %d, %d\n", (nnza), nz);
											printf("iouter = %d\n", (var_113));
											exit(1);
										};
										(((acol[((unsigned int)((nnza)))])) = (jcol));
										(((arow[((unsigned int)((nnza)))])) = (irow));
										(((aelt[((unsigned int)((nnza)))])) = (((v[((unsigned int)((var_108)))]))*(scale)));
									};
								};
								((ivelt1) = (1+(((int)(ceil((((double)((((nzv)+1)-1)))/((double)(1))))))*1)));
							};
						};
					};
					((ivelt) = (1+(((int)(ceil((((double)((((nzv)+1)-1)))/((double)(1))))))*1)));
				};
				((size) = ((size)*(ratio)));
			};
			((iouter) = (1+(((int)(ceil((((double)(((n+1)-1)))/((double)(1))))))*1)));
		};
		{
			for(int var_117 = firstrow; var_117 < (lastrow+1); var_117 += 1) {
				if((((var_117)>=firstcol)&&<?>Unhandled Type of Call Target</?>)) {
					((iouter) = (n+(var_117)));
					((nnza) = ((nnza)+1));
					if(((nnza)>nz)) {
						printf("Space for matrix elements exceeded in makea\n", 0);
						printf("nnza, nzmax = %d, %d\n", (nnza), nz);
						printf("iouter = %d\n", (iouter));
						exit(1);
					};
					(((acol[((unsigned int)((nnza)))])) = (var_117));
					(((arow[((unsigned int)((nnza)))])) = (var_117));
					(((aelt[((unsigned int)((nnza)))])) = (rcond-shift));
				};
			};
			((i) = (firstrow+(((int)(ceil((((double)(((lastrow+1)-firstrow)))/((double)(1))))))*1)));
		};
		sparse(a, colidx, rowstr, n, arow, acol, aelt, firstrow, lastrow, v, (&(iv[((unsigned int)(0))])), (&(iv[((unsigned int)(n))])), (nnza));
	}
}


// start code fragment :: Prototype for external function: sqrt ... type: ((real<8>)->real<8>) //
double sqrt(double);

// start code fragment :: Definition of conj_grad //
void conj_grad(struct __insieme_globals var_156, int* colidx, int* rowstr, double* x, double* z, double* a, double* p, double* q, double* r, double* w, double* rnorm) {
	{
		int i = 0;
		int j = 0;
		int k = 0;
		int cgit = 0;
		int cgitmax = 25;
		((*(&((var_156).rho))) = 0.0);
		{
			for(int var_172 = 1; var_172 < (((*(&((var_156).naa)))+1)+1); var_172 += 1) {
				(((q[((unsigned int)((var_172)))])) = 0.0);
				(((z[((unsigned int)((var_172)))])) = 0.0);
				(((r[((unsigned int)((var_172)))])) = ((x[((unsigned int)((var_172)))])));
				(((p[((unsigned int)((var_172)))])) = ((r[((unsigned int)((var_172)))])));
				(((w[((unsigned int)((var_172)))])) = 0.0);
			};
			((j) = (1+(((int)(ceil((((double)(((((*(&((var_156).naa)))+1)+1)-1)))/((double)(1))))))*1)));
		};
		{
			for(int var_173 = 1; var_173 < ((((*(&((var_156).lastcol)))-(*(&((var_156).firstcol))))+1)+1); var_173 += 1) {
				((*(&((var_156).rho))) = ((*(&((var_156).rho)))+(((x[((unsigned int)((var_173)))]))*((x[((unsigned int)((var_173)))])))));
			};
			((j) = (1+(((int)(ceil((((double)((((((*(&((var_156).lastcol)))-(*(&((var_156).firstcol))))+1)+1)-1)))/((double)(1))))))*1)));
		};
		{
			for(int var_182 = 1; var_182 < ((cgitmax)+1); var_182 += 1) {
				{
					((*(&((var_156).rho0))) = (*(&((var_156).rho))));
					((*(&((var_156).d))) = 0.0);
					((*(&((var_156).rho))) = 0.0);
				};
				{
					for(int var_175 = 1; var_175 < ((((*(&((var_156).lastrow)))-(*(&((var_156).firstrow))))+1)+1); var_175 += 1) {
						((*(&((var_156).sum))) = 0.0);
						{
							for(int var_174 = ((rowstr[((unsigned int)((var_175)))])); var_174 < ((rowstr[((unsigned int)(((var_175)+1)))])); var_174 += 1) {
								((*(&((var_156).sum))) = ((*(&((var_156).sum)))+(((a[((unsigned int)((var_174)))]))*((p[((unsigned int)(((colidx[((unsigned int)((var_174)))]))))])))));
							};
							((k) = (((rowstr[((unsigned int)((var_175)))]))+(((int)(ceil((((double)((((rowstr[((unsigned int)(((var_175)+1)))]))-((rowstr[((unsigned int)((var_175)))])))))/((double)(1))))))*1)));
						};
						(((w[((unsigned int)((var_175)))])) = (*(&((var_156).sum))));
					};
					((j) = (1+(((int)(ceil((((double)((((((*(&((var_156).lastrow)))-(*(&((var_156).firstrow))))+1)+1)-1)))/((double)(1))))))*1)));
				};
				{
					for(int var_176 = 1; var_176 < ((((*(&((var_156).lastcol)))-(*(&((var_156).firstcol))))+1)+1); var_176 += 1) {
						(((q[((unsigned int)((var_176)))])) = ((w[((unsigned int)((var_176)))])));
					};
					((j) = (1+(((int)(ceil((((double)((((((*(&((var_156).lastcol)))-(*(&((var_156).firstcol))))+1)+1)-1)))/((double)(1))))))*1)));
				};
				{
					for(int var_177 = 1; var_177 < ((((*(&((var_156).lastcol)))-(*(&((var_156).firstcol))))+1)+1); var_177 += 1) {
						(((w[((unsigned int)((var_177)))])) = 0.0);
					};
					((j) = (1+(((int)(ceil((((double)((((((*(&((var_156).lastcol)))-(*(&((var_156).firstcol))))+1)+1)-1)))/((double)(1))))))*1)));
				};
				{
					for(int var_178 = 1; var_178 < ((((*(&((var_156).lastcol)))-(*(&((var_156).firstcol))))+1)+1); var_178 += 1) {
						((*(&((var_156).d))) = ((*(&((var_156).d)))+(((p[((unsigned int)((var_178)))]))*((q[((unsigned int)((var_178)))])))));
					};
					((j) = (1+(((int)(ceil((((double)((((((*(&((var_156).lastcol)))-(*(&((var_156).firstcol))))+1)+1)-1)))/((double)(1))))))*1)));
				};
				((*(&((var_156).alpha))) = ((*(&((var_156).rho0)))/(*(&((var_156).d)))));
				{
					for(int var_179 = 1; var_179 < ((((*(&((var_156).lastcol)))-(*(&((var_156).firstcol))))+1)+1); var_179 += 1) {
						(((z[((unsigned int)((var_179)))])) = (((z[((unsigned int)((var_179)))]))+((*(&((var_156).alpha)))*((p[((unsigned int)((var_179)))])))));
						(((r[((unsigned int)((var_179)))])) = (((r[((unsigned int)((var_179)))]))-((*(&((var_156).alpha)))*((q[((unsigned int)((var_179)))])))));
					};
					((j) = (1+(((int)(ceil((((double)((((((*(&((var_156).lastcol)))-(*(&((var_156).firstcol))))+1)+1)-1)))/((double)(1))))))*1)));
				};
				{
					for(int var_180 = 1; var_180 < ((((*(&((var_156).lastcol)))-(*(&((var_156).firstcol))))+1)+1); var_180 += 1) {
						((*(&((var_156).rho))) = ((*(&((var_156).rho)))+(((r[((unsigned int)((var_180)))]))*((r[((unsigned int)((var_180)))])))));
					};
					((j) = (1+(((int)(ceil((((double)((((((*(&((var_156).lastcol)))-(*(&((var_156).firstcol))))+1)+1)-1)))/((double)(1))))))*1)));
				};
				((*(&((var_156).beta))) = ((*(&((var_156).rho)))/(*(&((var_156).rho0)))));
				{
					for(int var_181 = 1; var_181 < ((((*(&((var_156).lastcol)))-(*(&((var_156).firstcol))))+1)+1); var_181 += 1) {
						(((p[((unsigned int)((var_181)))])) = (((r[((unsigned int)((var_181)))]))+((*(&((var_156).beta)))*((p[((unsigned int)((var_181)))])))));
					};
					((j) = (1+(((int)(ceil((((double)((((((*(&((var_156).lastcol)))-(*(&((var_156).firstcol))))+1)+1)-1)))/((double)(1))))))*1)));
				};
			};
			((cgit) = (1+(((int)(ceil((((double)((((cgitmax)+1)-1)))/((double)(1))))))*1)));
		};
		((*(&((var_156).sum))) = 0.0);
		{
			for(int var_184 = 1; var_184 < ((((*(&((var_156).lastrow)))-(*(&((var_156).firstrow))))+1)+1); var_184 += 1) {
				((*(&((var_156).d))) = 0.0);
				{
					for(int var_183 = ((rowstr[((unsigned int)((var_184)))])); var_183 < ((((rowstr[((unsigned int)(((var_184)+1)))]))-1)+1); var_183 += 1) {
						((*(&((var_156).d))) = ((*(&((var_156).d)))+(((a[((unsigned int)((var_183)))]))*((z[((unsigned int)(((colidx[((unsigned int)((var_183)))]))))])))));
					};
					((k) = (((rowstr[((unsigned int)((var_184)))]))+(((int)(ceil((((double)((((((rowstr[((unsigned int)(((var_184)+1)))]))-1)+1)-((rowstr[((unsigned int)((var_184)))])))))/((double)(1))))))*1)));
				};
				(((w[((unsigned int)((var_184)))])) = (*(&((var_156).d))));
			};
			((j) = (1+(((int)(ceil((((double)((((((*(&((var_156).lastrow)))-(*(&((var_156).firstrow))))+1)+1)-1)))/((double)(1))))))*1)));
		};
		{
			for(int var_185 = 1; var_185 < ((((*(&((var_156).lastcol)))-(*(&((var_156).firstcol))))+1)+1); var_185 += 1) {
				(((r[((unsigned int)((var_185)))])) = ((w[((unsigned int)((var_185)))])));
			};
			((j) = (1+(((int)(ceil((((double)((((((*(&((var_156).lastcol)))-(*(&((var_156).firstcol))))+1)+1)-1)))/((double)(1))))))*1)));
		};
		{
			for(int var_186 = 1; var_186 < ((((*(&((var_156).lastcol)))-(*(&((var_156).firstcol))))+1)+1); var_186 += 1) {
				((*(&((var_156).d))) = (((x[((unsigned int)((var_186)))]))-((r[((unsigned int)((var_186)))]))));
				((*(&((var_156).sum))) = ((*(&((var_156).sum)))+((*(&((var_156).d)))*(*(&((var_156).d))))));
			};
			((j) = (1+(((int)(ceil((((double)((((((*(&((var_156).lastcol)))-(*(&((var_156).firstcol))))+1)+1)-1)))/((double)(1))))))*1)));
		};
		{
			(((rnorm[0])) = sqrt((*(&((var_156).sum)))));
		};
	}
}


// start code fragment :: Definition of timer_clear //
void timer_clear(struct __insieme_globals var_192, int n) {
	{
		((((((var_192).elapsed))[((unsigned int)(n))])) = 0.0);
	}
}


// start code fragment :: type_declaration_timeval //
struct timeval { 
    long tv_sec;
    long tv_usec;
};

// start code fragment :: type_declaration_timezone //
struct timezone { 
    int tz_minuteswest;
    int tz_dsttime;
};

// start code fragment :: Prototype for external function: gettimeofday ... type: ((ref<array<struct<tv_sec:int<8>,tv_usec:int<8>>,1>>,ref<array<struct<tz_minuteswest:int<4>,tz_dsttime:int<4>>,1>>)->int<4>) //
int gettimeofday(struct timeval*, struct timezone*);

// start code fragment :: Definition of wtime //
void wtime(struct __insieme_globals var_199, double* t) {
	{
		struct timeval tv;
		gettimeofday((&tv), null);
		if(((*(&((var_199).sec)))<0)) {
			((*(&((var_199).sec))) = ((int)((*(&((tv).tv_sec))))));
		};
		(((t[0])) = (((double)(((*(&((tv).tv_sec)))-((long)((*(&((var_199).sec))))))))+(1.0e-6*((double)((*(&((tv).tv_usec))))))));
	}
}


// start code fragment :: Definition of elapsed_time //
double elapsed_time(struct __insieme_globals var_197) {
	{
		double t = 0.0;
		wtime(&var_197, (&t));
		return (t);;
	}
}


// start code fragment :: Definition of timer_start //
void timer_start(struct __insieme_globals var_195, int n) {
	{
		((((((var_195).start))[((unsigned int)(n))])) = elapsed_time(&var_195));
	}
}


// start code fragment :: Definition of timer_stop //
void timer_stop(struct __insieme_globals var_208, int n) {
	{
		double t = 0.0;
		double now = 0.0;
		((now) = elapsed_time(&var_208));
		((t) = ((now)-(((((var_208).start))[((unsigned int)(n))]))));
		((((((var_208).elapsed))[((unsigned int)(n))])) = ((((((var_208).elapsed))[((unsigned int)(n))]))+(t)));
	}
}


// start code fragment :: Definition of timer_read //
double timer_read(struct __insieme_globals var_213, int n) {
	{
		return (((((var_213).elapsed))[((unsigned int)(n))]));;
	}
}


// start code fragment :: Prototype for external function: fabs ... type: ((real<8>)->real<8>) //
double fabs(double);

// start code fragment :: Definition of c_print_results //
void c_print_results(char* name, char class, int n1, int n2, int n3, int niter, int nthreads, double t, double mops, char* optype, int passed_verification, char* npbversion, char* compiletime, char* cc, char* clink, char* c_lib, char* c_inc, char* cflags, char* clinkflags, char* rand) {
	{
		char* evalue = "1000";
		printf("\n\n %s Benchmark Completed\n", (name));
		printf(" Class           =                        %c\n", ((int)(class)));
		if(((n2==0)&&<?>Unhandled Type of Call Target</?>)) {
			printf(" Size            =             %12d\n", n1);
		} else {
			printf(" Size            =              %3dx%3dx%3d\n", n1, n2, n3);
		};
		printf(" Iterations      =             %12d\n", niter);
		printf(" Threads         =             %12d\n", nthreads);
		printf(" Time in seconds =             %12.2f\n", 0.0);
		printf(" Mop/s total     =             %12.2f\n", 0.0);
		printf(" Operation type  = %24s\n", (optype));
		if(((bool)(passed_verification))) {
			printf(" Verification    =               SUCCESSFUL\n", 0);
		} else {
			printf(" Verification    =             UNSUCCESSFUL\n", 0);
		};
		printf(" Version         =             %12s\n", (npbversion));
		printf(" Compile date    =             %12s\n", (compiletime));
		printf("\n Compile options:\n", 0);
		printf("    CC           = %s\n", (cc));
		printf("    CLINK        = %s\n", (clink));
		printf("    C_LIB        = %s\n", (c_lib));
		printf("    C_INC        = %s\n", (c_inc));
		printf("    CFLAGS       = %s\n", (cflags));
		printf("    CLINKFLAGS   = %s\n", (clinkflags));
		printf("    RAND         = %s\n", (rand));
	}
}


// start code fragment :: Definition of main //
int main(int argc, char** argv) {
	{
		struct __insieme_globals* var_1 = malloc(sizeof(struct __insieme_globals));
		((*(&((*var_1).naa))) = 0);
		((*(&((*var_1).nzz))) = 0);
		((*(&((*var_1).firstrow))) = 0);
		((*(&((*var_1).lastrow))) = 0);
		((*(&((*var_1).firstcol))) = 0);
		((*(&((*var_1).lastcol))) = 0);
		((*(&((*var_1).amult))) = 0.0);
		((*(&((*var_1).tran))) = 0.0);
		((*(&((*var_1).d))) = 0.0);
		((*(&((*var_1).sum))) = 0.0);
		((*(&((*var_1).rho))) = 0.0);
		((*(&((*var_1).rho0))) = 0.0);
		((*(&((*var_1).alpha))) = 0.0);
		((*(&((*var_1).beta))) = 0.0);
		((*(&((*var_1).sec))) = (((int)(0))-1));
		int i = 0;
		int j = 0;
		int k = 0;
		int it = 0;
		int nthreads = 1;
		double zeta = 0.0;
		double rnorm = 0.0;
		double norm_temp11 = 0.0;
		double norm_temp12 = 0.0;
		double t = 0.0;
		double mflops = 0.0;
		char class = '\0';
		int verified = 0;
		double zeta_verify_value = 0.0;
		double epsilon = 0.0;
		((*(&((*var_1).firstrow))) = 1);
		((*(&((*var_1).lastrow))) = 7000);
		((*(&((*var_1).firstcol))) = 1);
		((*(&((*var_1).lastcol))) = 7000);
		if(((((7000==1400)&&<?>Unhandled Type of Call Target</?>)&&<?>Unhandled Type of Call Target</?>)&&<?>Unhandled Type of Call Target</?>)) {
			((class) = 'S');
			((zeta_verify_value) = 8.5971775078648);
		} else if(((((7000==7000)&&<?>Unhandled Type of Call Target</?>)&&<?>Unhandled Type of Call Target</?>)&&<?>Unhandled Type of Call Target</?>)) {
			((class) = 'W');
			((zeta_verify_value) = 10.362595087124);
		} else if(((((7000==14000)&&<?>Unhandled Type of Call Target</?>)&&<?>Unhandled Type of Call Target</?>)&&<?>Unhandled Type of Call Target</?>)) {
			((class) = 'A');
			((zeta_verify_value) = 17.130235054029);
		} else if(((((7000==75000)&&<?>Unhandled Type of Call Target</?>)&&<?>Unhandled Type of Call Target</?>)&&<?>Unhandled Type of Call Target</?>)) {
			((class) = 'B');
			((zeta_verify_value) = 22.712745482631);
		} else if(((((7000==150000)&&<?>Unhandled Type of Call Target</?>)&&<?>Unhandled Type of Call Target</?>)&&<?>Unhandled Type of Call Target</?>)) {
			((class) = 'C');
			((zeta_verify_value) = 28.973605592845);
		} else {
			((class) = 'U');
		};
		printf("\n\n NAS Parallel Benchmarks 2.3 OpenMP C version - CG Benchmark\n", 0);
		printf(" Size: %10d\n", 7000);
		printf(" Iterations: %5d\n", 15);
		((*(&((*var_1).naa))) = 7000);
		((*(&((*var_1).nzz))) = (((7000*(8+1))*(8+1))+(7000*(8+2))));
		((*(&((*var_1).tran))) = 314159265.0);
		((*(&((*var_1).amult))) = 1220703125.0);
		((zeta) = randlc(((&((*var_1).tran))), (*(&((*var_1).amult)))));
		makea(var_1, (*(&((*var_1).naa))), (*(&((*var_1).nzz))), (((*var_1).a)), (((*var_1).colidx)), (((*var_1).rowstr)), 8, (*(&((*var_1).firstrow))), (*(&((*var_1).lastrow))), (*(&((*var_1).firstcol))), (*(&((*var_1).lastcol))), 1.0e-1, (((*var_1).arow)), (((*var_1).acol)), (((*var_1).aelt)), (((*var_1).v)), (((*var_1).iv)), 12.0);
		{
			{
				for(int var_154 = 1; var_154 < ((((*(&((*var_1).lastrow)))-(*(&((*var_1).firstrow))))+1)+1); var_154 += 1) {
					{
						for(int var_153 = (((((*var_1).rowstr))[((unsigned int)((var_154)))])); var_153 < (((((*var_1).rowstr))[((unsigned int)(((var_154)+1)))])); var_153 += 1) {
							((((((*var_1).colidx))[((unsigned int)((var_153)))])) = (((((((*var_1).colidx))[((unsigned int)((var_153)))]))-(*(&((*var_1).firstcol))))+1));
						};
						((k) = ((((((*var_1).rowstr))[((unsigned int)((var_154)))]))+(((int)(ceil((((double)(((((((*var_1).rowstr))[((unsigned int)(((var_154)+1)))]))-(((((*var_1).rowstr))[((unsigned int)((var_154)))])))))/((double)(1))))))*1)));
					};
				};
				((j) = (1+(((int)(ceil((((double)((((((*(&((*var_1).lastrow)))-(*(&((*var_1).firstrow))))+1)+1)-1)))/((double)(1))))))*1)));
			};
			{
				for(int var_155 = 1; var_155 < ((7000+1)+1); var_155 += 1) {
					((((((*var_1).x))[((unsigned int)((var_155)))])) = 1.0);
				};
				((i) = (1+(((int)(ceil((((double)((((7000+1)+1)-1)))/((double)(1))))))*1)));
			};
			((zeta) = 0.0);
			{
				for(int var_190 = 1; var_190 < (1+1); var_190 += 1) {
					conj_grad(var_1, (((*var_1).colidx)), (((*var_1).rowstr)), (((*var_1).x)), (((*var_1).z)), (((*var_1).a)), (((*var_1).p)), (((*var_1).q)), (((*var_1).r)), (((*var_1).w)), (&rnorm));
					{
						((norm_temp11) = 0.0);
						((norm_temp12) = 0.0);
					};
					{
						for(int var_188 = 1; var_188 < ((((*(&((*var_1).lastcol)))-(*(&((*var_1).firstcol))))+1)+1); var_188 += 1) {
							((norm_temp11) = ((norm_temp11)+((((((*var_1).x))[((unsigned int)((var_188)))]))*(((((*var_1).z))[((unsigned int)((var_188)))])))));
							((norm_temp12) = ((norm_temp12)+((((((*var_1).z))[((unsigned int)((var_188)))]))*(((((*var_1).z))[((unsigned int)((var_188)))])))));
						};
						((j) = (1+(((int)(ceil((((double)((((((*(&((*var_1).lastcol)))-(*(&((*var_1).firstcol))))+1)+1)-1)))/((double)(1))))))*1)));
					};
					((norm_temp12) = (1.0/sqrt((norm_temp12))));
					{
						for(int var_189 = 1; var_189 < ((((*(&((*var_1).lastcol)))-(*(&((*var_1).firstcol))))+1)+1); var_189 += 1) {
							((((((*var_1).x))[((unsigned int)((var_189)))])) = ((norm_temp12)*(((((*var_1).z))[((unsigned int)((var_189)))]))));
						};
						((j) = (1+(((int)(ceil((((double)((((((*(&((*var_1).lastcol)))-(*(&((*var_1).firstcol))))+1)+1)-1)))/((double)(1))))))*1)));
					};
				};
				((it) = (1+(((int)(ceil((((double)(((1+1)-1)))/((double)(1))))))*1)));
			};
			{
				for(int var_191 = 1; var_191 < ((7000+1)+1); var_191 += 1) {
					((((((*var_1).x))[((unsigned int)((var_191)))])) = 1.0);
				};
				((i) = (1+(((int)(ceil((((double)((((7000+1)+1)-1)))/((double)(1))))))*1)));
			};
			((zeta) = 0.0);
		};
		timer_clear(var_1, 1);
		timer_start(var_1, 1);
		{
			{
				for(int var_207 = 1; var_207 < (15+1); var_207 += 1) {
					conj_grad(var_1, (((*var_1).colidx)), (((*var_1).rowstr)), (((*var_1).x)), (((*var_1).z)), (((*var_1).a)), (((*var_1).p)), (((*var_1).q)), (((*var_1).r)), (((*var_1).w)), (&rnorm));
					{
						((norm_temp11) = 0.0);
						((norm_temp12) = 0.0);
					};
					{
						for(int var_205 = 1; var_205 < ((((*(&((*var_1).lastcol)))-(*(&((*var_1).firstcol))))+1)+1); var_205 += 1) {
							((norm_temp11) = ((norm_temp11)+((((((*var_1).x))[((unsigned int)((var_205)))]))*(((((*var_1).z))[((unsigned int)((var_205)))])))));
							((norm_temp12) = ((norm_temp12)+((((((*var_1).z))[((unsigned int)((var_205)))]))*(((((*var_1).z))[((unsigned int)((var_205)))])))));
						};
						((j) = (1+(((int)(ceil((((double)((((((*(&((*var_1).lastcol)))-(*(&((*var_1).firstcol))))+1)+1)-1)))/((double)(1))))))*1)));
					};
					{
						((norm_temp12) = (1.0/sqrt((norm_temp12))));
						((zeta) = (12.0+(1.0/(norm_temp11))));
					};
					{
						if(((var_207)==1)) {
							printf("   iteration           ||r||                 zeta\n", 0);
						};
						printf("    %5d       %20.14e%20.13e\n", (var_207), (rnorm), (zeta));
					};
					{
						for(int var_206 = 1; var_206 < ((((*(&((*var_1).lastcol)))-(*(&((*var_1).firstcol))))+1)+1); var_206 += 1) {
							((((((*var_1).x))[((unsigned int)((var_206)))])) = ((norm_temp12)*(((((*var_1).z))[((unsigned int)((var_206)))]))));
						};
						((j) = (1+(((int)(ceil((((double)((((((*(&((*var_1).lastcol)))-(*(&((*var_1).firstcol))))+1)+1)-1)))/((double)(1))))))*1)));
					};
				};
				((it) = (1+(((int)(ceil((((double)(((15+1)-1)))/((double)(1))))))*1)));
			};
		};
		timer_stop(var_1, 1);
		((t) = timer_read(var_1, 1));
		printf(" Benchmark completed\n", 0);
		((epsilon) = 1.0e-10);
		if((((int)((class)))!='U')) {
			if((fabs(((zeta)-(zeta_verify_value)))<=(epsilon))) {
				((verified) = 1);
				printf(" VERIFICATION SUCCESSFUL\n", 0);
				printf(" Zeta is    %20.12e\n", (zeta));
				printf(" Error is   %20.12e\n", ((zeta)-(zeta_verify_value)));
			} else {
				((verified) = 0);
				printf(" VERIFICATION FAILED\n", 0);
				printf(" Zeta                %20.12e\n", (zeta));
				printf(" The correct zeta is %20.12e\n", (zeta_verify_value));
			};
		} else {
			((verified) = 0);
			printf(" Problem size unknown\n", 0);
			printf(" NO VERIFICATION PERFORMED\n", 0);
		};
		if(((t)!=0.0)) {
			((mflops) = (((((2.0*((double)(15)))*((double)(7000)))*(((3.0+((double)((8*(8+1)))))+(25.0*(5.0+((double)((8*(8+1)))))))+3.0))/(t))/1000000.0));
		} else {
			((mflops) = 0.0);
		};
		c_print_results("CG", (class), 7000, 0, 0, 15, (nthreads), (t), (mflops), "          floating point", (verified), "2.3", "02 Dec 2010", "cc", "cc", "-lm", "-I../common", "-O3 ", "-lm", "randdp");
	}
}

