// --- Generated Inspire Code ---
#include <alloca.h>
#include <stddef.h>
#include <stdlib.h>
#include <runtime.h>
#define bool int
#define true 1
#define false 0
#define null 0

// start code fragment :: array type definition of __insieme_type_1 <=> array<char,1> //
typedef struct ___insieme_type_1 { 
    char* data;
    unsigned size[1];
} __insieme_type_1;

// start code fragment :: array type definition of __insieme_type_0 <=> array<array<char,1>,1> //
typedef struct ___insieme_type_0 { 
    __insieme_type_1* data;
    unsigned size[1];
} __insieme_type_0;

// start code fragment :: Prototype for external function: strlen ... type: ((ref<array<char,1>>)->uint<8>) //
unsigned long strlen(char*);
static unsigned long strlen_wrap(void* _closure, __insieme_type_1* var_241) { return strlen(((char*)((*(var_241)).data))); }

// start code fragment :: vector_type_declaration of __insieme_type_3 <=> vector<int<4>,637001> //
typedef struct ___insieme_type_3 { 
    int data[637001];
} __insieme_type_3;

// A constructor initializing a vector of the type __insieme_type_3 uniformly
static inline __insieme_type_3 __insieme_type_3_init_uniform(int value) {
	__insieme_type_3 res;
	for (int i=0; i<637001;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_4 <=> vector<int<4>,7002> //
typedef struct ___insieme_type_4 { 
    int data[7002];
} __insieme_type_4;

// A constructor initializing a vector of the type __insieme_type_4 uniformly
static inline __insieme_type_4 __insieme_type_4_init_uniform(int value) {
	__insieme_type_4 res;
	for (int i=0; i<7002;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_5 <=> vector<int<4>,14002> //
typedef struct ___insieme_type_5 { 
    int data[14002];
} __insieme_type_5;

// A constructor initializing a vector of the type __insieme_type_5 uniformly
static inline __insieme_type_5 __insieme_type_5_init_uniform(int value) {
	__insieme_type_5 res;
	for (int i=0; i<14002;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_6 <=> vector<real<8>,7002> //
typedef struct ___insieme_type_6 { 
    double data[7002];
} __insieme_type_6;

// A constructor initializing a vector of the type __insieme_type_6 uniformly
static inline __insieme_type_6 __insieme_type_6_init_uniform(double value) {
	__insieme_type_6 res;
	for (int i=0; i<7002;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_7 <=> vector<real<8>,637001> //
typedef struct ___insieme_type_7 { 
    double data[637001];
} __insieme_type_7;

// A constructor initializing a vector of the type __insieme_type_7 uniformly
static inline __insieme_type_7 __insieme_type_7_init_uniform(double value) {
	__insieme_type_7 res;
	for (int i=0; i<637001;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_8 <=> vector<real<8>,7003> //
typedef struct ___insieme_type_8 { 
    double data[7003];
} __insieme_type_8;

// A constructor initializing a vector of the type __insieme_type_8 uniformly
static inline __insieme_type_8 __insieme_type_8_init_uniform(double value) {
	__insieme_type_8 res;
	for (int i=0; i<7003;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_9 <=> vector<real<8>,64> //
typedef struct ___insieme_type_9 { 
    double data[64];
} __insieme_type_9;

// A constructor initializing a vector of the type __insieme_type_9 uniformly
static inline __insieme_type_9 __insieme_type_9_init_uniform(double value) {
	__insieme_type_9 res;
	for (int i=0; i<64;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: type_declaration___insieme_globals //
struct __insieme_globals { 
    int naa;
    int nzz;
    int firstrow;
    int lastrow;
    int firstcol;
    int lastcol;
    __insieme_type_3 colidx;
    __insieme_type_4 rowstr;
    __insieme_type_5 iv;
    __insieme_type_3 arow;
    __insieme_type_3 acol;
    __insieme_type_6 v;
    __insieme_type_7 aelt;
    __insieme_type_7 a;
    __insieme_type_8 x;
    __insieme_type_8 z;
    __insieme_type_8 p;
    __insieme_type_8 q;
    __insieme_type_8 r;
    __insieme_type_8 w;
    double amult;
    double tran;
    double d;
    double sum;
    double rho;
    double rho0;
    double alpha;
    double beta;
    __insieme_type_9 start;
    __insieme_type_9 elapsed;
    int sec;
};

// start code fragment :: Prototype for external function: printf ... type: ((ref<array<char,1>>,var_list)->int<4>) //
int printf(char*, ...);

// start code fragment :: array type definition of __insieme_type_14 <=> array<real<8>,1> //
typedef struct ___insieme_type_14 { 
    double* data;
    unsigned size[1];
} __insieme_type_14;

// start code fragment :: Definition of randlc ... type: ((ref<array<real<8>,1>>,real<8>)->real<8>) //
double randlc(__insieme_type_14* x, double a){
	double t1 = 0.0;
	double t2 = 0.0;
	double t3 = 0.0;
	double t4 = 0.0;
	double a1 = 0.0;
	double a2 = 0.0;
	double x1 = 0.0;
	double x2 = 0.0;
	double z = 0.0;
	((t1) = (((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*a));
	((a1) = ((double)(((int)(t1)))));
	((a2) = (a-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(a1))));
	((t1) = (((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*(((*x).data[0]))));
	((x1) = ((double)(((int)(t1)))));
	((x2) = ((((*x).data[0]))-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(x1))));
	((t1) = (((a1)*(x2))+((a2)*(x1))));
	((t2) = ((double)(((int)((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*(t1)))))));
	((z) = ((t1)-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(t2))));
	((t3) = ((((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(z))+((a2)*(x2))));
	((t4) = ((double)(((int)(((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5))*(t3)))))));
	((((*x).data[0])) = ((t3)-((((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0))*(t4))));
	return ((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5))*(((*x).data[0])));
}
static double randlc_wrap(void* _closure, __insieme_type_14* x, double a) { return randlc(x, a); }

// start code fragment :: array type definition of __insieme_type_16 <=> array<int<4>,1> //
typedef struct ___insieme_type_16 { 
    int* data;
    unsigned size[1];
} __insieme_type_16;

// start code fragment :: Prototype for external function: pow ... type: ((real<8>,real<8>)->real<8>) //
double pow(double, double);
static double pow_wrap(void* _closure, double var_242, double var_243) { return pow(var_242, var_243); }

// start code fragment :: Prototype for external function: ceil ... type: ((real<8>)->real<8>) //
double ceil(double);
static double ceil_wrap(void* _closure, double var_244) { return ceil(var_244); }

// start code fragment :: Definition of icnvrt ... type: ((real<8>,int<4>)->int<4>) //
int icnvrt(double x, int ipwr2) { return ((int)((((double)(ipwr2))*x))); }
static int icnvrt_wrap(void* _closure, double x, int ipwr2) { return icnvrt(x, ipwr2); }

// start code fragment :: Definition of sprnvc ... type: ((ref<struct<naa:int<4>,nzz:int<4>,firstrow:int<4>,lastrow:int<4>,firstcol:int<4>,lastcol:int<4>,colidx:vector<int<4>,637001>,rowstr:vector<int<4>,7002>,iv:vector<int<4>,14002>,arow:vector<int<4>,637001>,acol:vector<int<4>,637001>,v:vector<real<8>,7002>,aelt:vector<real<8>,637001>,a:vector<real<8>,637001>,x:vector<real<8>,7003>,z:vector<real<8>,7003>,p:vector<real<8>,7003>,q:vector<real<8>,7003>,r:vector<real<8>,7003>,w:vector<real<8>,7003>,amult:real<8>,tran:real<8>,d:real<8>,sum:real<8>,rho:real<8>,rho0:real<8>,alpha:real<8>,beta:real<8>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,int<4>,int<4>,ref<array<real<8>,1>>,ref<array<int<4>,1>>,ref<array<int<4>,1>>,ref<array<int<4>,1>>)->unit) //
void sprnvc(struct __insieme_globals* var_76, int n, int nz, __insieme_type_14* v, __insieme_type_16* iv, __insieme_type_16* nzloc, __insieme_type_16* mark){
	int nn1 = 0;
	int nzrow = 0;
	int nzv = 0;
	int ii = 0;
	int i = 0;
	double vecelt = 0.0;
	double vecloc = 0.0;
	((nzv) = 0);
	((nzrow) = 0);
	((nn1) = 1);
	{
		((nn1) = (2*(nn1)));
		while(((nn1)<n))  { ((nn1) = (2*(nn1))); };
	};
	while(((nzv)<nz)) {
		((vecelt) = randlc((&((__insieme_type_14){(&((*var_76).tran)),{1}})), (*(&((*var_76).amult)))));
		((vecloc) = randlc((&((__insieme_type_14){(&((*var_76).tran)),{1}})), (*(&((*var_76).amult)))));
		((i) = (icnvrt((vecloc), (nn1))+1));
		if(((i)>n)) { continue; };
		if(((((*mark).data[((unsigned int)((i)))]))==0)){
			((((*mark).data[((unsigned int)((i)))])) = 1);
			((nzrow) = ((nzrow)+1));
			((((*nzloc).data[((unsigned int)((nzrow)))])) = (i));
			((nzv) = ((nzv)+1));
			((((*v).data[((unsigned int)((nzv)))])) = (vecelt));
			((((*iv).data[((unsigned int)((nzv)))])) = (i));
		};
	};
	{
		for(int var_93 = 1; var_93 < ((nzrow)+1); var_93 += 1) {
			((i) = (((*nzloc).data[((unsigned int)((var_93)))])));
			((((*mark).data[((unsigned int)((i)))])) = 0);
		};
		((ii) = (1+(((int)(ceil((((double)((((nzrow)+1)-1)))/((double)(1))))))*1)));
	};
}
static void sprnvc_wrap(void* _closure, struct __insieme_globals* var_76, int n, int nz, __insieme_type_14* v, __insieme_type_16* iv, __insieme_type_16* nzloc, __insieme_type_16* mark) { sprnvc(var_76, n, nz, v, iv, nzloc, mark); }

// start code fragment :: Definition of vecset ... type: ((int<4>,ref<array<real<8>,1>>,ref<array<int<4>,1>>,ref<array<int<4>,1>>,int<4>,real<8>)->unit) //
void vecset(int n, __insieme_type_14* v, __insieme_type_16* iv, __insieme_type_16* nzv, int i, double val){
	int k = 0;
	int set = 0;
	((set) = 0);
	{
		for(int var_103 = 1; var_103 < ((((*nzv).data[0]))+1); var_103 += 1)  { if(((((*iv).data[((unsigned int)((var_103)))]))==i)){
			((((*v).data[((unsigned int)((var_103)))])) = val);
			((set) = 1);
		}; };
		((k) = (1+(((int)(ceil((((double)((((((*nzv).data[0]))+1)-1)))/((double)(1))))))*1)));
	};
	if(((set)==0)){
		((((*nzv).data[0])) = ((((*nzv).data[0]))+1));
		((((*v).data[((unsigned int)((((*nzv).data[0]))))])) = val);
		((((*iv).data[((unsigned int)((((*nzv).data[0]))))])) = i);
	};
}
static void vecset_wrap(void* _closure, int n, __insieme_type_14* v, __insieme_type_16* iv, __insieme_type_16* nzv, int i, double val) { vecset(n, v, iv, nzv, i, val); }

// start code fragment :: Prototype for external function: exit ... type: ((int<4>)->unit) //
void exit(int);
static void exit_wrap(void* _closure, int var_245) { exit(var_245); }

// start code fragment :: Definition of sparse ... type: ((ref<array<real<8>,1>>,ref<array<int<4>,1>>,ref<array<int<4>,1>>,int<4>,ref<array<int<4>,1>>,ref<array<int<4>,1>>,ref<array<real<8>,1>>,int<4>,int<4>,ref<array<real<8>,1>>,ref<array<int<4>,1>>,ref<array<int<4>,1>>,int<4>)->unit) //
void sparse(__insieme_type_14* a, __insieme_type_16* colidx, __insieme_type_16* rowstr, int n, __insieme_type_16* arow, __insieme_type_16* acol, __insieme_type_14* aelt, int firstrow, int lastrow, __insieme_type_14* x, __insieme_type_16* mark, __insieme_type_16* nzloc, int nnza){
	int nrows = 0;
	int i = 0;
	int j = 0;
	int jajp1 = 0;
	int nza = 0;
	int k = 0;
	int nzrow = 0;
	double xi = 0.0;
	((nrows) = ((lastrow-firstrow)+1));
	{
		for(int var_139 = 1; var_139 < (n+1); var_139 += 1) {
			((((*rowstr).data[((unsigned int)((var_139)))])) = 0);
			((((*mark).data[((unsigned int)((var_139)))])) = 0);
		};
		((j) = (1+(((int)(ceil((((double)(((n+1)-1)))/((double)(1))))))*1)));
	};
	((((*rowstr).data[((unsigned int)((n+1)))])) = 0);
	{
		for(int var_140 = 1; var_140 < (nnza+1); var_140 += 1) {
			((j) = ((((((*arow).data[((unsigned int)((var_140)))]))-firstrow)+1)+1));
			((((*rowstr).data[((unsigned int)((j)))])) = ((((*rowstr).data[((unsigned int)((j)))]))+1));
		};
		((nza) = (1+(((int)(ceil((((double)(((nnza+1)-1)))/((double)(1))))))*1)));
	};
	((((*rowstr).data[((unsigned int)(1))])) = 1);
	{
		for(int var_141 = 2; var_141 < (((nrows)+1)+1); var_141 += 1)  { ((((*rowstr).data[((unsigned int)((var_141)))])) = ((((*rowstr).data[((unsigned int)((var_141)))]))+(((*rowstr).data[((unsigned int)(((var_141)-1)))])))); };
		((j) = (2+(((int)(ceil((((double)(((((nrows)+1)+1)-2)))/((double)(1))))))*1)));
	};
	{
		for(int var_142 = 1; var_142 < (nnza+1); var_142 += 1) {
			((j) = (((((*arow).data[((unsigned int)((var_142)))]))-firstrow)+1));
			((k) = (((*rowstr).data[((unsigned int)((j)))])));
			((((*a).data[((unsigned int)((k)))])) = (((*aelt).data[((unsigned int)((var_142)))])));
			((((*colidx).data[((unsigned int)((k)))])) = (((*acol).data[((unsigned int)((var_142)))])));
			((((*rowstr).data[((unsigned int)((j)))])) = ((((*rowstr).data[((unsigned int)((j)))]))+1));
		};
		((nza) = (1+(((int)(ceil((((double)(((nnza+1)-1)))/((double)(1))))))*1)));
	};
	{
		for(int var_143 = (((int)(0))-(nrows)); var_143 < ((((int)(0))-1)+1); var_143 += 1)  { ((((*rowstr).data[((unsigned int)(((((int)(0))-(var_143))+1)))])) = (((*rowstr).data[((unsigned int)((((int)(0))-(var_143))))]))); };
		((j) = ((nrows)+(((int)(ceil((((double)((((((int)(0))-1)+1)-(nrows))))/((double)(1))))))*1)));
	};
	((((*rowstr).data[((unsigned int)(1))])) = 1);
	((nza) = 0);
	{
		for(int var_144 = 1; var_144 < (n+1); var_144 += 1) {
			((((*x).data[((unsigned int)((var_144)))])) = 0.0);
			((((*mark).data[((unsigned int)((var_144)))])) = 0);
		};
		((i) = (1+(((int)(ceil((((double)(((n+1)-1)))/((double)(1))))))*1)));
	};
	((jajp1) = (((*rowstr).data[((unsigned int)(1))])));
	{
		for(int var_150 = 1; var_150 < ((nrows)+1); var_150 += 1) {
			((nzrow) = 0);
			{
				for(int var_148 = (jajp1); var_148 < (((*rowstr).data[((unsigned int)(((var_150)+1)))])); var_148 += 1) {
					((i) = (((*colidx).data[((unsigned int)((var_148)))])));
					((((*x).data[((unsigned int)((i)))])) = ((((*x).data[((unsigned int)((i)))]))+(((*a).data[((unsigned int)((var_148)))]))));
					if((((((*mark).data[((unsigned int)((i)))]))==0)&&((((*x).data[((unsigned int)((i)))]))!=0.0))){
						((((*mark).data[((unsigned int)((i)))])) = 1);
						((nzrow) = ((nzrow)+1));
						((((*nzloc).data[((unsigned int)((nzrow)))])) = (i));
					};
				};
				((k) = ((jajp1)+(((int)(ceil((((double)(((((*rowstr).data[((unsigned int)(((var_150)+1)))]))-(jajp1))))/((double)(1))))))*1)));
			};
			{
				for(int var_149 = 1; var_149 < ((nzrow)+1); var_149 += 1) {
					((i) = (((*nzloc).data[((unsigned int)((var_149)))])));
					((((*mark).data[((unsigned int)((i)))])) = 0);
					((xi) = (((*x).data[((unsigned int)((i)))])));
					((((*x).data[((unsigned int)((i)))])) = 0.0);
					if(((xi)!=0.0)){
						((nza) = ((nza)+1));
						((((*a).data[((unsigned int)((nza)))])) = (xi));
						((((*colidx).data[((unsigned int)((nza)))])) = (i));
					};
				};
				((k) = (1+(((int)(ceil((((double)((((nzrow)+1)-1)))/((double)(1))))))*1)));
			};
			((jajp1) = (((*rowstr).data[((unsigned int)(((var_150)+1)))])));
			((((*rowstr).data[((unsigned int)(((var_150)+1)))])) = ((nza)+(((*rowstr).data[((unsigned int)(1))]))));
		};
		((j) = (1+(((int)(ceil((((double)((((nrows)+1)-1)))/((double)(1))))))*1)));
	};
}
static void sparse_wrap(void* _closure, __insieme_type_14* a, __insieme_type_16* colidx, __insieme_type_16* rowstr, int n, __insieme_type_16* arow, __insieme_type_16* acol, __insieme_type_14* aelt, int firstrow, int lastrow, __insieme_type_14* x, __insieme_type_16* mark, __insieme_type_16* nzloc, int nnza) { sparse(a, colidx, rowstr, n, arow, acol, aelt, firstrow, lastrow, x, mark, nzloc, nnza); }

// start code fragment :: Definition of makea ... type: ((ref<struct<naa:int<4>,nzz:int<4>,firstrow:int<4>,lastrow:int<4>,firstcol:int<4>,lastcol:int<4>,colidx:vector<int<4>,637001>,rowstr:vector<int<4>,7002>,iv:vector<int<4>,14002>,arow:vector<int<4>,637001>,acol:vector<int<4>,637001>,v:vector<real<8>,7002>,aelt:vector<real<8>,637001>,a:vector<real<8>,637001>,x:vector<real<8>,7003>,z:vector<real<8>,7003>,p:vector<real<8>,7003>,q:vector<real<8>,7003>,r:vector<real<8>,7003>,w:vector<real<8>,7003>,amult:real<8>,tran:real<8>,d:real<8>,sum:real<8>,rho:real<8>,rho0:real<8>,alpha:real<8>,beta:real<8>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,int<4>,int<4>,ref<array<real<8>,1>>,ref<array<int<4>,1>>,ref<array<int<4>,1>>,int<4>,int<4>,int<4>,int<4>,int<4>,real<8>,ref<array<int<4>,1>>,ref<array<int<4>,1>>,ref<array<real<8>,1>>,ref<array<real<8>,1>>,ref<array<int<4>,1>>,real<8>)->unit) //
void makea(struct __insieme_globals* var_46, int n, int nz, __insieme_type_14* a, __insieme_type_16* colidx, __insieme_type_16* rowstr, int nonzer, int firstrow, int lastrow, int firstcol, int lastcol, double rcond, __insieme_type_16* arow, __insieme_type_16* acol, __insieme_type_14* aelt, __insieme_type_14* v, __insieme_type_16* iv, double shift){
	int i = 0;
	int nnza = 0;
	int iouter = 0;
	int ivelt = 0;
	int ivelt1 = 0;
	int irow = 0;
	int nzv = 0;
	double size = 0.0;
	double ratio = 0.0;
	double scale = 0.0;
	int jcol = 0;
	((size) = 1.0);
	((ratio) = pow(rcond, (1.0/((double)(n)))));
	((nnza) = 0);
	{
		for(int var_75 = 1; var_75 < (n+1); var_75 += 1)  { ((((*colidx).data[((unsigned int)((n+(var_75))))])) = 0); };
		((i) = (1+(((int)(ceil((((double)(((n+1)-1)))/((double)(1))))))*1)));
	};
	{
		for(int var_113 = 1; var_113 < (n+1); var_113 += 1) {
			((nzv) = nonzer);
			sprnvc(var_46, n, (nzv), v, iv, (&((__insieme_type_16){&((*colidx).data[((unsigned int)(0))]),{1}})), (&((__insieme_type_16){&((*colidx).data[((unsigned int)(n))]),{1}})));
			vecset(n, v, iv, (&((__insieme_type_16){&nzv,{1}})), (var_113), 0.5);
			{
				for(int var_112 = 1; var_112 < ((nzv)+1); var_112 += 1) {
					((jcol) = (((*iv).data[((unsigned int)((var_112)))])));
					if((((jcol)>=firstcol)&&((jcol)<=lastcol))){
						((scale) = ((size)*(((*v).data[((unsigned int)((var_112)))]))));
						{
							for(int var_108 = 1; var_108 < ((nzv)+1); var_108 += 1) {
								((irow) = (((*iv).data[((unsigned int)((var_108)))])));
								if((((irow)>=firstrow)&&((irow)<=lastrow))){
									((nnza) = ((nnza)+1));
									if(((nnza)>nz)){
										printf(((char*)((*(&((__insieme_type_1){"Space for matrix elements exceeded in"}))).data)), 0);
										printf(((char*)((*(&((__insieme_type_1){"nnza, nzmax = %d, %d\n"}))).data)), (nnza), nz);
										printf(((char*)((*(&((__insieme_type_1){"iouter = %d\n"}))).data)), (var_113));
										exit(1);
									};
									((((*acol).data[((unsigned int)((nnza)))])) = (jcol));
									((((*arow).data[((unsigned int)((nnza)))])) = (irow));
									((((*aelt).data[((unsigned int)((nnza)))])) = ((((*v).data[((unsigned int)((var_108)))]))*(scale)));
								};
							};
							((ivelt1) = (1+(((int)(ceil((((double)((((nzv)+1)-1)))/((double)(1))))))*1)));
						};
					};
				};
				((ivelt) = (1+(((int)(ceil((((double)((((nzv)+1)-1)))/((double)(1))))))*1)));
			};
			((size) = ((size)*(ratio)));
		};
		((iouter) = (1+(((int)(ceil((((double)(((n+1)-1)))/((double)(1))))))*1)));
	};
	{
		for(int var_117 = firstrow; var_117 < (lastrow+1); var_117 += 1)  { if((((var_117)>=firstcol)&&((var_117)<=lastcol))){
			((iouter) = (n+(var_117)));
			((nnza) = ((nnza)+1));
			if(((nnza)>nz)){
				printf(((char*)((*(&((__insieme_type_1){"Space for matrix elements exceeded in makea\n"}))).data)), 0);
				printf(((char*)((*(&((__insieme_type_1){"nnza, nzmax = %d, %d\n"}))).data)), (nnza), nz);
				printf(((char*)((*(&((__insieme_type_1){"iouter = %d\n"}))).data)), (iouter));
				exit(1);
			};
			((((*acol).data[((unsigned int)((nnza)))])) = (var_117));
			((((*arow).data[((unsigned int)((nnza)))])) = (var_117));
			((((*aelt).data[((unsigned int)((nnza)))])) = (rcond-shift));
		}; };
		((i) = (firstrow+(((int)(ceil((((double)(((lastrow+1)-firstrow)))/((double)(1))))))*1)));
	};
	sparse(a, colidx, rowstr, n, arow, acol, aelt, firstrow, lastrow, v, (&((__insieme_type_16){&((*iv).data[((unsigned int)(0))]),{1}})), (&((__insieme_type_16){&((*iv).data[((unsigned int)(n))]),{1}})), (nnza));
}
static void makea_wrap(void* _closure, struct __insieme_globals* var_46, int n, int nz, __insieme_type_14* a, __insieme_type_16* colidx, __insieme_type_16* rowstr, int nonzer, int firstrow, int lastrow, int firstcol, int lastcol, double rcond, __insieme_type_16* arow, __insieme_type_16* acol, __insieme_type_14* aelt, __insieme_type_14* v, __insieme_type_16* iv, double shift) { makea(var_46, n, nz, a, colidx, rowstr, nonzer, firstrow, lastrow, firstcol, lastcol, rcond, arow, acol, aelt, v, iv, shift); }

// start code fragment :: Prototype for external function: sqrt ... type: ((real<8>)->real<8>) //
double sqrt(double);
static double sqrt_wrap(void* _closure, double var_246) { return sqrt(var_246); }

// start code fragment :: Definition of conj_grad ... type: ((ref<struct<naa:int<4>,nzz:int<4>,firstrow:int<4>,lastrow:int<4>,firstcol:int<4>,lastcol:int<4>,colidx:vector<int<4>,637001>,rowstr:vector<int<4>,7002>,iv:vector<int<4>,14002>,arow:vector<int<4>,637001>,acol:vector<int<4>,637001>,v:vector<real<8>,7002>,aelt:vector<real<8>,637001>,a:vector<real<8>,637001>,x:vector<real<8>,7003>,z:vector<real<8>,7003>,p:vector<real<8>,7003>,q:vector<real<8>,7003>,r:vector<real<8>,7003>,w:vector<real<8>,7003>,amult:real<8>,tran:real<8>,d:real<8>,sum:real<8>,rho:real<8>,rho0:real<8>,alpha:real<8>,beta:real<8>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,ref<array<int<4>,1>>,ref<array<int<4>,1>>,ref<array<real<8>,1>>,ref<array<real<8>,1>>,ref<array<real<8>,1>>,ref<array<real<8>,1>>,ref<array<real<8>,1>>,ref<array<real<8>,1>>,ref<array<real<8>,1>>,ref<array<real<8>,1>>)->unit) //
void conj_grad(struct __insieme_globals* var_156, __insieme_type_16* colidx, __insieme_type_16* rowstr, __insieme_type_14* x, __insieme_type_14* z, __insieme_type_14* a, __insieme_type_14* p, __insieme_type_14* q, __insieme_type_14* r, __insieme_type_14* w, __insieme_type_14* rnorm){
	int i = 0;
	int j = 0;
	int k = 0;
	int cgit = 0;
	int cgitmax = 25;
	((*(&((*var_156).rho))) = 0.0);
	{
		for(int var_172 = 1; var_172 < (((*(&((*var_156).naa)))+1)+1); var_172 += 1) {
			((((*q).data[((unsigned int)((var_172)))])) = 0.0);
			((((*z).data[((unsigned int)((var_172)))])) = 0.0);
			((((*r).data[((unsigned int)((var_172)))])) = (((*x).data[((unsigned int)((var_172)))])));
			((((*p).data[((unsigned int)((var_172)))])) = (((*r).data[((unsigned int)((var_172)))])));
			((((*w).data[((unsigned int)((var_172)))])) = 0.0);
		};
		((j) = (1+(((int)(ceil((((double)(((((*(&((*var_156).naa)))+1)+1)-1)))/((double)(1))))))*1)));
	};
	{
		for(int var_173 = 1; var_173 < ((((*(&((*var_156).lastcol)))-(*(&((*var_156).firstcol))))+1)+1); var_173 += 1)  { ((*(&((*var_156).rho))) = ((*(&((*var_156).rho)))+((((*x).data[((unsigned int)((var_173)))]))*(((*x).data[((unsigned int)((var_173)))]))))); };
		((j) = (1+(((int)(ceil((((double)((((((*(&((*var_156).lastcol)))-(*(&((*var_156).firstcol))))+1)+1)-1)))/((double)(1))))))*1)));
	};
	{
		for(int var_182 = 1; var_182 < ((cgitmax)+1); var_182 += 1) {
			{
				((*(&((*var_156).rho0))) = (*(&((*var_156).rho))));
				((*(&((*var_156).d))) = 0.0);
				((*(&((*var_156).rho))) = 0.0);
			};
			{
				for(int var_175 = 1; var_175 < ((((*(&((*var_156).lastrow)))-(*(&((*var_156).firstrow))))+1)+1); var_175 += 1) {
					((*(&((*var_156).sum))) = 0.0);
					{
						for(int var_174 = (((*rowstr).data[((unsigned int)((var_175)))])); var_174 < (((*rowstr).data[((unsigned int)(((var_175)+1)))])); var_174 += 1)  { ((*(&((*var_156).sum))) = ((*(&((*var_156).sum)))+((((*a).data[((unsigned int)((var_174)))]))*(((*p).data[((unsigned int)((((*colidx).data[((unsigned int)((var_174)))]))))]))))); };
						((k) = ((((*rowstr).data[((unsigned int)((var_175)))]))+(((int)(ceil((((double)(((((*rowstr).data[((unsigned int)(((var_175)+1)))]))-(((*rowstr).data[((unsigned int)((var_175)))])))))/((double)(1))))))*1)));
					};
					((((*w).data[((unsigned int)((var_175)))])) = (*(&((*var_156).sum))));
				};
				((j) = (1+(((int)(ceil((((double)((((((*(&((*var_156).lastrow)))-(*(&((*var_156).firstrow))))+1)+1)-1)))/((double)(1))))))*1)));
			};
			{
				for(int var_176 = 1; var_176 < ((((*(&((*var_156).lastcol)))-(*(&((*var_156).firstcol))))+1)+1); var_176 += 1)  { ((((*q).data[((unsigned int)((var_176)))])) = (((*w).data[((unsigned int)((var_176)))]))); };
				((j) = (1+(((int)(ceil((((double)((((((*(&((*var_156).lastcol)))-(*(&((*var_156).firstcol))))+1)+1)-1)))/((double)(1))))))*1)));
			};
			{
				for(int var_177 = 1; var_177 < ((((*(&((*var_156).lastcol)))-(*(&((*var_156).firstcol))))+1)+1); var_177 += 1)  { ((((*w).data[((unsigned int)((var_177)))])) = 0.0); };
				((j) = (1+(((int)(ceil((((double)((((((*(&((*var_156).lastcol)))-(*(&((*var_156).firstcol))))+1)+1)-1)))/((double)(1))))))*1)));
			};
			{
				for(int var_178 = 1; var_178 < ((((*(&((*var_156).lastcol)))-(*(&((*var_156).firstcol))))+1)+1); var_178 += 1)  { ((*(&((*var_156).d))) = ((*(&((*var_156).d)))+((((*p).data[((unsigned int)((var_178)))]))*(((*q).data[((unsigned int)((var_178)))]))))); };
				((j) = (1+(((int)(ceil((((double)((((((*(&((*var_156).lastcol)))-(*(&((*var_156).firstcol))))+1)+1)-1)))/((double)(1))))))*1)));
			};
			((*(&((*var_156).alpha))) = ((*(&((*var_156).rho0)))/(*(&((*var_156).d)))));
			{
				for(int var_179 = 1; var_179 < ((((*(&((*var_156).lastcol)))-(*(&((*var_156).firstcol))))+1)+1); var_179 += 1) {
					((((*z).data[((unsigned int)((var_179)))])) = ((((*z).data[((unsigned int)((var_179)))]))+((*(&((*var_156).alpha)))*(((*p).data[((unsigned int)((var_179)))])))));
					((((*r).data[((unsigned int)((var_179)))])) = ((((*r).data[((unsigned int)((var_179)))]))-((*(&((*var_156).alpha)))*(((*q).data[((unsigned int)((var_179)))])))));
				};
				((j) = (1+(((int)(ceil((((double)((((((*(&((*var_156).lastcol)))-(*(&((*var_156).firstcol))))+1)+1)-1)))/((double)(1))))))*1)));
			};
			{
				for(int var_180 = 1; var_180 < ((((*(&((*var_156).lastcol)))-(*(&((*var_156).firstcol))))+1)+1); var_180 += 1)  { ((*(&((*var_156).rho))) = ((*(&((*var_156).rho)))+((((*r).data[((unsigned int)((var_180)))]))*(((*r).data[((unsigned int)((var_180)))]))))); };
				((j) = (1+(((int)(ceil((((double)((((((*(&((*var_156).lastcol)))-(*(&((*var_156).firstcol))))+1)+1)-1)))/((double)(1))))))*1)));
			};
			((*(&((*var_156).beta))) = ((*(&((*var_156).rho)))/(*(&((*var_156).rho0)))));
			{
				for(int var_181 = 1; var_181 < ((((*(&((*var_156).lastcol)))-(*(&((*var_156).firstcol))))+1)+1); var_181 += 1)  { ((((*p).data[((unsigned int)((var_181)))])) = ((((*r).data[((unsigned int)((var_181)))]))+((*(&((*var_156).beta)))*(((*p).data[((unsigned int)((var_181)))]))))); };
				((j) = (1+(((int)(ceil((((double)((((((*(&((*var_156).lastcol)))-(*(&((*var_156).firstcol))))+1)+1)-1)))/((double)(1))))))*1)));
			};
		};
		((cgit) = (1+(((int)(ceil((((double)((((cgitmax)+1)-1)))/((double)(1))))))*1)));
	};
	((*(&((*var_156).sum))) = 0.0);
	{
		for(int var_184 = 1; var_184 < ((((*(&((*var_156).lastrow)))-(*(&((*var_156).firstrow))))+1)+1); var_184 += 1) {
			((*(&((*var_156).d))) = 0.0);
			{
				for(int var_183 = (((*rowstr).data[((unsigned int)((var_184)))])); var_183 < (((((*rowstr).data[((unsigned int)(((var_184)+1)))]))-1)+1); var_183 += 1)  { ((*(&((*var_156).d))) = ((*(&((*var_156).d)))+((((*a).data[((unsigned int)((var_183)))]))*(((*z).data[((unsigned int)((((*colidx).data[((unsigned int)((var_183)))]))))]))))); };
				((k) = ((((*rowstr).data[((unsigned int)((var_184)))]))+(((int)(ceil((((double)(((((((*rowstr).data[((unsigned int)(((var_184)+1)))]))-1)+1)-(((*rowstr).data[((unsigned int)((var_184)))])))))/((double)(1))))))*1)));
			};
			((((*w).data[((unsigned int)((var_184)))])) = (*(&((*var_156).d))));
		};
		((j) = (1+(((int)(ceil((((double)((((((*(&((*var_156).lastrow)))-(*(&((*var_156).firstrow))))+1)+1)-1)))/((double)(1))))))*1)));
	};
	{
		for(int var_185 = 1; var_185 < ((((*(&((*var_156).lastcol)))-(*(&((*var_156).firstcol))))+1)+1); var_185 += 1)  { ((((*r).data[((unsigned int)((var_185)))])) = (((*w).data[((unsigned int)((var_185)))]))); };
		((j) = (1+(((int)(ceil((((double)((((((*(&((*var_156).lastcol)))-(*(&((*var_156).firstcol))))+1)+1)-1)))/((double)(1))))))*1)));
	};
	{
		for(int var_186 = 1; var_186 < ((((*(&((*var_156).lastcol)))-(*(&((*var_156).firstcol))))+1)+1); var_186 += 1) {
			((*(&((*var_156).d))) = ((((*x).data[((unsigned int)((var_186)))]))-(((*r).data[((unsigned int)((var_186)))]))));
			((*(&((*var_156).sum))) = ((*(&((*var_156).sum)))+((*(&((*var_156).d)))*(*(&((*var_156).d))))));
		};
		((j) = (1+(((int)(ceil((((double)((((((*(&((*var_156).lastcol)))-(*(&((*var_156).firstcol))))+1)+1)-1)))/((double)(1))))))*1)));
	};
	 { ((((*rnorm).data[0])) = sqrt((*(&((*var_156).sum))))); };
}
static void conj_grad_wrap(void* _closure, struct __insieme_globals* var_156, __insieme_type_16* colidx, __insieme_type_16* rowstr, __insieme_type_14* x, __insieme_type_14* z, __insieme_type_14* a, __insieme_type_14* p, __insieme_type_14* q, __insieme_type_14* r, __insieme_type_14* w, __insieme_type_14* rnorm) { conj_grad(var_156, colidx, rowstr, x, z, a, p, q, r, w, rnorm); }

// start code fragment :: Definition of timer_clear ... type: ((ref<struct<naa:int<4>,nzz:int<4>,firstrow:int<4>,lastrow:int<4>,firstcol:int<4>,lastcol:int<4>,colidx:vector<int<4>,637001>,rowstr:vector<int<4>,7002>,iv:vector<int<4>,14002>,arow:vector<int<4>,637001>,acol:vector<int<4>,637001>,v:vector<real<8>,7002>,aelt:vector<real<8>,637001>,a:vector<real<8>,637001>,x:vector<real<8>,7003>,z:vector<real<8>,7003>,p:vector<real<8>,7003>,q:vector<real<8>,7003>,r:vector<real<8>,7003>,w:vector<real<8>,7003>,amult:real<8>,tran:real<8>,d:real<8>,sum:real<8>,rho:real<8>,rho0:real<8>,alpha:real<8>,beta:real<8>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,int<4>)->unit) //
void timer_clear(struct __insieme_globals* var_192, int n) { ((((*(&((*var_192).elapsed))).data[((unsigned int)(n))])) = 0.0); }
static void timer_clear_wrap(void* _closure, struct __insieme_globals* var_192, int n) { timer_clear(var_192, n); }

// start code fragment :: type_declaration_timeval //
struct timeval { 
    long tv_sec;
    long tv_usec;
};

// start code fragment :: array type definition of __insieme_type_19 <=> array<struct<tv_sec:int<8>,tv_usec:int<8>>,1> //
typedef struct ___insieme_type_19 { 
    struct timeval* data;
    unsigned size[1];
} __insieme_type_19;

// start code fragment :: type_declaration_timezone //
struct timezone { 
    int tz_minuteswest;
    int tz_dsttime;
};

// start code fragment :: array type definition of __timezone_ptr_t <=> array<struct<tz_minuteswest:int<4>,tz_dsttime:int<4>>,1> //
typedef struct ___timezone_ptr_t { 
    struct timezone* data;
    unsigned size[1];
} __timezone_ptr_t;

// start code fragment :: Prototype for external function: gettimeofday ... type: ((ref<array<struct<tv_sec:int<8>,tv_usec:int<8>>,1>>,ref<array<struct<tz_minuteswest:int<4>,tz_dsttime:int<4>>,1>>)->int<4>) //
int gettimeofday(struct timeval*, struct timezone*);
static int gettimeofday_wrap(void* _closure, __insieme_type_19* var_247, __timezone_ptr_t* var_248) { return gettimeofday(((struct timeval*)((*(var_247)).data)), ((struct timezone*)((*(var_248)).data))); }

// start code fragment :: Definition of wtime ... type: ((ref<struct<naa:int<4>,nzz:int<4>,firstrow:int<4>,lastrow:int<4>,firstcol:int<4>,lastcol:int<4>,colidx:vector<int<4>,637001>,rowstr:vector<int<4>,7002>,iv:vector<int<4>,14002>,arow:vector<int<4>,637001>,acol:vector<int<4>,637001>,v:vector<real<8>,7002>,aelt:vector<real<8>,637001>,a:vector<real<8>,637001>,x:vector<real<8>,7003>,z:vector<real<8>,7003>,p:vector<real<8>,7003>,q:vector<real<8>,7003>,r:vector<real<8>,7003>,w:vector<real<8>,7003>,amult:real<8>,tran:real<8>,d:real<8>,sum:real<8>,rho:real<8>,rho0:real<8>,alpha:real<8>,beta:real<8>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,ref<array<real<8>,1>>)->unit) //
void wtime(struct __insieme_globals* var_199, __insieme_type_14* t){
	struct timeval tv;
	gettimeofday(((struct timeval*)((*((&((__insieme_type_19){&tv,{1}})))).data)), ((struct timezone*)((*(((__timezone_ptr_t*)memcpy(alloca(sizeof(__timezone_ptr_t)), &((__timezone_ptr_t){0,{0}}), sizeof(__timezone_ptr_t))))).data)));
	if(((*(&((*var_199).sec)))<0)) { ((*(&((*var_199).sec))) = ((int)((*(&((tv).tv_sec)))))); };
	((((*t).data[0])) = (((double)(((*(&((tv).tv_sec)))-((long)((*(&((*var_199).sec))))))))+(1.0e-6*((double)((*(&((tv).tv_usec))))))));
}
static void wtime_wrap(void* _closure, struct __insieme_globals* var_199, __insieme_type_14* t) { wtime(var_199, t); }

// start code fragment :: Definition of elapsed_time ... type: ((ref<struct<naa:int<4>,nzz:int<4>,firstrow:int<4>,lastrow:int<4>,firstcol:int<4>,lastcol:int<4>,colidx:vector<int<4>,637001>,rowstr:vector<int<4>,7002>,iv:vector<int<4>,14002>,arow:vector<int<4>,637001>,acol:vector<int<4>,637001>,v:vector<real<8>,7002>,aelt:vector<real<8>,637001>,a:vector<real<8>,637001>,x:vector<real<8>,7003>,z:vector<real<8>,7003>,p:vector<real<8>,7003>,q:vector<real<8>,7003>,r:vector<real<8>,7003>,w:vector<real<8>,7003>,amult:real<8>,tran:real<8>,d:real<8>,sum:real<8>,rho:real<8>,rho0:real<8>,alpha:real<8>,beta:real<8>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>)->real<8>) //
double elapsed_time(struct __insieme_globals* var_197){
	double t = 0.0;
	wtime(var_197, (&((__insieme_type_14){&t,{1}})));
	return (t);
}
static double elapsed_time_wrap(void* _closure, struct __insieme_globals* var_197) { return elapsed_time(var_197); }

// start code fragment :: Definition of timer_start ... type: ((ref<struct<naa:int<4>,nzz:int<4>,firstrow:int<4>,lastrow:int<4>,firstcol:int<4>,lastcol:int<4>,colidx:vector<int<4>,637001>,rowstr:vector<int<4>,7002>,iv:vector<int<4>,14002>,arow:vector<int<4>,637001>,acol:vector<int<4>,637001>,v:vector<real<8>,7002>,aelt:vector<real<8>,637001>,a:vector<real<8>,637001>,x:vector<real<8>,7003>,z:vector<real<8>,7003>,p:vector<real<8>,7003>,q:vector<real<8>,7003>,r:vector<real<8>,7003>,w:vector<real<8>,7003>,amult:real<8>,tran:real<8>,d:real<8>,sum:real<8>,rho:real<8>,rho0:real<8>,alpha:real<8>,beta:real<8>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,int<4>)->unit) //
void timer_start(struct __insieme_globals* var_195, int n) { ((((*(&((*var_195).start))).data[((unsigned int)(n))])) = elapsed_time(var_195)); }
static void timer_start_wrap(void* _closure, struct __insieme_globals* var_195, int n) { timer_start(var_195, n); }

// start code fragment :: Definition of timer_stop ... type: ((ref<struct<naa:int<4>,nzz:int<4>,firstrow:int<4>,lastrow:int<4>,firstcol:int<4>,lastcol:int<4>,colidx:vector<int<4>,637001>,rowstr:vector<int<4>,7002>,iv:vector<int<4>,14002>,arow:vector<int<4>,637001>,acol:vector<int<4>,637001>,v:vector<real<8>,7002>,aelt:vector<real<8>,637001>,a:vector<real<8>,637001>,x:vector<real<8>,7003>,z:vector<real<8>,7003>,p:vector<real<8>,7003>,q:vector<real<8>,7003>,r:vector<real<8>,7003>,w:vector<real<8>,7003>,amult:real<8>,tran:real<8>,d:real<8>,sum:real<8>,rho:real<8>,rho0:real<8>,alpha:real<8>,beta:real<8>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,int<4>)->unit) //
void timer_stop(struct __insieme_globals* var_208, int n){
	double t = 0.0;
	double now = 0.0;
	((now) = elapsed_time(var_208));
	((t) = ((now)-(((*(&((*var_208).start))).data[((unsigned int)(n))]))));
	((((*(&((*var_208).elapsed))).data[((unsigned int)(n))])) = ((((*(&((*var_208).elapsed))).data[((unsigned int)(n))]))+(t)));
}
static void timer_stop_wrap(void* _closure, struct __insieme_globals* var_208, int n) { timer_stop(var_208, n); }

// start code fragment :: Definition of timer_read ... type: ((ref<struct<naa:int<4>,nzz:int<4>,firstrow:int<4>,lastrow:int<4>,firstcol:int<4>,lastcol:int<4>,colidx:vector<int<4>,637001>,rowstr:vector<int<4>,7002>,iv:vector<int<4>,14002>,arow:vector<int<4>,637001>,acol:vector<int<4>,637001>,v:vector<real<8>,7002>,aelt:vector<real<8>,637001>,a:vector<real<8>,637001>,x:vector<real<8>,7003>,z:vector<real<8>,7003>,p:vector<real<8>,7003>,q:vector<real<8>,7003>,r:vector<real<8>,7003>,w:vector<real<8>,7003>,amult:real<8>,tran:real<8>,d:real<8>,sum:real<8>,rho:real<8>,rho0:real<8>,alpha:real<8>,beta:real<8>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,int<4>)->real<8>) //
double timer_read(struct __insieme_globals* var_213, int n) { return (((*(&((*var_213).elapsed))).data[((unsigned int)(n))])); }
static double timer_read_wrap(void* _closure, struct __insieme_globals* var_213, int n) { return timer_read(var_213, n); }

// start code fragment :: Prototype for external function: fabs ... type: ((real<8>)->real<8>) //
double fabs(double);
static double fabs_wrap(void* _closure, double var_249) { return fabs(var_249); }

// start code fragment :: Definition of c_print_results ... type: ((ref<array<char,1>>,char,int<4>,int<4>,int<4>,int<4>,int<4>,real<8>,real<8>,ref<array<char,1>>,int<4>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>)->unit) //
void c_print_results(__insieme_type_1* name, char class, int n1, int n2, int n3, int niter, int nthreads, double t, double mops, __insieme_type_1* optype, int passed_verification, __insieme_type_1* npbversion, __insieme_type_1* compiletime, __insieme_type_1* cc, __insieme_type_1* clink, __insieme_type_1* c_lib, __insieme_type_1* c_inc, __insieme_type_1* cflags, __insieme_type_1* clinkflags, __insieme_type_1* rand){
	__insieme_type_1 evalue = ((__insieme_type_1){"1000"});
	printf(((char*)((*(&((__insieme_type_1){"\n\n %s Benchmark Completed\n"}))).data)), ((char*)((*(name)).data)));
	printf(((char*)((*(&((__insieme_type_1){" Class           =                        %c\n"}))).data)), ((int)(class)));
	if(((n2==0)&&(n3==0))) { printf(((char*)((*(&((__insieme_type_1){" Size            =             %12d\n"}))).data)), n1); } else  { printf(((char*)((*(&((__insieme_type_1){" Size            =              %3dx%3dx%3d\n"}))).data)), n1, n2, n3); };
	printf(((char*)((*(&((__insieme_type_1){" Iterations      =             %12d\n"}))).data)), niter);
	printf(((char*)((*(&((__insieme_type_1){" Threads         =             %12d\n"}))).data)), nthreads);
	printf(((char*)((*(&((__insieme_type_1){" Time in seconds =             %12.2f\n"}))).data)), 0.0);
	printf(((char*)((*(&((__insieme_type_1){" Mop/s total     =             %12.2f\n"}))).data)), 0.0);
	printf(((char*)((*(&((__insieme_type_1){" Operation type  = %24s\n"}))).data)), ((char*)((*(optype)).data)));
	if((passed_verification!=0)) { printf(((char*)((*(&((__insieme_type_1){" Verification    =               SUCCESSFUL\n"}))).data)), 0); } else  { printf(((char*)((*(&((__insieme_type_1){" Verification    =             UNSUCCESSFUL\n"}))).data)), 0); };
	printf(((char*)((*(&((__insieme_type_1){" Version         =             %12s\n"}))).data)), ((char*)((*(npbversion)).data)));
	printf(((char*)((*(&((__insieme_type_1){" Compile date    =             %12s\n"}))).data)), ((char*)((*(compiletime)).data)));
	printf(((char*)((*(&((__insieme_type_1){"\n Compile options:\n"}))).data)), 0);
	printf(((char*)((*(&((__insieme_type_1){"    CC           = %s\n"}))).data)), ((char*)((*(cc)).data)));
	printf(((char*)((*(&((__insieme_type_1){"    CLINK        = %s\n"}))).data)), ((char*)((*(clink)).data)));
	printf(((char*)((*(&((__insieme_type_1){"    C_LIB        = %s\n"}))).data)), ((char*)((*(c_lib)).data)));
	printf(((char*)((*(&((__insieme_type_1){"    C_INC        = %s\n"}))).data)), ((char*)((*(c_inc)).data)));
	printf(((char*)((*(&((__insieme_type_1){"    CFLAGS       = %s\n"}))).data)), ((char*)((*(cflags)).data)));
	printf(((char*)((*(&((__insieme_type_1){"    CLINKFLAGS   = %s\n"}))).data)), ((char*)((*(clinkflags)).data)));
	printf(((char*)((*(&((__insieme_type_1){"    RAND         = %s\n"}))).data)), ((char*)((*(rand)).data)));
}
static void c_print_results_wrap(void* _closure, __insieme_type_1* name, char class, int n1, int n2, int n3, int niter, int nthreads, double t, double mops, __insieme_type_1* optype, int passed_verification, __insieme_type_1* npbversion, __insieme_type_1* compiletime, __insieme_type_1* cc, __insieme_type_1* clink, __insieme_type_1* c_lib, __insieme_type_1* c_inc, __insieme_type_1* cflags, __insieme_type_1* clinkflags, __insieme_type_1* rand) { c_print_results(name, class, n1, n2, n3, niter, nthreads, t, mops, optype, passed_verification, npbversion, compiletime, cc, clink, c_lib, c_inc, cflags, clinkflags, rand); }

// start code fragment :: main function //
int main(int __argc, char** __argv) {
	
	// encapsulating arguments within Insieme Types ...
	int argc = __argc;
	__insieme_type_0 argv = (__insieme_type_0){alloca(sizeof(__insieme_type_1) * argc), {argc}};
	for(int i=0; i<argc; ++i) {
		argv.data[i] = (__insieme_type_1){__argv[i],{strlen(__argv[i])+1}};
	}
	
	// ---- begin of actual code body ----
	{
		struct __insieme_globals* var_1 = malloc(sizeof(struct __insieme_globals));
		((*(&((*var_1).naa))) = 0);
		((*(&((*var_1).nzz))) = 0);
		((*(&((*var_1).firstrow))) = 0);
		((*(&((*var_1).lastrow))) = 0);
		((*(&((*var_1).firstcol))) = 0);
		((*(&((*var_1).lastcol))) = 0);
		((*(&((*var_1).amult))) = 0.0);
		((*(&((*var_1).tran))) = 0.0);
		((*(&((*var_1).d))) = 0.0);
		((*(&((*var_1).sum))) = 0.0);
		((*(&((*var_1).rho))) = 0.0);
		((*(&((*var_1).rho0))) = 0.0);
		((*(&((*var_1).alpha))) = 0.0);
		((*(&((*var_1).beta))) = 0.0);
		((*(&((*var_1).sec))) = (((int)(0))-1));
		int i = 0;
		int j = 0;
		int k = 0;
		int it = 0;
		int nthreads = 1;
		double zeta = 0.0;
		double rnorm = 0.0;
		double norm_temp11 = 0.0;
		double norm_temp12 = 0.0;
		double t = 0.0;
		double mflops = 0.0;
		char class = '\0';
		int verified = 0;
		double zeta_verify_value = 0.0;
		double epsilon = 0.0;
		((*(&((*var_1).firstrow))) = 1);
		((*(&((*var_1).lastrow))) = 7000);
		((*(&((*var_1).firstcol))) = 1);
		((*(&((*var_1).lastcol))) = 7000);
		if(((((7000==1400)&&(8==7))&&(15==15))&&(12.0==10.0))){
			((class) = 'S');
			((zeta_verify_value) = 8.5971775078648);
		} else  { if(((((7000==7000)&&(8==8))&&(15==15))&&(12.0==12.0))){
			((class) = 'W');
			((zeta_verify_value) = 10.362595087124);
		} else  { if(((((7000==14000)&&(8==11))&&(15==15))&&(12.0==20.0))){
			((class) = 'A');
			((zeta_verify_value) = 17.130235054029);
		} else  { if(((((7000==75000)&&(8==13))&&(15==75))&&(12.0==60.0))){
			((class) = 'B');
			((zeta_verify_value) = 22.712745482631);
		} else  { if(((((7000==150000)&&(8==15))&&(15==75))&&(12.0==110.0))){
			((class) = 'C');
			((zeta_verify_value) = 28.973605592845);
		} else  { ((class) = 'U'); }; }; }; }; };
		printf(((char*)((*(&((__insieme_type_1){"\n\n NAS Parallel Benchmarks 2.3 OpenMP C version - CG Benchmark\n"}))).data)), 0);
		printf(((char*)((*(&((__insieme_type_1){" Size: %10d\n"}))).data)), 7000);
		printf(((char*)((*(&((__insieme_type_1){" Iterations: %5d\n"}))).data)), 15);
		((*(&((*var_1).naa))) = 7000);
		((*(&((*var_1).nzz))) = (((7000*(8+1))*(8+1))+(7000*(8+2))));
		((*(&((*var_1).tran))) = 314159265.0);
		((*(&((*var_1).amult))) = 1220703125.0);
		((zeta) = randlc((&((__insieme_type_14){(&((*var_1).tran)),{1}})), (*(&((*var_1).amult)))));
		makea(var_1, (*(&((*var_1).naa))), (*(&((*var_1).nzz))), (&((__insieme_type_14){(*(&((*var_1).a))).data,{1}})), (&((__insieme_type_16){(*(&((*var_1).colidx))).data,{1}})), (&((__insieme_type_16){(*(&((*var_1).rowstr))).data,{1}})), 8, (*(&((*var_1).firstrow))), (*(&((*var_1).lastrow))), (*(&((*var_1).firstcol))), (*(&((*var_1).lastcol))), 1.0e-1, (&((__insieme_type_16){(*(&((*var_1).arow))).data,{1}})), (&((__insieme_type_16){(*(&((*var_1).acol))).data,{1}})), (&((__insieme_type_14){(*(&((*var_1).aelt))).data,{1}})), (&((__insieme_type_14){(*(&((*var_1).v))).data,{1}})), (&((__insieme_type_16){(*(&((*var_1).iv))).data,{1}})), 12.0);
		{
			{
				for(int var_154 = 1; var_154 < ((((*(&((*var_1).lastrow)))-(*(&((*var_1).firstrow))))+1)+1); var_154 += 1)  { {
					for(int var_153 = (((*(&((*var_1).rowstr))).data[((unsigned int)((var_154)))])); var_153 < (((*(&((*var_1).rowstr))).data[((unsigned int)(((var_154)+1)))])); var_153 += 1)  { ((((*(&((*var_1).colidx))).data[((unsigned int)((var_153)))])) = (((((*(&((*var_1).colidx))).data[((unsigned int)((var_153)))]))-(*(&((*var_1).firstcol))))+1)); };
					((k) = ((((*(&((*var_1).rowstr))).data[((unsigned int)((var_154)))]))+(((int)(ceil((((double)(((((*(&((*var_1).rowstr))).data[((unsigned int)(((var_154)+1)))]))-(((*(&((*var_1).rowstr))).data[((unsigned int)((var_154)))])))))/((double)(1))))))*1)));
				}; };
				((j) = (1+(((int)(ceil((((double)((((((*(&((*var_1).lastrow)))-(*(&((*var_1).firstrow))))+1)+1)-1)))/((double)(1))))))*1)));
			};
			{
				for(int var_155 = 1; var_155 < ((7000+1)+1); var_155 += 1)  { ((((*(&((*var_1).x))).data[((unsigned int)((var_155)))])) = 1.0); };
				((i) = (1+(((int)(ceil((((double)((((7000+1)+1)-1)))/((double)(1))))))*1)));
			};
			((zeta) = 0.0);
			{
				for(int var_190 = 1; var_190 < (1+1); var_190 += 1) {
					conj_grad(var_1, (&((__insieme_type_16){(*(&((*var_1).colidx))).data,{1}})), (&((__insieme_type_16){(*(&((*var_1).rowstr))).data,{1}})), (&((__insieme_type_14){(*(&((*var_1).x))).data,{1}})), (&((__insieme_type_14){(*(&((*var_1).z))).data,{1}})), (&((__insieme_type_14){(*(&((*var_1).a))).data,{1}})), (&((__insieme_type_14){(*(&((*var_1).p))).data,{1}})), (&((__insieme_type_14){(*(&((*var_1).q))).data,{1}})), (&((__insieme_type_14){(*(&((*var_1).r))).data,{1}})), (&((__insieme_type_14){(*(&((*var_1).w))).data,{1}})), (&((__insieme_type_14){&rnorm,{1}})));
					{
						((norm_temp11) = 0.0);
						((norm_temp12) = 0.0);
					};
					{
						for(int var_188 = 1; var_188 < ((((*(&((*var_1).lastcol)))-(*(&((*var_1).firstcol))))+1)+1); var_188 += 1) {
							((norm_temp11) = ((norm_temp11)+((((*(&((*var_1).x))).data[((unsigned int)((var_188)))]))*(((*(&((*var_1).z))).data[((unsigned int)((var_188)))])))));
							((norm_temp12) = ((norm_temp12)+((((*(&((*var_1).z))).data[((unsigned int)((var_188)))]))*(((*(&((*var_1).z))).data[((unsigned int)((var_188)))])))));
						};
						((j) = (1+(((int)(ceil((((double)((((((*(&((*var_1).lastcol)))-(*(&((*var_1).firstcol))))+1)+1)-1)))/((double)(1))))))*1)));
					};
					((norm_temp12) = (1.0/sqrt((norm_temp12))));
					{
						for(int var_189 = 1; var_189 < ((((*(&((*var_1).lastcol)))-(*(&((*var_1).firstcol))))+1)+1); var_189 += 1)  { ((((*(&((*var_1).x))).data[((unsigned int)((var_189)))])) = ((norm_temp12)*(((*(&((*var_1).z))).data[((unsigned int)((var_189)))])))); };
						((j) = (1+(((int)(ceil((((double)((((((*(&((*var_1).lastcol)))-(*(&((*var_1).firstcol))))+1)+1)-1)))/((double)(1))))))*1)));
					};
				};
				((it) = (1+(((int)(ceil((((double)(((1+1)-1)))/((double)(1))))))*1)));
			};
			{
				for(int var_191 = 1; var_191 < ((7000+1)+1); var_191 += 1)  { ((((*(&((*var_1).x))).data[((unsigned int)((var_191)))])) = 1.0); };
				((i) = (1+(((int)(ceil((((double)((((7000+1)+1)-1)))/((double)(1))))))*1)));
			};
			((zeta) = 0.0);
		};
		timer_clear(var_1, 1);
		timer_start(var_1, 1);
		 { {
			for(int var_207 = 1; var_207 < (15+1); var_207 += 1) {
				conj_grad(var_1, (&((__insieme_type_16){(*(&((*var_1).colidx))).data,{1}})), (&((__insieme_type_16){(*(&((*var_1).rowstr))).data,{1}})), (&((__insieme_type_14){(*(&((*var_1).x))).data,{1}})), (&((__insieme_type_14){(*(&((*var_1).z))).data,{1}})), (&((__insieme_type_14){(*(&((*var_1).a))).data,{1}})), (&((__insieme_type_14){(*(&((*var_1).p))).data,{1}})), (&((__insieme_type_14){(*(&((*var_1).q))).data,{1}})), (&((__insieme_type_14){(*(&((*var_1).r))).data,{1}})), (&((__insieme_type_14){(*(&((*var_1).w))).data,{1}})), (&((__insieme_type_14){&rnorm,{1}})));
				{
					((norm_temp11) = 0.0);
					((norm_temp12) = 0.0);
				};
				{
					for(int var_205 = 1; var_205 < ((((*(&((*var_1).lastcol)))-(*(&((*var_1).firstcol))))+1)+1); var_205 += 1) {
						((norm_temp11) = ((norm_temp11)+((((*(&((*var_1).x))).data[((unsigned int)((var_205)))]))*(((*(&((*var_1).z))).data[((unsigned int)((var_205)))])))));
						((norm_temp12) = ((norm_temp12)+((((*(&((*var_1).z))).data[((unsigned int)((var_205)))]))*(((*(&((*var_1).z))).data[((unsigned int)((var_205)))])))));
					};
					((j) = (1+(((int)(ceil((((double)((((((*(&((*var_1).lastcol)))-(*(&((*var_1).firstcol))))+1)+1)-1)))/((double)(1))))))*1)));
				};
				{
					((norm_temp12) = (1.0/sqrt((norm_temp12))));
					((zeta) = (12.0+(1.0/(norm_temp11))));
				};
				{
					if(((var_207)==1)) { printf(((char*)((*(&((__insieme_type_1){"   iteration           ||r||                 zeta\n"}))).data)), 0); };
					printf(((char*)((*(&((__insieme_type_1){"    %5d       %20.14e%20.13e\n"}))).data)), (var_207), (rnorm), (zeta));
				};
				{
					for(int var_206 = 1; var_206 < ((((*(&((*var_1).lastcol)))-(*(&((*var_1).firstcol))))+1)+1); var_206 += 1)  { ((((*(&((*var_1).x))).data[((unsigned int)((var_206)))])) = ((norm_temp12)*(((*(&((*var_1).z))).data[((unsigned int)((var_206)))])))); };
					((j) = (1+(((int)(ceil((((double)((((((*(&((*var_1).lastcol)))-(*(&((*var_1).firstcol))))+1)+1)-1)))/((double)(1))))))*1)));
				};
			};
			((it) = (1+(((int)(ceil((((double)(((15+1)-1)))/((double)(1))))))*1)));
		}; };
		timer_stop(var_1, 1);
		((t) = timer_read(var_1, 1));
		printf(((char*)((*(&((__insieme_type_1){" Benchmark completed\n"}))).data)), 0);
		((epsilon) = 1.0e-10);
		if(((class)!='U')) { if((fabs(((zeta)-(zeta_verify_value)))<=(epsilon))){
			((verified) = 1);
			printf(((char*)((*(&((__insieme_type_1){" VERIFICATION SUCCESSFUL\n"}))).data)), 0);
			printf(((char*)((*(&((__insieme_type_1){" Zeta is    %20.12e\n"}))).data)), (zeta));
			printf(((char*)((*(&((__insieme_type_1){" Error is   %20.12e\n"}))).data)), ((zeta)-(zeta_verify_value)));
		} else {
			((verified) = 0);
			printf(((char*)((*(&((__insieme_type_1){" VERIFICATION FAILED\n"}))).data)), 0);
			printf(((char*)((*(&((__insieme_type_1){" Zeta                %20.12e\n"}))).data)), (zeta));
			printf(((char*)((*(&((__insieme_type_1){" The correct zeta is %20.12e\n"}))).data)), (zeta_verify_value));
		}; } else {
			((verified) = 0);
			printf(((char*)((*(&((__insieme_type_1){" Problem size unknown\n"}))).data)), 0);
			printf(((char*)((*(&((__insieme_type_1){" NO VERIFICATION PERFORMED\n"}))).data)), 0);
		};
		if(((t)!=0.0)) { ((mflops) = (((((2.0*((double)(15)))*((double)(7000)))*(((3.0+((double)((8*(8+1)))))+(25.0*(5.0+((double)((8*(8+1)))))))+3.0))/(t))/1000000.0)); } else  { ((mflops) = 0.0); };
		c_print_results(&((__insieme_type_1){"CG"}), (class), 7000, 0, 0, 15, (nthreads), (t), (mflops), &((__insieme_type_1){"          floating point"}), (verified), &((__insieme_type_1){"2.3"}), &((__insieme_type_1){"02 Dec 2010"}), &((__insieme_type_1){"cc"}), &((__insieme_type_1){"cc"}), &((__insieme_type_1){"-lm"}), &((__insieme_type_1){"-I../common"}), &((__insieme_type_1){"-O3 "}), &((__insieme_type_1){"-lm"}), &((__insieme_type_1){"randdp"}));
	}
	// ----  end of actual code body  ----
	
}

