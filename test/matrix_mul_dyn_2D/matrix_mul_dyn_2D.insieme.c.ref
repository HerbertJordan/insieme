// --- Generated Inspire Code ---
#include <alloca.h>
#include <stddef.h>
#include <stdlib.h>
#include <runtime.h>
#define bool int
#define true 1
#define false 0
#define null 0

// start code fragment :: array type definition of __insieme_type_1 <=> array<real<8>,1> //
typedef struct ___insieme_type_1 { 
    double* data;
} __insieme_type_1;

// start code fragment :: array type definition of __insieme_type_0 <=> array<array<real<8>,1>,1> //
typedef struct ___insieme_type_0 { 
    __insieme_type_1* data;
} __insieme_type_0;

// start code fragment :: New operator for type ref<array<real<8>,1>> //
static inline __insieme_type_1* _ref_new___insieme_type_3(__insieme_type_1 value) {
    __insieme_type_1* res = malloc(sizeof(__insieme_type_1));
    *res = value;
    return res;
}


// start code fragment :: array type utils of __insieme_type_1 <=> array<real<8>,1> //
// A constructor for the array type __insieme_type_1
static inline __insieme_type_1 __insieme_type_1_ctr(unsigned s1) {
    return ((__insieme_type_1){malloc(sizeof(double)*s1)});
}

// start code fragment :: New operator for type ref<array<array<real<8>,1>,1>> //
static inline __insieme_type_0* _ref_new___insieme_type_2(__insieme_type_0 value) {
    __insieme_type_0* res = malloc(sizeof(__insieme_type_0));
    *res = value;
    return res;
}


// start code fragment :: array type utils of __insieme_type_0 <=> array<array<real<8>,1>,1> //
// A constructor for the array type __insieme_type_0
static inline __insieme_type_0 __insieme_type_0_ctr(unsigned s1) {
    return ((__insieme_type_0){malloc(sizeof(__insieme_type_1)*s1)});
}

// start code fragment :: Definition of createMatrix ... type: ((uint<4>,uint<4>)->ref<array<array<real<8>,1>,1>>) //
__insieme_type_0* createMatrix(unsigned int x, unsigned int y){
	__insieme_type_1* data = _ref_new___insieme_type_3((__insieme_type_1_ctr(((((unsigned long)((x*y)))*sizeof(double))/sizeof(double)))));
	__insieme_type_0* index = _ref_new___insieme_type_2((__insieme_type_0_ctr(((((unsigned long)(x))*sizeof(__insieme_type_1))/sizeof(__insieme_type_1)))));
	((((*index).data[((unsigned int)(0))])) = (*data));
	for(unsigned int var_7 = ((unsigned int)(1)); var_7 < x; var_7 += 1)  { ((((*index).data[((unsigned int)(var_7))])) = (*(&((__insieme_type_1){&((*data).data[((unsigned int)((var_7*y)))])})))); };
	return index;
}
static __insieme_type_0* createMatrix_wrap(void* _closure, unsigned int x, unsigned int y) { return createMatrix(x, y); }

// start code fragment :: array type definition of __insieme_type_6 <=> array<char,1> //
typedef struct ___insieme_type_6 { 
    char* data;
} __insieme_type_6;

// start code fragment :: Prototype for external function: printf ... type: ((ref<array<char,1>>,var_list)->int<4>) //
int printf(char*, ...);

// start code fragment :: vector_type_declaration of __insieme_type_8 <=> vector<char,3> //
typedef struct ___insieme_type_8 { 
    char data[3];
} __insieme_type_8;

// A constructor initializing a vector of the type __insieme_type_8 uniformly
static inline __insieme_type_8 __insieme_type_8_init_uniform(char value) {
	__insieme_type_8 res;
	for (int i=0; i<3;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_9 <=> vector<char,4> //
typedef struct ___insieme_type_9 { 
    char data[4];
} __insieme_type_9;

// A constructor initializing a vector of the type __insieme_type_9 uniformly
static inline __insieme_type_9 __insieme_type_9_init_uniform(char value) {
	__insieme_type_9 res;
	for (int i=0; i<4;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: Definition of freeMatrix ... type: ((ref<array<array<real<8>,1>,1>>)->unit) //
void freeMatrix(__insieme_type_0* matrix){
	__insieme_type_0* var_44 = matrix;
	{
		free((((*(var_44)).data[((unsigned int)(0))])).data);
		;
	};
}
static void freeMatrix_wrap(void* _closure, __insieme_type_0* matrix) { freeMatrix(matrix); }

// start code fragment :: main function //
int main() {
	{
		__insieme_type_0 A = *createMatrix(((unsigned int)(1000)), ((unsigned int)(1000)));
		__insieme_type_0 B = *createMatrix(((unsigned int)(1000)), ((unsigned int)(1000)));
		__insieme_type_0 C = *createMatrix(((unsigned int)(1000)), ((unsigned int)(1000)));
		{
			for(int var_14 = 0; var_14 < 1000; var_14 += 1)  { for(int var_13 = 0; var_13 < 1000; var_13 += 1)  { ((((((A).data[((unsigned int)(var_14))])).data[((unsigned int)(var_13))])) = ((double)((var_14*var_13)))); }; };
			for(int var_20 = 0; var_20 < 1000; var_20 += 1)  { for(int var_19 = 0; var_19 < 1000; var_19 += 1)  { ((((((B).data[((unsigned int)(var_20))])).data[((unsigned int)(var_19))])) = ((double)((((var_20==var_19))?(1):(0))))); }; };
			for(int var_27 = 0; var_27 < 1000; var_27 += 1)  { for(int var_26 = 0; var_26 < 1000; var_26 += 1) {
				double sum = ((double)(0));
				for(int var_25 = 0; var_25 < 1000; var_25 += 1)  { ((sum) = ((sum)+((((((A).data[((unsigned int)(var_27))])).data[((unsigned int)(var_25))]))*(((((B).data[((unsigned int)(var_25))])).data[((unsigned int)(var_26))]))))); };
				((((((C).data[((unsigned int)(var_27))])).data[((unsigned int)(var_26))])) = (sum));
			}; };
		};
		int success = 1;
		for(int var_40 = 0; var_40 < 1000; var_40 += 1) {
			for(int var_33 = 0; var_33 < (((1000<1000))?(1000):(1000)); var_33 += 1)  { if(((((((A).data[((unsigned int)(var_40))])).data[((unsigned int)(var_33))]))!=(((((C).data[((unsigned int)(var_40))])).data[((unsigned int)(var_33))])))) { ((success) = 0); }; };
			for(int var_39 = (((1000<1000))?(1000):(1000)); var_39 < (((1000>1000))?(1000):(1000)); var_39 += 1)  { if(((((((C).data[((unsigned int)(var_40))])).data[((unsigned int)(var_39))]))!=((double)(0)))) { ((success) = 0); }; };
		};
		printf(((char*)((*(&((__insieme_type_6){"Verification: %s\n"}))).data)), (((((success)!=0))?((((__insieme_type_6){(((__insieme_type_8){{'O', 'K', '\0'}})).data}))):((((__insieme_type_6){(((__insieme_type_9){{'E', 'R', 'R', '\0'}})).data}))))).data);
		freeMatrix(&A);
		freeMatrix(&B);
		freeMatrix(&C);
	};
}
