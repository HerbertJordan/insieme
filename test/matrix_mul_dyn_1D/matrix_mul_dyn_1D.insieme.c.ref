// --- Generated Inspire Code ---
#include <alloca.h>
#include <stddef.h>
#include <runtime.h>
#define bool int
#define true 1
#define false 0
#define null 0

// start code fragment :: Definition of createMatrix ... type: ((uint<4>,uint<4>)->ref<array<real<8>,1>>) //
double* createMatrix(unsigned int x, unsigned int y) { return (((double*){malloc(sizeof(double*)*((((unsigned long)((x*y)))*sizeof(double))/sizeof(double)))})); }
static double* createMatrix_wrap(void* _closure, unsigned int x, unsigned int y) { return createMatrix(x, y); }

// start code fragment :: Prototype for external function: printf ... type: ((ref<array<char,1>>,var_list)->int<4>) //
int printf(char*, ...);

// start code fragment :: vector_type_declaration of __insieme_type_1 <=> vector<char,3> //
typedef struct ___insieme_type_1 { 
    char data[3];
} __insieme_type_1;

// A constructor initializing a vector of the type __insieme_type_1 uniformly
static inline __insieme_type_1 __insieme_type_1_init_uniform(char value) {
	__insieme_type_1 res;
	for (int i=0; i<3;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_2 <=> vector<char,4> //
typedef struct ___insieme_type_2 { 
    char data[4];
} __insieme_type_2;

// A constructor initializing a vector of the type __insieme_type_2 uniformly
static inline __insieme_type_2 __insieme_type_2_init_uniform(char value) {
	__insieme_type_2 res;
	for (int i=0; i<4;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: Definition of freeMatrix ... type: ((ref<array<real<8>,1>>)->unit) //
void freeMatrix(double* matrix){
	double* var_5 = matrix;
	 { ; };
}
static void freeMatrix_wrap(void* _closure, double* matrix) { freeMatrix(matrix); }

// start code fragment :: Definition of main ... type: (()->int<4>) //
int main(){
	double* A = createMatrix(((unsigned int)(1000)), ((unsigned int)(1000)));
	double* B = createMatrix(((unsigned int)(1000)), ((unsigned int)(1000)));
	double* C = createMatrix(((unsigned int)(1000)), ((unsigned int)(1000)));
	{
		for(int var_13 = 0; var_13 < 1000; var_13 += 1)  { for(int var_12 = 0; var_12 < 1000; var_12 += 1)  { ((((A)[((unsigned int)(((var_13*1000)+var_12)))])) = ((double)((var_13*var_12)))); }; };
		for(int var_21 = 0; var_21 < 1000; var_21 += 1)  { for(int var_20 = 0; var_20 < 1000; var_20 += 1)  { ((((B)[((unsigned int)(((var_21*1000)+var_20)))])) = ((double)((((var_21==var_20))?(1):(0))))); }; };
		for(int var_28 = 0; var_28 < 1000; var_28 += 1)  { for(int var_27 = 0; var_27 < 1000; var_27 += 1) {
			double sum = ((double)(0));
			for(int var_26 = 0; var_26 < 1000; var_26 += 1)  { ((sum) = ((sum)+((((A)[((unsigned int)(((var_28*1000)+var_26)))]))*(((B)[((unsigned int)(((var_26*1000)+var_27)))]))))); };
			((((C)[((unsigned int)(((var_28*1000)+var_27)))])) = (sum));
		}; };
	};
	int success = 1;
	for(int var_41 = 0; var_41 < 1000; var_41 += 1) {
		for(int var_34 = 0; var_34 < (((1000<1000))?(1000):(1000)); var_34 += 1)  { if(((((A)[((unsigned int)(((var_41*1000)+var_34)))]))!=(((C)[((unsigned int)(((var_41*1000)+var_34)))])))) { ((success) = 0); }; };
		for(int var_40 = (((1000<1000))?(1000):(1000)); var_40 < (((1000>1000))?(1000):(1000)); var_40 += 1)  { if(((((C)[((unsigned int)(((var_41*1000)+var_40)))]))!=((double)(0)))) { ((success) = 0); }; };
	};
	printf("Verification: %s\n", ((((success)!=0))?(((((__insieme_type_1){{'O', 'K', '\0'}})).data)):(((((__insieme_type_2){{'E', 'R', 'R', '\0'}})).data))));
	freeMatrix((A));
	freeMatrix((B));
	freeMatrix((C));
}
static int main_wrap(void* _closure) { return main(); }
