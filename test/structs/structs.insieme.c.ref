// --- Generated Inspire Code ---
#include <alloca.h>
#include <stddef.h>
#include <stdlib.h>
#include <runtime.h>
#define bool int
#define true 1
#define false 0
#define null 0

// start code fragment :: array type definition of __insieme_type_1 <=> array<char,1> //
typedef struct ___insieme_type_1 { 
    char* data;
    unsigned size[1];
} __insieme_type_1;

// start code fragment :: array type definition of __insieme_type_0 <=> array<array<char,1>,1> //
typedef struct ___insieme_type_0 { 
    __insieme_type_1* data;
    unsigned size[1];
} __insieme_type_0;

// start code fragment :: Prototype for external function: strlen ... type: ((ref<array<char,1>>)->uint<8>) //
unsigned long strlen(char*);
static unsigned long strlen_wrap(void* _closure, __insieme_type_1* var_11) { return strlen(((char*)((*(var_11)).data))); }

// start code fragment :: vector_type_declaration of __insieme_type_3 <=> vector<char,30> //
typedef struct ___insieme_type_3 { 
    char data[30];
} __insieme_type_3;

// A constructor initializing a vector of the type __insieme_type_3 uniformly
static inline __insieme_type_3 __insieme_type_3_init_uniform(char value) {
	__insieme_type_3 res;
	for (int i=0; i<30;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: type_declaration_Person //
struct Person { 
    __insieme_type_3 name;
    unsigned int age;
};

// start code fragment :: Prototype for external function: strcpy ... type: ((ref<array<char,1>>,ref<array<char,1>>)->ref<array<char,1>>) //
char* strcpy(char*, char*);
static __insieme_type_1* strcpy_wrap(void* _closure, __insieme_type_1* var_12, __insieme_type_1* var_13) { return &((__insieme_type_1){strcpy(((char*)((*(var_12)).data)), ((char*)((*(var_13)).data))),{1}}); }

// start code fragment :: Definition of getPerson ... type: (()->struct<name:vector<char,30>,age:uint<4>>) //
struct Person getPerson(){
	struct Person res;
	&((__insieme_type_1){strcpy(((char*)((*((&((__insieme_type_1){(*(&((res).name))).data,{1}})))).data)), ((char*)((*(&((__insieme_type_1){"John Doe"}))).data))),{1}});
	((*(&((res).age))) = ((unsigned int)(101)));
}
static struct Person getPerson_wrap(void* _closure) { return getPerson(); }

// start code fragment :: Definition of isTeenager ... type: ((struct<name:vector<char,30>,age:uint<4>>)->int<4>) //
int isTeenager(struct Person person) { return ((int)(((((person.age)>=((unsigned int)(10)))&&((person.age)<((unsigned int)(20))))))); }
static int isTeenager_wrap(void* _closure, struct Person person) { return isTeenager(person); }

// start code fragment :: main function //
int main(int __argc, char** __argv) {
	
	// encapsulating arguments within Insieme Types ...
	int argc = __argc;
	__insieme_type_0 argv = (__insieme_type_0){alloca(sizeof(__insieme_type_1) * argc), {argc}};
	for(int i=0; i<argc; ++i) {
		argv.data[i] = (__insieme_type_1){__argv[i],{strlen(__argv[i])+1}};
	}
	
	// ---- begin of actual code body ----
	{
		struct Person mrX = getPerson();
		return isTeenager((mrX));
	}
	// ----  end of actual code body  ----
	
}

