// --- Generated Inspire Code ---
#include <alloca.h>
#include <stddef.h>
#include <runtime.h>
#define bool int
#define true 1
#define false 0
#define null 0

// start code fragment :: vector_type_declaration of __insieme_type_1 <=> vector<real<8>,64> //
typedef struct ___insieme_type_1 { 
    double data[64];
} __insieme_type_1;

// A constructor initializing a vector of the type __insieme_type_1 uniformly
static inline __insieme_type_1 __insieme_type_1_init_uniform(double value) {
	__insieme_type_1 res;
	for (int i=0; i<64;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_2 <=> vector<int<4>,5> //
typedef struct ___insieme_type_2 { 
    int data[5];
} __insieme_type_2;

// A constructor initializing a vector of the type __insieme_type_2 uniformly
static inline __insieme_type_2 __insieme_type_2_init_uniform(int value) {
	__insieme_type_2 res;
	for (int i=0; i<5;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_3 <=> vector<int<4>,1048576> //
typedef struct ___insieme_type_3 { 
    int data[1048576];
} __insieme_type_3;

// A constructor initializing a vector of the type __insieme_type_3 uniformly
static inline __insieme_type_3 __insieme_type_3_init_uniform(int value) {
	__insieme_type_3 res;
	for (int i=0; i<1048576;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: type_declaration___insieme_globals //
struct __insieme_globals { 
    __insieme_type_1 start;
    __insieme_type_1 elapsed;
    int sec;
    __insieme_type_2 B_test_index_array;
    __insieme_type_2 B_test_rank_array;
    __insieme_type_2 C_test_index_array;
    __insieme_type_2 C_test_rank_array;
    int KS;
    double R23;
    double R46;
    int* key_buff_ptr_global;
    int passed_verification;
    __insieme_type_3 key_array;
    __insieme_type_3 key_buff1;
    __insieme_type_3 key_buff2;
    __insieme_type_2 partial_verify_vals;
    __insieme_type_2 test_index_array;
    __insieme_type_2 test_rank_array;
    __insieme_type_2 S_test_index_array;
    __insieme_type_2 S_test_rank_array;
    __insieme_type_2 W_test_index_array;
    __insieme_type_2 W_test_rank_array;
    __insieme_type_2 A_test_index_array;
    __insieme_type_2 A_test_rank_array;
    double T23;
    double T46;
};

// start code fragment :: vector_type_declaration of __insieme_type_4 <=> vector<int<4>,1> //
typedef struct ___insieme_type_4 { 
    int data[1];
} __insieme_type_4;

// A constructor initializing a vector of the type __insieme_type_4 uniformly
static inline __insieme_type_4 __insieme_type_4_init_uniform(int value) {
	__insieme_type_4 res;
	for (int i=0; i<1;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: Prototype for external function: ceil ... type: ((real<8>)->real<8>) //
double ceil(double);
static double ceil_wrap(void* _closure, double var_137) { return ceil(var_137); }

// start code fragment :: Prototype for external function: printf ... type: ((ref<array<char,1>>,var_list)->int<4>) //
int printf(char*, ...);

// start code fragment :: Definition of timer_clear ... type: ((ref<struct<start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>,B_test_index_array:vector<int<4>,5>,B_test_rank_array:vector<int<4>,5>,C_test_index_array:vector<int<4>,5>,C_test_rank_array:vector<int<4>,5>,KS:int<4>,R23:real<8>,R46:real<8>,key_buff_ptr_global:ref<array<int<4>,1>>,passed_verification:int<4>,key_array:vector<int<4>,1048576>,key_buff1:vector<int<4>,1048576>,key_buff2:vector<int<4>,1048576>,partial_verify_vals:vector<int<4>,5>,test_index_array:vector<int<4>,5>,test_rank_array:vector<int<4>,5>,S_test_index_array:vector<int<4>,5>,S_test_rank_array:vector<int<4>,5>,W_test_index_array:vector<int<4>,5>,W_test_rank_array:vector<int<4>,5>,A_test_index_array:vector<int<4>,5>,A_test_rank_array:vector<int<4>,5>,T23:real<8>,T46:real<8>>>,int<4>)->unit) //
void timer_clear(struct __insieme_globals* var_41, int n) { ((((*(&((*var_41).elapsed))).data[((unsigned int)(n))])) = 0.0); }
static void timer_clear_wrap(void* _closure, struct __insieme_globals* var_41, int n) { timer_clear(var_41, n); }

// start code fragment :: Definition of randlc ... type: ((ref<struct<start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>,B_test_index_array:vector<int<4>,5>,B_test_rank_array:vector<int<4>,5>,C_test_index_array:vector<int<4>,5>,C_test_rank_array:vector<int<4>,5>,KS:int<4>,R23:real<8>,R46:real<8>,key_buff_ptr_global:ref<array<int<4>,1>>,passed_verification:int<4>,key_array:vector<int<4>,1048576>,key_buff1:vector<int<4>,1048576>,key_buff2:vector<int<4>,1048576>,partial_verify_vals:vector<int<4>,5>,test_index_array:vector<int<4>,5>,test_rank_array:vector<int<4>,5>,S_test_index_array:vector<int<4>,5>,S_test_rank_array:vector<int<4>,5>,W_test_index_array:vector<int<4>,5>,W_test_rank_array:vector<int<4>,5>,A_test_index_array:vector<int<4>,5>,A_test_rank_array:vector<int<4>,5>,T23:real<8>,T46:real<8>>>,ref<array<real<8>,1>>,ref<array<real<8>,1>>)->real<8>) //
double randlc(struct __insieme_globals* var_47, double* X, double* A){
	double T1 = 0.0;
	double T2 = 0.0;
	double T3 = 0.0;
	double T4 = 0.0;
	double A1 = 0.0;
	double A2 = 0.0;
	double X1 = 0.0;
	double X2 = 0.0;
	double Z = 0.0;
	int i = 0;
	int j = 0;
	if(((*(&((*var_47).KS)))==0)){
		((*(&((*var_47).R23))) = 1.0);
		((*(&((*var_47).R46))) = 1.0);
		((*(&((*var_47).T23))) = 1.0);
		((*(&((*var_47).T46))) = 1.0);
		{
			for(int var_62 = 1; var_62 < (23+1); var_62 += 1) {
				((*(&((*var_47).R23))) = (0.50*(*(&((*var_47).R23)))));
				((*(&((*var_47).T23))) = (2.0*(*(&((*var_47).T23)))));
			};
			((i) = (1+(((int)(ceil((((double)(((23+1)-1)))/((double)(1))))))*1)));
		};
		{
			for(int var_64 = 1; var_64 < (46+1); var_64 += 1) {
				((*(&((*var_47).R46))) = (0.50*(*(&((*var_47).R46)))));
				((*(&((*var_47).T46))) = (2.0*(*(&((*var_47).T46)))));
			};
			((i) = (1+(((int)(ceil((((double)(((46+1)-1)))/((double)(1))))))*1)));
		};
		((*(&((*var_47).KS))) = 1);
	};
	((T1) = ((*(&((*var_47).R23)))*((A[0]))));
	((j) = ((int)((T1))));
	((A1) = ((double)((j))));
	((A2) = (((A[0]))-((*(&((*var_47).T23)))*(A1))));
	((T1) = ((*(&((*var_47).R23)))*((X[0]))));
	((j) = ((int)((T1))));
	((X1) = ((double)((j))));
	((X2) = (((X[0]))-((*(&((*var_47).T23)))*(X1))));
	((T1) = (((A1)*(X2))+((A2)*(X1))));
	((j) = ((int)(((*(&((*var_47).R23)))*(T1)))));
	((T2) = ((double)((j))));
	((Z) = ((T1)-((*(&((*var_47).T23)))*(T2))));
	((T3) = (((*(&((*var_47).T23)))*(Z))+((A2)*(X2))));
	((j) = ((int)(((*(&((*var_47).R46)))*(T3)))));
	((T4) = ((double)((j))));
	(((X[0])) = ((T3)-((*(&((*var_47).T46)))*(T4))));
	return ((*(&((*var_47).R46)))*((X[0])));
}
static double randlc_wrap(void* _closure, struct __insieme_globals* var_47, double* X, double* A) { return randlc(var_47, X, A); }

// start code fragment :: Definition of create_seq ... type: ((ref<struct<start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>,B_test_index_array:vector<int<4>,5>,B_test_rank_array:vector<int<4>,5>,C_test_index_array:vector<int<4>,5>,C_test_rank_array:vector<int<4>,5>,KS:int<4>,R23:real<8>,R46:real<8>,key_buff_ptr_global:ref<array<int<4>,1>>,passed_verification:int<4>,key_array:vector<int<4>,1048576>,key_buff1:vector<int<4>,1048576>,key_buff2:vector<int<4>,1048576>,partial_verify_vals:vector<int<4>,5>,test_index_array:vector<int<4>,5>,test_rank_array:vector<int<4>,5>,S_test_index_array:vector<int<4>,5>,S_test_rank_array:vector<int<4>,5>,W_test_index_array:vector<int<4>,5>,W_test_rank_array:vector<int<4>,5>,A_test_index_array:vector<int<4>,5>,A_test_rank_array:vector<int<4>,5>,T23:real<8>,T46:real<8>>>,real<8>,real<8>)->unit) //
void create_seq(struct __insieme_globals* var_66, double seed, double a){
	double var_73 = seed;
	double var_74 = a;
	{
		double x = 0.0;
		int i = 0;
		int j = 0;
		int k = 0;
		((k) = ((1<<16)/4));
		{
			for(int var_76 = 0; var_76 < (1<<20); var_76 += 1) {
				((x) = randlc(var_66, (&var_73), (&var_74)));
				((x) = ((x)+randlc(var_66, (&var_73), (&var_74))));
				((x) = ((x)+randlc(var_66, (&var_73), (&var_74))));
				((x) = ((x)+randlc(var_66, (&var_73), (&var_74))));
				((((*(&((*var_66).key_array))).data[((unsigned int)(var_76))])) = ((int)((((double)((k)))*(x)))));
			};
			((i) = (0+(((int)(ceil((((double)(((1<<20)-0)))/((double)(1))))))*1)));
		};
	};
}
static void create_seq_wrap(void* _closure, struct __insieme_globals* var_66, double seed, double a) { create_seq(var_66, seed, a); }

// start code fragment :: vector_type_declaration of __insieme_type_5 <=> vector<int<4>,65536> //
typedef struct ___insieme_type_5 { 
    int data[65536];
} __insieme_type_5;

// A constructor initializing a vector of the type __insieme_type_5 uniformly
static inline __insieme_type_5 __insieme_type_5_init_uniform(int value) {
	__insieme_type_5 res;
	for (int i=0; i<65536;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: Definition of rank ... type: ((ref<struct<start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>,B_test_index_array:vector<int<4>,5>,B_test_rank_array:vector<int<4>,5>,C_test_index_array:vector<int<4>,5>,C_test_rank_array:vector<int<4>,5>,KS:int<4>,R23:real<8>,R46:real<8>,key_buff_ptr_global:ref<array<int<4>,1>>,passed_verification:int<4>,key_array:vector<int<4>,1048576>,key_buff1:vector<int<4>,1048576>,key_buff2:vector<int<4>,1048576>,partial_verify_vals:vector<int<4>,5>,test_index_array:vector<int<4>,5>,test_rank_array:vector<int<4>,5>,S_test_index_array:vector<int<4>,5>,S_test_rank_array:vector<int<4>,5>,W_test_index_array:vector<int<4>,5>,W_test_rank_array:vector<int<4>,5>,A_test_index_array:vector<int<4>,5>,A_test_rank_array:vector<int<4>,5>,T23:real<8>,T46:real<8>>>,int<4>)->unit) //
void rank(struct __insieme_globals* var_89, int iteration){
	int i = 0;
	int j = 0;
	int k = 0;
	int l = 0;
	int m = 0;
	int shift = (16-10);
	int key = 0;
	int min_key_val = 0;
	int max_key_val = 0;
	__insieme_type_5 prv_buff1;
	{
		((((*(&((*var_89).key_array))).data[((unsigned int)(iteration))])) = iteration);
		((((*(&((*var_89).key_array))).data[((unsigned int)((iteration+10)))])) = ((1<<16)-iteration));
		{
			for(int var_102 = 0; var_102 < 5; var_102 += 1)  { ((((*(&((*var_89).partial_verify_vals))).data[((unsigned int)(var_102))])) = (((*(&((*var_89).key_array))).data[((unsigned int)((((*(&((*var_89).test_index_array))).data[((unsigned int)(var_102))]))))]))); };
			((i) = (0+(((int)(ceil((((double)((5-0)))/((double)(1))))))*1)));
		};
		{
			for(int var_104 = 0; var_104 < (1<<16); var_104 += 1)  { ((((*(&((*var_89).key_buff1))).data[((unsigned int)(var_104))])) = 0); };
			((i) = (0+(((int)(ceil((((double)(((1<<16)-0)))/((double)(1))))))*1)));
		};
	};
	{
		for(int var_106 = 0; var_106 < (1<<16); var_106 += 1)  { ((((prv_buff1).data[((unsigned int)(var_106))])) = 0); };
		((i) = (0+(((int)(ceil((((double)(((1<<16)-0)))/((double)(1))))))*1)));
	};
	{
		for(int var_108 = 0; var_108 < (1<<20); var_108 += 1) {
			((((*(&((*var_89).key_buff2))).data[((unsigned int)(var_108))])) = (((*(&((*var_89).key_array))).data[((unsigned int)(var_108))])));
			((((prv_buff1).data[((unsigned int)((((*(&((*var_89).key_buff2))).data[((unsigned int)(var_108))]))))]))++);
		};
		((i) = (0+(((int)(ceil((((double)(((1<<20)-0)))/((double)(1))))))*1)));
	};
	{
		for(int var_110 = 0; var_110 < ((1<<16)-1); var_110 += 1)  { ((((prv_buff1).data[((unsigned int)((var_110+1)))])) = ((((prv_buff1).data[((unsigned int)((var_110+1)))]))+(((prv_buff1).data[((unsigned int)(var_110))])))); };
		((i) = (0+(((int)(ceil((((double)((((1<<16)-1)-0)))/((double)(1))))))*1)));
	};
	 { {
		for(int var_112 = 0; var_112 < (1<<16); var_112 += 1)  { ((((*(&((*var_89).key_buff1))).data[((unsigned int)(var_112))])) = ((((*(&((*var_89).key_buff1))).data[((unsigned int)(var_112))]))+(((prv_buff1).data[((unsigned int)(var_112))])))); };
		((i) = (0+(((int)(ceil((((double)(((1<<16)-0)))/((double)(1))))))*1)));
	}; };
	{
		{
			for(int var_121 = 0; var_121 < 5; var_121 += 1) {
				((k) = (((*(&((*var_89).partial_verify_vals))).data[((unsigned int)(var_121))])));
				if(((0<=(k))&&((k)<=((1<<20)-1)))){
					int var_113 = ((int)('W'));
					switch(var_113) {
					case 'S':
						if((var_121<=2)) { if(((((*(&((*var_89).key_buff1))).data[((unsigned int)(((k)-1)))]))!=((((*(&((*var_89).test_rank_array))).data[((unsigned int)(var_121))]))+iteration))) { printf("Failed partial verification: iteration %d, test key %d\n", iteration, var_121); } else  { ((*(&((*var_89).passed_verification)))++); }; } else  { if(((((*(&((*var_89).key_buff1))).data[((unsigned int)(((k)-1)))]))!=((((*(&((*var_89).test_rank_array))).data[((unsigned int)(var_121))]))-iteration))) { printf("Failed partial verification: iteration %d, test key %d\n", iteration, var_121); } else  { ((*(&((*var_89).passed_verification)))++); }; }; break;
					case 'W':
						if((var_121<2)) { if(((((*(&((*var_89).key_buff1))).data[((unsigned int)(((k)-1)))]))!=((((*(&((*var_89).test_rank_array))).data[((unsigned int)(var_121))]))+(iteration-2)))) { printf("Failed partial verification: iteration %d, test key %d\n", iteration, var_121); } else  { ((*(&((*var_89).passed_verification)))++); }; } else  { if(((((*(&((*var_89).key_buff1))).data[((unsigned int)(((k)-1)))]))!=((((*(&((*var_89).test_rank_array))).data[((unsigned int)(var_121))]))-iteration))) { printf("Failed partial verification: iteration %d, test key %d\n", iteration, var_121); } else  { ((*(&((*var_89).passed_verification)))++); }; }; break;
					case 'A':
						if((var_121<=2)) { if(((((*(&((*var_89).key_buff1))).data[((unsigned int)(((k)-1)))]))!=((((*(&((*var_89).test_rank_array))).data[((unsigned int)(var_121))]))+(iteration-1)))) { printf("Failed partial verification: iteration %d, test key %d\n", iteration, var_121); } else  { ((*(&((*var_89).passed_verification)))++); }; } else  { if(((((*(&((*var_89).key_buff1))).data[((unsigned int)(((k)-1)))]))!=((((*(&((*var_89).test_rank_array))).data[((unsigned int)(var_121))]))-(iteration-1)))) { printf("Failed partial verification: iteration %d, test key %d\n", iteration, var_121); } else  { ((*(&((*var_89).passed_verification)))++); }; }; break;
					case 'B':
						if((((var_121==1)||((var_121)==2))||((var_121)==4))) { if(((((*(&((*var_89).key_buff1))).data[((unsigned int)(((k)-1)))]))!=((((*(&((*var_89).test_rank_array))).data[((unsigned int)(var_121))]))+iteration))) { printf("Failed partial verification: iteration %d, test key %d\n", iteration, var_121); } else  { ((*(&((*var_89).passed_verification)))++); }; } else  { if(((((*(&((*var_89).key_buff1))).data[((unsigned int)(((k)-1)))]))!=((((*(&((*var_89).test_rank_array))).data[((unsigned int)(var_121))]))-iteration))) { printf("Failed partial verification: iteration %d, test key %d\n", iteration, var_121); } else  { ((*(&((*var_89).passed_verification)))++); }; }; break;
					case 'C':
						if((var_121<=2)) { if(((((*(&((*var_89).key_buff1))).data[((unsigned int)(((k)-1)))]))!=((((*(&((*var_89).test_rank_array))).data[((unsigned int)(var_121))]))+iteration))) { printf("Failed partial verification: iteration %d, test key %d\n", iteration, var_121); } else  { ((*(&((*var_89).passed_verification)))++); }; } else  { if(((((*(&((*var_89).key_buff1))).data[((unsigned int)(((k)-1)))]))!=((((*(&((*var_89).test_rank_array))).data[((unsigned int)(var_121))]))-iteration))) { printf("Failed partial verification: iteration %d, test key %d\n", iteration, var_121); } else  { ((*(&((*var_89).passed_verification)))++); }; }; break;
					};
				};
			};
			((i) = (0+(((int)(ceil((((double)((5-0)))/((double)(1))))))*1)));
		};
		if((iteration==10)) { ((*(&((*var_89).key_buff_ptr_global))) = (((int*){(*(&((*var_89).key_buff1))).data}))); };
	};
}
static void rank_wrap(void* _closure, struct __insieme_globals* var_89, int iteration) { rank(var_89, iteration); }

// start code fragment :: type_declaration_timeval //
struct timeval { 
    long tv_sec;
    long tv_usec;
};

// start code fragment :: type_declaration_timezone //
struct timezone { 
    int tz_minuteswest;
    int tz_dsttime;
};

// start code fragment :: Prototype for external function: gettimeofday ... type: ((ref<array<struct<tv_sec:int<8>,tv_usec:int<8>>,1>>,ref<array<struct<tz_minuteswest:int<4>,tz_dsttime:int<4>>,1>>)->int<4>) //
int gettimeofday(struct timeval*, struct timezone*);
static int gettimeofday_wrap(void* _closure, struct timeval* var_138, struct timezone* var_139) { return gettimeofday(var_138, var_139); }

// start code fragment :: Definition of wtime ... type: ((ref<struct<start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>,B_test_index_array:vector<int<4>,5>,B_test_rank_array:vector<int<4>,5>,C_test_index_array:vector<int<4>,5>,C_test_rank_array:vector<int<4>,5>,KS:int<4>,R23:real<8>,R46:real<8>,key_buff_ptr_global:ref<array<int<4>,1>>,passed_verification:int<4>,key_array:vector<int<4>,1048576>,key_buff1:vector<int<4>,1048576>,key_buff2:vector<int<4>,1048576>,partial_verify_vals:vector<int<4>,5>,test_index_array:vector<int<4>,5>,test_rank_array:vector<int<4>,5>,S_test_index_array:vector<int<4>,5>,S_test_rank_array:vector<int<4>,5>,W_test_index_array:vector<int<4>,5>,W_test_rank_array:vector<int<4>,5>,A_test_index_array:vector<int<4>,5>,A_test_rank_array:vector<int<4>,5>,T23:real<8>,T46:real<8>>>,ref<array<real<8>,1>>)->unit) //
void wtime(struct __insieme_globals* var_26, double* t){
	struct timeval tv;
	gettimeofday((&tv), 0);
	if(((*(&((*var_26).sec)))<0)) { ((*(&((*var_26).sec))) = ((int)((*(&((tv).tv_sec)))))); };
	(((t[0])) = (((double)(((*(&((tv).tv_sec)))-((long)((*(&((*var_26).sec))))))))+(1.0e-6*((double)((*(&((tv).tv_usec))))))));
}
static void wtime_wrap(void* _closure, struct __insieme_globals* var_26, double* t) { wtime(var_26, t); }

// start code fragment :: Definition of elapsed_time ... type: ((ref<struct<start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>,B_test_index_array:vector<int<4>,5>,B_test_rank_array:vector<int<4>,5>,C_test_index_array:vector<int<4>,5>,C_test_rank_array:vector<int<4>,5>,KS:int<4>,R23:real<8>,R46:real<8>,key_buff_ptr_global:ref<array<int<4>,1>>,passed_verification:int<4>,key_array:vector<int<4>,1048576>,key_buff1:vector<int<4>,1048576>,key_buff2:vector<int<4>,1048576>,partial_verify_vals:vector<int<4>,5>,test_index_array:vector<int<4>,5>,test_rank_array:vector<int<4>,5>,S_test_index_array:vector<int<4>,5>,S_test_rank_array:vector<int<4>,5>,W_test_index_array:vector<int<4>,5>,W_test_rank_array:vector<int<4>,5>,A_test_index_array:vector<int<4>,5>,A_test_rank_array:vector<int<4>,5>,T23:real<8>,T46:real<8>>>)->real<8>) //
double elapsed_time(struct __insieme_globals* var_30){
	double t = 0.0;
	wtime(var_30, (&t));
	return (t);
}
static double elapsed_time_wrap(void* _closure, struct __insieme_globals* var_30) { return elapsed_time(var_30); }

// start code fragment :: Definition of timer_start ... type: ((ref<struct<start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>,B_test_index_array:vector<int<4>,5>,B_test_rank_array:vector<int<4>,5>,C_test_index_array:vector<int<4>,5>,C_test_rank_array:vector<int<4>,5>,KS:int<4>,R23:real<8>,R46:real<8>,key_buff_ptr_global:ref<array<int<4>,1>>,passed_verification:int<4>,key_array:vector<int<4>,1048576>,key_buff1:vector<int<4>,1048576>,key_buff2:vector<int<4>,1048576>,partial_verify_vals:vector<int<4>,5>,test_index_array:vector<int<4>,5>,test_rank_array:vector<int<4>,5>,S_test_index_array:vector<int<4>,5>,S_test_rank_array:vector<int<4>,5>,W_test_index_array:vector<int<4>,5>,W_test_rank_array:vector<int<4>,5>,A_test_index_array:vector<int<4>,5>,A_test_rank_array:vector<int<4>,5>,T23:real<8>,T46:real<8>>>,int<4>)->unit) //
void timer_start(struct __insieme_globals* var_44, int n) { ((((*(&((*var_44).start))).data[((unsigned int)(n))])) = elapsed_time(var_44)); }
static void timer_start_wrap(void* _closure, struct __insieme_globals* var_44, int n) { timer_start(var_44, n); }

// start code fragment :: Definition of timer_stop ... type: ((ref<struct<start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>,B_test_index_array:vector<int<4>,5>,B_test_rank_array:vector<int<4>,5>,C_test_index_array:vector<int<4>,5>,C_test_rank_array:vector<int<4>,5>,KS:int<4>,R23:real<8>,R46:real<8>,key_buff_ptr_global:ref<array<int<4>,1>>,passed_verification:int<4>,key_array:vector<int<4>,1048576>,key_buff1:vector<int<4>,1048576>,key_buff2:vector<int<4>,1048576>,partial_verify_vals:vector<int<4>,5>,test_index_array:vector<int<4>,5>,test_rank_array:vector<int<4>,5>,S_test_index_array:vector<int<4>,5>,S_test_rank_array:vector<int<4>,5>,W_test_index_array:vector<int<4>,5>,W_test_rank_array:vector<int<4>,5>,A_test_index_array:vector<int<4>,5>,A_test_rank_array:vector<int<4>,5>,T23:real<8>,T46:real<8>>>,int<4>)->unit) //
void timer_stop(struct __insieme_globals* var_33, int n){
	double t = 0.0;
	double now = 0.0;
	((now) = elapsed_time(var_33));
	((t) = ((now)-(((*(&((*var_33).start))).data[((unsigned int)(n))]))));
	((((*(&((*var_33).elapsed))).data[((unsigned int)(n))])) = ((((*(&((*var_33).elapsed))).data[((unsigned int)(n))]))+(t)));
}
static void timer_stop_wrap(void* _closure, struct __insieme_globals* var_33, int n) { timer_stop(var_33, n); }

// start code fragment :: Definition of timer_read ... type: ((ref<struct<start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>,B_test_index_array:vector<int<4>,5>,B_test_rank_array:vector<int<4>,5>,C_test_index_array:vector<int<4>,5>,C_test_rank_array:vector<int<4>,5>,KS:int<4>,R23:real<8>,R46:real<8>,key_buff_ptr_global:ref<array<int<4>,1>>,passed_verification:int<4>,key_array:vector<int<4>,1048576>,key_buff1:vector<int<4>,1048576>,key_buff2:vector<int<4>,1048576>,partial_verify_vals:vector<int<4>,5>,test_index_array:vector<int<4>,5>,test_rank_array:vector<int<4>,5>,S_test_index_array:vector<int<4>,5>,S_test_rank_array:vector<int<4>,5>,W_test_index_array:vector<int<4>,5>,W_test_rank_array:vector<int<4>,5>,A_test_index_array:vector<int<4>,5>,A_test_rank_array:vector<int<4>,5>,T23:real<8>,T46:real<8>>>,int<4>)->real<8>) //
double timer_read(struct __insieme_globals* var_38, int n) { return (((*(&((*var_38).elapsed))).data[((unsigned int)(n))])); }
static double timer_read_wrap(void* _closure, struct __insieme_globals* var_38, int n) { return timer_read(var_38, n); }

// start code fragment :: Definition of full_verify ... type: ((ref<struct<start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>,B_test_index_array:vector<int<4>,5>,B_test_rank_array:vector<int<4>,5>,C_test_index_array:vector<int<4>,5>,C_test_rank_array:vector<int<4>,5>,KS:int<4>,R23:real<8>,R46:real<8>,key_buff_ptr_global:ref<array<int<4>,1>>,passed_verification:int<4>,key_array:vector<int<4>,1048576>,key_buff1:vector<int<4>,1048576>,key_buff2:vector<int<4>,1048576>,partial_verify_vals:vector<int<4>,5>,test_index_array:vector<int<4>,5>,test_rank_array:vector<int<4>,5>,S_test_index_array:vector<int<4>,5>,S_test_rank_array:vector<int<4>,5>,W_test_index_array:vector<int<4>,5>,W_test_rank_array:vector<int<4>,5>,A_test_index_array:vector<int<4>,5>,A_test_rank_array:vector<int<4>,5>,T23:real<8>,T46:real<8>>>)->unit) //
void full_verify(struct __insieme_globals* var_78){
	int i = 0;
	int j = 0;
	int k = 0;
	int m = 0;
	int unique_keys = 0;
	{
		for(int var_85 = 0; var_85 < (1<<20); var_85 += 1)  { ((((*(&((*var_78).key_array))).data[((unsigned int)((--(((*(&((*var_78).key_buff_ptr_global)))[((unsigned int)((((*(&((*var_78).key_buff2))).data[((unsigned int)(var_85))]))))])))))])) = (((*(&((*var_78).key_buff2))).data[((unsigned int)(var_85))]))); };
		((i) = (0+(((int)(ceil((((double)(((1<<20)-0)))/((double)(1))))))*1)));
	};
	((j) = 0);
	{
		for(int var_87 = 1; var_87 < (1<<20); var_87 += 1)  { if(((((*(&((*var_78).key_array))).data[((unsigned int)((var_87-1)))]))>(((*(&((*var_78).key_array))).data[((unsigned int)(var_87))])))) { ((j)++); }; };
		((i) = (1+(((int)(ceil((((double)(((1<<20)-1)))/((double)(1))))))*1)));
	};
	if(((j)!=0)) { printf("Full_verify: number of keys out of sort: %d\n", (j)); } else  { ((*(&((*var_78).passed_verification)))++); };
}
static void full_verify_wrap(void* _closure, struct __insieme_globals* var_78) { full_verify(var_78); }

// start code fragment :: Definition of c_print_results ... type: ((ref<array<char,1>>,char,int<4>,int<4>,int<4>,int<4>,int<4>,real<8>,real<8>,ref<array<char,1>>,int<4>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>)->unit) //
void c_print_results(char* name, char class, int n1, int n2, int n3, int niter, int nthreads, double t, double mops, char* optype, int passed_verification, char* npbversion, char* compiletime, char* cc, char* clink, char* c_lib, char* c_inc, char* cflags, char* clinkflags, char* rand){
	char* evalue = "1000";
	printf("\n\n %s Benchmark Completed\n", name);
	printf(" Class           =                        %c\n", ((int)(class)));
	if(((n2==0)&&(n3==0))) { printf(" Size            =             %12d\n", n1); } else  { printf(" Size            =              %3dx%3dx%3d\n", n1, n2, n3); };
	printf(" Iterations      =             %12d\n", niter);
	printf(" Threads         =             %12d\n", nthreads);
	printf(" Time in seconds =             %12.2f\n", 0.0);
	printf(" Mop/s total     =             %12.2f\n", 0.0);
	printf(" Operation type  = %24s\n", optype);
	if((passed_verification!=0)) { printf(" Verification    =               SUCCESSFUL\n", 0); } else  { printf(" Verification    =             UNSUCCESSFUL\n", 0); };
	printf(" Version         =             %12s\n", npbversion);
	printf(" Compile date    =             %12s\n", compiletime);
	printf("\n Compile options:\n", 0);
	printf("    CC           = %s\n", cc);
	printf("    CLINK        = %s\n", clink);
	printf("    C_LIB        = %s\n", c_lib);
	printf("    C_INC        = %s\n", c_inc);
	printf("    CFLAGS       = %s\n", cflags);
	printf("    CLINKFLAGS   = %s\n", clinkflags);
	printf("    RAND         = %s\n", rand);
}
static void c_print_results_wrap(void* _closure, char* name, char class, int n1, int n2, int n3, int niter, int nthreads, double t, double mops, char* optype, int passed_verification, char* npbversion, char* compiletime, char* cc, char* clink, char* c_lib, char* c_inc, char* cflags, char* clinkflags, char* rand) { c_print_results(name, class, n1, n2, n3, niter, nthreads, t, mops, optype, passed_verification, npbversion, compiletime, cc, clink, c_lib, c_inc, cflags, clinkflags, rand); }

// start code fragment :: Definition of main ... type: ((int<4>,ref<array<ref<array<char,1>>,1>>)->int<4>) //
int main(int argc, char** argv){
	struct __insieme_globals* var_1 = malloc(sizeof(struct __insieme_globals));
	((*(&((*var_1).sec))) = (((int)(0))-1));
	((*(&((*var_1).B_test_index_array))) = ((__insieme_type_2){{41869, 812306, 5102857, 18232239, 26860214}}));
	((*(&((*var_1).B_test_rank_array))) = ((__insieme_type_2){{33422937, 10244, 59149, 33135281, 99}}));
	((*(&((*var_1).C_test_index_array))) = ((__insieme_type_2){{44172927, 72999161, 74326391, 129606274, 21736814}}));
	((*(&((*var_1).C_test_rank_array))) = ((__insieme_type_2){{61147, 882988, 266290, 133997595, 133525895}}));
	((*(&((*var_1).KS))) = 0);
	((*(&((*var_1).R23))) = 0.0);
	((*(&((*var_1).R46))) = 0.0);
	((*(&((*var_1).key_buff_ptr_global))) = ((__insieme_type_4_init_uniform(0)).data));
	((*(&((*var_1).passed_verification))) = 0);
	((*(&((*var_1).S_test_index_array))) = ((__insieme_type_2){{48427, 17148, 23627, 62548, 4431}}));
	((*(&((*var_1).S_test_rank_array))) = ((__insieme_type_2){{0, 18, 346, 64917, 65463}}));
	((*(&((*var_1).W_test_index_array))) = ((__insieme_type_2){{357773, 934767, 875723, 898999, 404505}}));
	((*(&((*var_1).W_test_rank_array))) = ((__insieme_type_2){{1249, 11698, 1039987, 1043896, 1048018}}));
	((*(&((*var_1).A_test_index_array))) = ((__insieme_type_2){{2112377, 662041, 5336171, 3642833, 4250760}}));
	((*(&((*var_1).A_test_rank_array))) = ((__insieme_type_2){{104, 17523, 123928, 8288932, 8388264}}));
	((*(&((*var_1).T23))) = 0.0);
	((*(&((*var_1).T46))) = 0.0);
	int i = 0;
	int iteration = 0;
	int itemp = 0;
	int nthreads = 1;
	double timecounter = 0.0;
	double maxtime = 0.0;
	{
		for(int var_133 = 0; var_133 < 5; var_133 += 1) {
			int var_131 = ((int)('W'));
			switch(var_131) {
			case 'S':
				{
					((((*(&((*var_1).test_index_array))).data[((unsigned int)(var_133))])) = (((*(&((*var_1).S_test_index_array))).data[((unsigned int)(var_133))])));
					((((*(&((*var_1).test_rank_array))).data[((unsigned int)(var_133))])) = (((*(&((*var_1).S_test_rank_array))).data[((unsigned int)(var_133))])));
				}; break;
			case 'A':
				{
					((((*(&((*var_1).test_index_array))).data[((unsigned int)(var_133))])) = (((*(&((*var_1).A_test_index_array))).data[((unsigned int)(var_133))])));
					((((*(&((*var_1).test_rank_array))).data[((unsigned int)(var_133))])) = (((*(&((*var_1).A_test_rank_array))).data[((unsigned int)(var_133))])));
				}; break;
			case 'W':
				{
					((((*(&((*var_1).test_index_array))).data[((unsigned int)(var_133))])) = (((*(&((*var_1).W_test_index_array))).data[((unsigned int)(var_133))])));
					((((*(&((*var_1).test_rank_array))).data[((unsigned int)(var_133))])) = (((*(&((*var_1).W_test_rank_array))).data[((unsigned int)(var_133))])));
				}; break;
			case 'B':
				{
					((((*(&((*var_1).test_index_array))).data[((unsigned int)(var_133))])) = (((*(&((*var_1).B_test_index_array))).data[((unsigned int)(var_133))])));
					((((*(&((*var_1).test_rank_array))).data[((unsigned int)(var_133))])) = (((*(&((*var_1).B_test_rank_array))).data[((unsigned int)(var_133))])));
				}; break;
			case 'C':
				{
					((((*(&((*var_1).test_index_array))).data[((unsigned int)(var_133))])) = (((*(&((*var_1).C_test_index_array))).data[((unsigned int)(var_133))])));
					((((*(&((*var_1).test_rank_array))).data[((unsigned int)(var_133))])) = (((*(&((*var_1).C_test_rank_array))).data[((unsigned int)(var_133))])));
				}; break;
			};
		};
		((i) = (0+(((int)(ceil((((double)((5-0)))/((double)(1))))))*1)));
	};
	{};
	printf("\n\n NAS Parallel Benchmarks 2.3 OpenMP C version - IS Benchmark\n\n", 0);
	printf(" Size:  %d  (class %c)\n", (1<<20), 'W');
	printf(" Iterations:   %d\n", 10);
	timer_clear(var_1, 0);
	create_seq(var_1, 314159265.00, 1220703125.00);
	rank(var_1, 1);
	((*(&((*var_1).passed_verification))) = 0);
	if(('W'!='S')) { printf("\n   iteration\n", 0); };
	timer_start(var_1, 0);
	{
		for(int var_135 = 1; var_135 < (10+1); var_135 += 1) {
			if(('W'!='S')) { printf("        %d\n", var_135); };
			rank(var_1, var_135);
		};
		((iteration) = (1+(((int)(ceil((((double)(((10+1)-1)))/((double)(1))))))*1)));
	};
	timer_stop(var_1, 0);
	((timecounter) = timer_read(var_1, 0));
	full_verify(var_1);
	if(((*(&((*var_1).passed_verification)))!=((5*10)+1))) { ((*(&((*var_1).passed_verification))) = 0); };
	c_print_results("IS", 'W', (1<<20), 0, 0, 10, (nthreads), (timecounter), ((((double)((10*(1<<20))))/(timecounter))/1000000.), "keys ranked", (*(&((*var_1).passed_verification))), "2.3", "02 Dec 2010", "cc", "cc", "-lm", "-I../common", "-O3 ", "-lm", "randlc");
}
static int main_wrap(void* _closure, int argc, char** argv) { return main(argc, argv); }
