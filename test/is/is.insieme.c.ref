// --- Generated Inspire Code ---
#include <alloca.h>
#include <stddef.h>
#include <stdlib.h>
#define bool int
#define true 1
#define false 0
#define null 0
// --- Entry Point ---

// start code fragment :: type_declaration___insieme_globals //
struct __insieme_globals { 
    double(* start)[64];
    double(* elapsed)[64];
    int sec;
    int KS;
    double R23;
    double R46;
    double T23;
    double T46;
    int* key_buff_ptr_global;
    int passed_verification;
    int(* key_array)[1048576];
    int(* key_buff1)[1048576];
    int(* key_buff2)[1048576];
    int(* partial_verify_vals)[5];
    int(* test_index_array)[5];
    int(* test_rank_array)[5];
    int(* S_test_index_array)[5];
    int(* S_test_rank_array)[5];
    int(* W_test_index_array)[5];
    int(* W_test_rank_array)[5];
    int(* A_test_index_array)[5];
    int(* A_test_rank_array)[5];
    int(* B_test_index_array)[5];
    int(* B_test_rank_array)[5];
    int(* C_test_index_array)[5];
    int(* C_test_rank_array)[5];
};

// start code fragment :: Prototype for external function: ceil //
double ceil(double);

// start code fragment :: Prototype for external function: printf //
int printf(char*, ...);

// start code fragment :: Definitions for function type: __insieme_funType_type_0 //
// Abstract prototype for lambdas of type __insieme_funType_type_0
struct __insieme_funType_type_0 { 
    void(*fun)(void*, int);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_0
void call__insieme_funType_type_0(struct __insieme_funType_type_0* lambda, int p1) { return lambda->fun(lambda, p1); }

// start code fragment :: Definitions for function type: __insieme_funType_type_1 //
// Abstract prototype for lambdas of type __insieme_funType_type_1
struct __insieme_funType_type_1 { 
    void(*fun)(void*, int);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: Definition of timer_clear //
void timer_clear(void* _capture, int n) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_13 = ((struct __insieme_funType_type_1*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		((((((((*var_13).elapsed))[0]))[((unsigned int)(n))])) = 0.0);
	}
}


// start code fragment :: Definitions for function type: __insieme_funType_type_2 //
// Abstract prototype for lambdas of type __insieme_funType_type_2
struct __insieme_funType_type_2 { 
    void(*fun)(void*, double, double);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_2
void call__insieme_funType_type_2(struct __insieme_funType_type_2* lambda, double p1, double p2) { return lambda->fun(lambda, p1,p2); }

// start code fragment :: Definitions for function type: __insieme_funType_type_3 //
// Abstract prototype for lambdas of type __insieme_funType_type_3
struct __insieme_funType_type_3 { 
    void(*fun)(void*, double, double);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: Definitions for function type: __insieme_funType_type_4 //
// Abstract prototype for lambdas of type __insieme_funType_type_4
struct __insieme_funType_type_4 { 
    double(*fun)(void*, double*, double*);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_4
double call__insieme_funType_type_4(struct __insieme_funType_type_4* lambda, double* p1, double* p2) { return lambda->fun(lambda, p1,p2); }

// start code fragment :: Definitions for function type: __insieme_funType_type_5 //
// Abstract prototype for lambdas of type __insieme_funType_type_5
struct __insieme_funType_type_5 { 
    double(*fun)(void*, double*, double*);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: Definition of randlc //
double randlc(void* _capture, double* X, double* A) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_26 = ((struct __insieme_funType_type_5*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		double T1 = 0.0;
		double T2 = 0.0;
		double T3 = 0.0;
		double T4 = 0.0;
		double A1 = 0.0;
		double A2 = 0.0;
		double X1 = 0.0;
		double X2 = 0.0;
		double Z = 0.0;
		int i = 0;
		int j = 0;
		if(((((*var_26).KS))==0)) {
			((((*var_26).R23)) = 1.0);
			((((*var_26).R46)) = 1.0);
			((((*var_26).T23)) = 1.0);
			((((*var_26).T46)) = 1.0);
			{
				for(int var_38 = 1; var_38 < (23+1); var_38 += 1) {
					((((*var_26).R23)) = (0.50*(((*var_26).R23))));
					((((*var_26).T23)) = (2.0*(((*var_26).T23))));
				};
				((i) = (1+(((int)(ceil((((double)(((23+1)-1)))/((double)(1))))))*1)));
			};
			{
				for(int var_39 = 1; var_39 < (46+1); var_39 += 1) {
					((((*var_26).R46)) = (0.50*(((*var_26).R46))));
					((((*var_26).T46)) = (2.0*(((*var_26).T46))));
				};
				((i) = (1+(((int)(ceil((((double)(((46+1)-1)))/((double)(1))))))*1)));
			};
			((((*var_26).KS)) = 1);
		};
		((T1) = ((((*var_26).R23))*((A[0]))));
		((j) = ((int)((T1))));
		((A1) = ((double)((j))));
		((A2) = (((A[0]))-((((*var_26).T23))*(A1))));
		((T1) = ((((*var_26).R23))*((X[0]))));
		((j) = ((int)((T1))));
		((X1) = ((double)((j))));
		((X2) = (((X[0]))-((((*var_26).T23))*(X1))));
		((T1) = (((A1)*(X2))+((A2)*(X1))));
		((j) = ((int)(((((*var_26).R23))*(T1)))));
		((T2) = ((double)((j))));
		((Z) = ((T1)-((((*var_26).T23))*(T2))));
		((T3) = (((((*var_26).T23))*(Z))+((A2)*(X2))));
		((j) = ((int)(((((*var_26).R46))*(T3)))));
		((T4) = ((double)((j))));
		(((X[0])) = ((T3)-((((*var_26).T46))*(T4))));
		return ((((*var_26).R46))*((X[0])));;
	}
}


// start code fragment :: Definition of create_seq //
void create_seq(void* _capture, double seed, double a) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_17 = ((struct __insieme_funType_type_3*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		double var_22 = seed;
		double var_23 = a;
		{
			double x = 0.0;
			int i = 0;
			int j = 0;
			int k = 0;
			((k) = ((1<<16)/4));
			{
				for(int var_41 = 0; var_41 < (1<<20); var_41 += 1) {
					((x) = call__insieme_funType_type_4(((struct __insieme_funType_type_4*)(&((struct __insieme_funType_type_5){&randlc, 0, var_17}))), &var_22, &var_23));
					((x) = ((x)+call__insieme_funType_type_4(((struct __insieme_funType_type_4*)(&((struct __insieme_funType_type_5){&randlc, 0, var_17}))), &var_22, &var_23)));
					((x) = ((x)+call__insieme_funType_type_4(((struct __insieme_funType_type_4*)(&((struct __insieme_funType_type_5){&randlc, 0, var_17}))), &var_22, &var_23)));
					((x) = ((x)+call__insieme_funType_type_4(((struct __insieme_funType_type_4*)(&((struct __insieme_funType_type_5){&randlc, 0, var_17}))), &var_22, &var_23)));
					((((((((*var_17).key_array))[0]))[((unsigned int)((var_41)))])) = ((int)((((double)((k)))*(x)))));
				};
				((i) = (0+(((int)(ceil((((double)(((1<<20)-0)))/((double)(1))))))*1)));
			};
		};
	}
}


// start code fragment :: Definitions for function type: __insieme_funType_type_6 //
// Abstract prototype for lambdas of type __insieme_funType_type_6
struct __insieme_funType_type_6 { 
    bool(*fun)(void*);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_6
bool call__insieme_funType_type_6(struct __insieme_funType_type_6* lambda) { return lambda->fun(lambda); }

// start code fragment :: Definitions for function type: __insieme_funType_type_7 //
// Abstract prototype for lambdas of type __insieme_funType_type_7
struct __insieme_funType_type_7 { 
    bool(*fun)(void*);
    const size_t size;
    int* p0;
};

// start code fragment :: Definition of __insieme_supp_8 //
bool __insieme_supp_8(void* _capture) {
	// --------- Captured Stuff - Begin -------------
	int* var_66 = ((struct __insieme_funType_type_7*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	return ((*var_66)<=((1<<20)-1));
}


// start code fragment :: Definition of __insieme_supp_9 //
bool __insieme_supp_9(void* _capture) {
	// --------- Captured Stuff - Begin -------------
	int* var_62 = ((struct __insieme_funType_type_7*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	return ((*var_62)==2);
}


// start code fragment :: Definition of __insieme_supp_10 //
bool __insieme_supp_10(void* _capture) {
	// --------- Captured Stuff - Begin -------------
	int* var_64 = ((struct __insieme_funType_type_7*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	return ((*var_64)==4);
}


// start code fragment :: Definition of rank //
void rank(void* _capture, int iteration) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_44 = ((struct __insieme_funType_type_1*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		int i = 0;
		int j = 0;
		int k = 0;
		int l = 0;
		int m = 0;
		int shift = (16-10);
		int key = 0;
		int min_key_val = 0;
		int max_key_val = 0;
		int prv_buff1[65536];
		{
			((((((((*var_44).key_array))[0]))[((unsigned int)(iteration))])) = iteration);
			((((((((*var_44).key_array))[0]))[((unsigned int)((iteration+10)))])) = ((1<<16)-iteration));
			{
				for(int var_55 = 0; var_55 < 5; var_55 += 1) {
					((((((((*var_44).partial_verify_vals))[0]))[((unsigned int)((var_55)))])) = (((((((*var_44).key_array))[0]))[((unsigned int)((((((((*var_44).test_index_array))[0]))[((unsigned int)((var_55)))]))))])));
				};
				((i) = (0+(((int)(ceil((((double)((5-0)))/((double)(1))))))*1)));
			};
			{
				for(int var_56 = 0; var_56 < (1<<16); var_56 += 1) {
					((((((((*var_44).key_buff1))[0]))[((unsigned int)((var_56)))])) = 0);
				};
				((i) = (0+(((int)(ceil((((double)(((1<<16)-0)))/((double)(1))))))*1)));
			};
		};
		{
			for(int var_57 = 0; var_57 < (1<<16); var_57 += 1) {
				(((prv_buff1[((unsigned int)((var_57)))])) = 0);
			};
			((i) = (0+(((int)(ceil((((double)(((1<<16)-0)))/((double)(1))))))*1)));
		};
		{
			for(int var_58 = 0; var_58 < (1<<20); var_58 += 1) {
				((((((((*var_44).key_buff2))[0]))[((unsigned int)((var_58)))])) = (((((((*var_44).key_array))[0]))[((unsigned int)((var_58)))])));
				(((prv_buff1[((unsigned int)((((((((*var_44).key_buff2))[0]))[((unsigned int)((var_58)))]))))]))++);
			};
			((i) = (0+(((int)(ceil((((double)(((1<<20)-0)))/((double)(1))))))*1)));
		};
		{
			for(int var_59 = 0; var_59 < ((1<<16)-1); var_59 += 1) {
				(((prv_buff1[((unsigned int)(((var_59)+1)))])) = (((prv_buff1[((unsigned int)(((var_59)+1)))]))+((prv_buff1[((unsigned int)((var_59)))]))));
			};
			((i) = (0+(((int)(ceil((((double)((((1<<16)-1)-0)))/((double)(1))))))*1)));
		};
		{
			{
				for(int var_60 = 0; var_60 < (1<<16); var_60 += 1) {
					((((((((*var_44).key_buff1))[0]))[((unsigned int)((var_60)))])) = ((((((((*var_44).key_buff1))[0]))[((unsigned int)((var_60)))]))+((prv_buff1[((unsigned int)((var_60)))]))));
				};
				((i) = (0+(((int)(ceil((((double)(((1<<16)-0)))/((double)(1))))))*1)));
			};
		};
		{
			{
				for(int var_68 = 0; var_68 < 5; var_68 += 1) {
					((k) = (((((((*var_44).partial_verify_vals))[0]))[((unsigned int)((var_68)))])));
					if(((0<=(k))&&((struct __insieme_funType_type_6*)(&((struct __insieme_funType_type_7){&__insieme_supp_8, 0, &k}))))) {
						int var_61 = ((int)('W'));
						switch(var_61) {
						case 'S':
							if(((var_68)<=2)) {
								if(((((((((*var_44).key_buff1))[0]))[((unsigned int)(((k)-1)))]))!=((((((((*var_44).test_rank_array))[0]))[((unsigned int)((var_68)))]))+iteration))) {
									printf("Failed partial verification: iteration %d, test key %d\n", iteration, (var_68));
								} else {
									((((*var_44).passed_verification))++);
								};
							} else {
								if(((((((((*var_44).key_buff1))[0]))[((unsigned int)(((k)-1)))]))!=((((((((*var_44).test_rank_array))[0]))[((unsigned int)((var_68)))]))-iteration))) {
									printf("Failed partial verification: iteration %d, test key %d\n", iteration, (var_68));
								} else {
									((((*var_44).passed_verification))++);
								};
							}; break;
						case 'W':
							if(((var_68)<2)) {
								if(((((((((*var_44).key_buff1))[0]))[((unsigned int)(((k)-1)))]))!=((((((((*var_44).test_rank_array))[0]))[((unsigned int)((var_68)))]))+(iteration-2)))) {
									printf("Failed partial verification: iteration %d, test key %d\n", iteration, (var_68));
								} else {
									((((*var_44).passed_verification))++);
								};
							} else {
								if(((((((((*var_44).key_buff1))[0]))[((unsigned int)(((k)-1)))]))!=((((((((*var_44).test_rank_array))[0]))[((unsigned int)((var_68)))]))-iteration))) {
									printf("Failed partial verification: iteration %d, test key %d\n", iteration, (var_68));
								} else {
									((((*var_44).passed_verification))++);
								};
							}; break;
						case 'A':
							if(((var_68)<=2)) {
								if(((((((((*var_44).key_buff1))[0]))[((unsigned int)(((k)-1)))]))!=((((((((*var_44).test_rank_array))[0]))[((unsigned int)((var_68)))]))+(iteration-1)))) {
									printf("Failed partial verification: iteration %d, test key %d\n", iteration, (var_68));
								} else {
									((((*var_44).passed_verification))++);
								};
							} else {
								if(((((((((*var_44).key_buff1))[0]))[((unsigned int)(((k)-1)))]))!=((((((((*var_44).test_rank_array))[0]))[((unsigned int)((var_68)))]))-(iteration-1)))) {
									printf("Failed partial verification: iteration %d, test key %d\n", iteration, (var_68));
								} else {
									((((*var_44).passed_verification))++);
								};
							}; break;
						case 'B':
							if(((((var_68)==1)||((struct __insieme_funType_type_6*)(&((struct __insieme_funType_type_7){&__insieme_supp_9, 0, &var_68}))))||((struct __insieme_funType_type_6*)(&((struct __insieme_funType_type_7){&__insieme_supp_10, 0, &var_68}))))) {
								if(((((((((*var_44).key_buff1))[0]))[((unsigned int)(((k)-1)))]))!=((((((((*var_44).test_rank_array))[0]))[((unsigned int)((var_68)))]))+iteration))) {
									printf("Failed partial verification: iteration %d, test key %d\n", iteration, (var_68));
								} else {
									((((*var_44).passed_verification))++);
								};
							} else {
								if(((((((((*var_44).key_buff1))[0]))[((unsigned int)(((k)-1)))]))!=((((((((*var_44).test_rank_array))[0]))[((unsigned int)((var_68)))]))-iteration))) {
									printf("Failed partial verification: iteration %d, test key %d\n", iteration, (var_68));
								} else {
									((((*var_44).passed_verification))++);
								};
							}; break;
						case 'C':
							if(((var_68)<=2)) {
								if(((((((((*var_44).key_buff1))[0]))[((unsigned int)(((k)-1)))]))!=((((((((*var_44).test_rank_array))[0]))[((unsigned int)((var_68)))]))+iteration))) {
									printf("Failed partial verification: iteration %d, test key %d\n", iteration, (var_68));
								} else {
									((((*var_44).passed_verification))++);
								};
							} else {
								if(((((((((*var_44).key_buff1))[0]))[((unsigned int)(((k)-1)))]))!=((((((((*var_44).test_rank_array))[0]))[((unsigned int)((var_68)))]))-iteration))) {
									printf("Failed partial verification: iteration %d, test key %d\n", iteration, (var_68));
								} else {
									((((*var_44).passed_verification))++);
								};
							}; break;
						};
					};
				};
				((i) = (0+(((int)(ceil((((double)((5-0)))/((double)(1))))))*1)));
			};
			if((iteration==10)) {
				((((*var_44).key_buff_ptr_global)) = (((((*var_44).key_buff1))[0])));
			};
		};
	}
}


// start code fragment :: Definitions for function type: __insieme_funType_type_11 //
// Abstract prototype for lambdas of type __insieme_funType_type_11
struct __insieme_funType_type_11 { 
    double(*fun)(void*);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_11
double call__insieme_funType_type_11(struct __insieme_funType_type_11* lambda) { return lambda->fun(lambda); }

// start code fragment :: Definitions for function type: __insieme_funType_type_12 //
// Abstract prototype for lambdas of type __insieme_funType_type_12
struct __insieme_funType_type_12 { 
    double(*fun)(void*);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: Definitions for function type: __insieme_funType_type_13 //
// Abstract prototype for lambdas of type __insieme_funType_type_13
struct __insieme_funType_type_13 { 
    void(*fun)(void*, double*);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_13
void call__insieme_funType_type_13(struct __insieme_funType_type_13* lambda, double* p1) { return lambda->fun(lambda, p1); }

// start code fragment :: Definitions for function type: __insieme_funType_type_14 //
// Abstract prototype for lambdas of type __insieme_funType_type_14
struct __insieme_funType_type_14 { 
    void(*fun)(void*, double*);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: type_declaration_timeval //
struct timeval { 
    long tv_sec;
    long tv_usec;
};

// start code fragment :: type_declaration_timezone //
struct timezone { 
    int tz_minuteswest;
    int tz_dsttime;
};

// start code fragment :: Prototype for external function: gettimeofday //
int gettimeofday(struct timeval*, struct timezone*);

// start code fragment :: Definition of wtime //
void wtime(void* _capture, double* t) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_75 = ((struct __insieme_funType_type_14*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		struct timeval tv;
		gettimeofday(&tv, null);
		if(((((*var_75).sec))<0)) {
			((((*var_75).sec)) = ((int)((((tv).tv_sec)))));
		};
		(((t[0])) = (((double)(((((tv).tv_sec))-((long)((((*var_75).sec)))))))+(1.0e-6*((double)((((tv).tv_usec)))))));
	}
}


// start code fragment :: Definition of elapsed_time //
double elapsed_time(void* _capture) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_72 = ((struct __insieme_funType_type_12*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		double t = 0.0;
		call__insieme_funType_type_13(((struct __insieme_funType_type_13*)(&((struct __insieme_funType_type_14){&wtime, 0, var_72}))), &t);
		return (t);;
	}
}


// start code fragment :: Definition of timer_start //
void timer_start(void* _capture, int n) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_71 = ((struct __insieme_funType_type_1*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		((((((((*var_71).start))[0]))[((unsigned int)(n))])) = call__insieme_funType_type_11(((struct __insieme_funType_type_11*)(&((struct __insieme_funType_type_12){&elapsed_time, 0, var_71})))));
	}
}


// start code fragment :: Definition of timer_stop //
void timer_stop(void* _capture, int n) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_82 = ((struct __insieme_funType_type_1*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		double t = 0.0;
		double now = 0.0;
		((now) = call__insieme_funType_type_11(((struct __insieme_funType_type_11*)(&((struct __insieme_funType_type_12){&elapsed_time, 0, var_82})))));
		((t) = ((now)-(((((((*var_82).start))[0]))[((unsigned int)(n))]))));
		((((((((*var_82).elapsed))[0]))[((unsigned int)(n))])) = ((((((((*var_82).elapsed))[0]))[((unsigned int)(n))]))+(t)));
	}
}


// start code fragment :: Definitions for function type: __insieme_funType_type_15 //
// Abstract prototype for lambdas of type __insieme_funType_type_15
struct __insieme_funType_type_15 { 
    double(*fun)(void*, int);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_15
double call__insieme_funType_type_15(struct __insieme_funType_type_15* lambda, int p1) { return lambda->fun(lambda, p1); }

// start code fragment :: Definitions for function type: __insieme_funType_type_16 //
// Abstract prototype for lambdas of type __insieme_funType_type_16
struct __insieme_funType_type_16 { 
    double(*fun)(void*, int);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: Definition of timer_read //
double timer_read(void* _capture, int n) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_87 = ((struct __insieme_funType_type_16*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		return (((((((*var_87).elapsed))[0]))[((unsigned int)(n))]));;
	}
}


// start code fragment :: Definitions for function type: __insieme_funType_type_17 //
// Abstract prototype for lambdas of type __insieme_funType_type_17
struct __insieme_funType_type_17 { 
    void(*fun)(void*);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_17
void call__insieme_funType_type_17(struct __insieme_funType_type_17* lambda) { return lambda->fun(lambda); }

// start code fragment :: Definitions for function type: __insieme_funType_type_18 //
// Abstract prototype for lambdas of type __insieme_funType_type_18
struct __insieme_funType_type_18 { 
    void(*fun)(void*);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: Definition of full_verify //
void full_verify(void* _capture) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_89 = ((struct __insieme_funType_type_18*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		int i = 0;
		int j = 0;
		int k = 0;
		int m = 0;
		int unique_keys = 0;
		{
			for(int var_95 = 0; var_95 < (1<<20); var_95 += 1) {
				((((((((*var_89).key_array))[0]))[((unsigned int)((--(((((*var_89).key_buff_ptr_global))[((unsigned int)((((((((*var_89).key_buff2))[0]))[((unsigned int)((var_95)))]))))])))))])) = (((((((*var_89).key_buff2))[0]))[((unsigned int)((var_95)))])));
			};
			((i) = (0+(((int)(ceil((((double)(((1<<20)-0)))/((double)(1))))))*1)));
		};
		((j) = 0);
		{
			for(int var_96 = 1; var_96 < (1<<20); var_96 += 1) if(((((((((*var_89).key_array))[0]))[((unsigned int)(((var_96)-1)))]))>(((((((*var_89).key_array))[0]))[((unsigned int)((var_96)))])))) {
				((j)++);
			};
			((i) = (1+(((int)(ceil((((double)(((1<<20)-1)))/((double)(1))))))*1)));
		};
		if(((j)!=0)) {
			printf("Full_verify: number of keys out of sort: %d\n", (j));
		} else {
			((((*var_89).passed_verification))++);
		};
	}
}


// start code fragment :: Definitions for function type: __insieme_funType_type_19 //
// Abstract prototype for lambdas of type __insieme_funType_type_19
struct __insieme_funType_type_19 { 
    bool(*fun)(void*);
    const size_t size;
    int p0;
};

// start code fragment :: Definition of __insieme_supp_20 //
bool __insieme_supp_20(void* _capture) {
	// --------- Captured Stuff - Begin -------------
	int var_119 = ((struct __insieme_funType_type_19*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	return (var_119==0);
}


// start code fragment :: Definition of c_print_results //
void c_print_results(char* name, char class, int n1, int n2, int n3, int niter, int nthreads, double t, double mops, char* optype, int passed_verification, char* npbversion, char* compiletime, char* cc, char* clink, char* c_lib, char* c_inc, char* cflags, char* clinkflags, char* rand) {
	{
		char* evalue = "1000";
		printf("\n\n %s Benchmark Completed\n", name);
		printf(" Class           =                        %c\n", ((int)(class)));
		if(((n2==0)&&((struct __insieme_funType_type_6*)(&((struct __insieme_funType_type_19){&__insieme_supp_20, 0, n3}))))) {
			printf(" Size            =             %12d\n", n1);
		} else {
			printf(" Size            =              %3dx%3dx%3d\n", n1, n2, n3);
		};
		printf(" Iterations      =             %12d\n", niter);
		printf(" Threads         =             %12d\n", nthreads);
		printf(" Time in seconds =             %12.2f\n", 0.0);
		printf(" Mop/s total     =             %12.2f\n", 0.0);
		printf(" Operation type  = %24s\n", optype);
		if(((bool)(passed_verification))) {
			printf(" Verification    =               SUCCESSFUL\n", 0);
		} else {
			printf(" Verification    =             UNSUCCESSFUL\n", 0);
		};
		printf(" Version         =             %12s\n", npbversion);
		printf(" Compile date    =             %12s\n", compiletime);
		printf("\n Compile options:\n", 0);
		printf("    CC           = %s\n", cc);
		printf("    CLINK        = %s\n", clink);
		printf("    C_LIB        = %s\n", c_lib);
		printf("    C_INC        = %s\n", c_inc);
		printf("    CFLAGS       = %s\n", cflags);
		printf("    CLINKFLAGS   = %s\n", clinkflags);
		printf("    RAND         = %s\n", rand);
	}
}


// start code fragment :: Definition of main //
int main(int argc, char** argv) {
	{
		struct __insieme_globals var_1 = ((struct __insieme_globals){(calloc(sizeof(double[64]), 1)),
			(calloc(sizeof(double[64]), 1)),
			(((int)(0))-1),
			0,
			0.0,
			0.0,
			0.0,
			0.0,
			null,
			0,
			(calloc(sizeof(int[1048576]), 1)),
			(calloc(sizeof(int[1048576]), 1)),
			(calloc(sizeof(int[1048576]), 1)),
			(calloc(sizeof(int[5]), 1)),
			(calloc(sizeof(int[5]), 1)),
			(calloc(sizeof(int[5]), 1)),
			(memcpy(malloc(sizeof(int[5])), &((int[5]){48427, 17148, 23627, 62548, 4431}), sizeof(int[5]))),
			(memcpy(malloc(sizeof(int[5])), &((int[5]){0, 18, 346, 64917, 65463}), sizeof(int[5]))),
			(memcpy(malloc(sizeof(int[5])), &((int[5]){357773, 934767, 875723, 898999, 404505}), sizeof(int[5]))),
			(memcpy(malloc(sizeof(int[5])), &((int[5]){1249, 11698, 1039987, 1043896, 1048018}), sizeof(int[5]))),
			(memcpy(malloc(sizeof(int[5])), &((int[5]){2112377, 662041, 5336171, 3642833, 4250760}), sizeof(int[5]))),
			(memcpy(malloc(sizeof(int[5])), &((int[5]){104, 17523, 123928, 8288932, 8388264}), sizeof(int[5]))),
			(memcpy(malloc(sizeof(int[5])), &((int[5]){41869, 812306, 5102857, 18232239, 26860214}), sizeof(int[5]))),
			(memcpy(malloc(sizeof(int[5])), &((int[5]){33422937, 10244, 59149, 33135281, 99}), sizeof(int[5]))),
			(memcpy(malloc(sizeof(int[5])), &((int[5]){44172927, 72999161, 74326391, 129606274, 21736814}), sizeof(int[5]))),
			(memcpy(malloc(sizeof(int[5])), &((int[5]){61147, 882988, 266290, 133997595, 133525895}), sizeof(int[5])))
		});
		int i = 0;
		int iteration = 0;
		int itemp = 0;
		int nthreads = 1;
		double timecounter = 0.0;
		double maxtime = 0.0;
		{
			for(int var_124 = 0; var_124 < 5; var_124 += 1) {
				int var_123 = ((int)('W'));
				switch(var_123) {
				case 'S':
					{
						((((((((var_1).test_index_array))[0]))[((unsigned int)((var_124)))])) = (((((((var_1).S_test_index_array))[0]))[((unsigned int)((var_124)))])));
						((((((((var_1).test_rank_array))[0]))[((unsigned int)((var_124)))])) = (((((((var_1).S_test_rank_array))[0]))[((unsigned int)((var_124)))])));
					}; break;
				case 'A':
					{
						((((((((var_1).test_index_array))[0]))[((unsigned int)((var_124)))])) = (((((((var_1).A_test_index_array))[0]))[((unsigned int)((var_124)))])));
						((((((((var_1).test_rank_array))[0]))[((unsigned int)((var_124)))])) = (((((((var_1).A_test_rank_array))[0]))[((unsigned int)((var_124)))])));
					}; break;
				case 'W':
					{
						((((((((var_1).test_index_array))[0]))[((unsigned int)((var_124)))])) = (((((((var_1).W_test_index_array))[0]))[((unsigned int)((var_124)))])));
						((((((((var_1).test_rank_array))[0]))[((unsigned int)((var_124)))])) = (((((((var_1).W_test_rank_array))[0]))[((unsigned int)((var_124)))])));
					}; break;
				case 'B':
					{
						((((((((var_1).test_index_array))[0]))[((unsigned int)((var_124)))])) = (((((((var_1).B_test_index_array))[0]))[((unsigned int)((var_124)))])));
						((((((((var_1).test_rank_array))[0]))[((unsigned int)((var_124)))])) = (((((((var_1).B_test_rank_array))[0]))[((unsigned int)((var_124)))])));
					}; break;
				case 'C':
					{
						((((((((var_1).test_index_array))[0]))[((unsigned int)((var_124)))])) = (((((((var_1).C_test_index_array))[0]))[((unsigned int)((var_124)))])));
						((((((((var_1).test_rank_array))[0]))[((unsigned int)((var_124)))])) = (((((((var_1).C_test_rank_array))[0]))[((unsigned int)((var_124)))])));
					}; break;
				};
			};
			((i) = (0+(((int)(ceil((((double)((5-0)))/((double)(1))))))*1)));
		};
		{};
		printf("\n\n NAS Parallel Benchmarks 2.3 OpenMP C version - IS Benchmark\n\n", 0);
		printf(" Size:  %d  (class %c)\n", (1<<20), 'W');
		printf(" Iterations:   %d\n", 10);
		call__insieme_funType_type_0(((struct __insieme_funType_type_0*)(&((struct __insieme_funType_type_1){&timer_clear, 0, &var_1}))), 0);
		call__insieme_funType_type_2(((struct __insieme_funType_type_2*)(&((struct __insieme_funType_type_3){&create_seq, 0, &var_1}))), 314159265.00, 1220703125.00);
		call__insieme_funType_type_0(((struct __insieme_funType_type_0*)(&((struct __insieme_funType_type_1){&rank, 0, &var_1}))), 1);
		((((var_1).passed_verification)) = 0);
		if(('W'!='S')) {
			printf("\n   iteration\n", 0);
		};
		call__insieme_funType_type_0(((struct __insieme_funType_type_0*)(&((struct __insieme_funType_type_1){&timer_start, 0, &var_1}))), 0);
		{
			for(int var_125 = 1; var_125 < (10+1); var_125 += 1) {
				if(('W'!='S')) {
					printf("        %d\n", (var_125));
				};
				call__insieme_funType_type_0(((struct __insieme_funType_type_0*)(&((struct __insieme_funType_type_1){&rank, 0, &var_1}))), (var_125));
			};
			((iteration) = (1+(((int)(ceil((((double)(((10+1)-1)))/((double)(1))))))*1)));
		};
		call__insieme_funType_type_0(((struct __insieme_funType_type_0*)(&((struct __insieme_funType_type_1){&timer_stop, 0, &var_1}))), 0);
		((timecounter) = ((double)(call__insieme_funType_type_15(((struct __insieme_funType_type_15*)(&((struct __insieme_funType_type_16){&timer_read, 0, &var_1}))), 0))));
		call__insieme_funType_type_17(((struct __insieme_funType_type_17*)(&((struct __insieme_funType_type_18){&full_verify, 0, &var_1}))));
		if(((((var_1).passed_verification))!=((5*10)+1))) {
			((((var_1).passed_verification)) = 0);
		};
		c_print_results("IS", 'W', (1<<20), 0, 0, 10, (nthreads), (timecounter), ((((double)((10*(1<<20))))/(timecounter))/1000000.), "keys ranked", (((var_1).passed_verification)), "2.3", "02 Dec 2010", "cc", "cc", "-lm", "-I../common", "-O3 ", "-lm", "randlc");
	}
}

