// --- Generated Inspire Code ---
#include <alloca.h>
#include <stddef.h>
#include <stdlib.h>
#include <runtime.h>
#define bool int
#define true 1
#define false 0
#define null 0

// start code fragment :: array type definition of __insieme_type_1 <=> array<char,1> //
typedef struct ___insieme_type_1 { 
    char* data;
} __insieme_type_1;

// start code fragment :: array type definition of __insieme_type_0 <=> array<array<char,1>,1> //
typedef struct ___insieme_type_0 { 
    __insieme_type_1* data;
} __insieme_type_0;

// start code fragment :: array type definition of __insieme_type_2 <=> array<int<4>,1> //
typedef struct ___insieme_type_2 { 
    int* data;
} __insieme_type_2;

// start code fragment :: New operator for type ref<array<int<4>,1>> //
static inline __insieme_type_2* _ref_new___insieme_type_3(__insieme_type_2 value) {
    __insieme_type_2* res = malloc(sizeof(__insieme_type_2));
    *res = value;
    return res;
}


// start code fragment :: array type utils of __insieme_type_2 <=> array<int<4>,1> //
// A constructor for the array type __insieme_type_2
static inline __insieme_type_2 __insieme_type_2_ctr(unsigned s1) {
    return ((__insieme_type_2){malloc(sizeof(int)*s1)});
}

// start code fragment :: Prototype for external function: rand ... type: (()->int<4>) //
int rand();
static int rand_wrap(void* _closure) { return rand(); }

// start code fragment :: Prototype of sortIt ... type: ((ref<array<int<4>,1>>,int<4>,int<4>)->unit) //
void sortIt(__insieme_type_2*, int, int);

// start code fragment :: Definition of swapIt ... type: ((ref<array<int<4>,1>>,ref<array<int<4>,1>>)->unit) //
void swapIt(__insieme_type_2* a, __insieme_type_2* b){
	int t = ((*a).data[0]);
	((((*a).data[0])) = (((*b).data[0])));
	((((*b).data[0])) = (t));
}
static void swapIt_wrap(void* _closure, __insieme_type_2* a, __insieme_type_2* b) { swapIt(a, b); }

// start code fragment :: Definition of sortIt ... type: ((ref<array<int<4>,1>>,int<4>,int<4>)->unit) //
void sortIt(__insieme_type_2* arr, int beg, int end) { if((end>(beg+1))){
	int piv = ((*arr).data[((unsigned int)(beg))]);
	int l = (beg+1);
	int r = end;
	while(((l)<(r)))  { if(((((*arr).data[((unsigned int)((l)))]))<=(piv))) { ((l)++); } else  { swapIt((&((__insieme_type_2){&((*arr).data[((unsigned int)((l)))])})), (&((__insieme_type_2){&((*arr).data[((unsigned int)((--(r))))])}))); }; };
	swapIt((&((__insieme_type_2){&((*arr).data[((unsigned int)((--(l))))])})), (&((__insieme_type_2){&((*arr).data[((unsigned int)(beg))])})));
	sortIt(arr, beg, (l));
	sortIt(arr, (r), end);
}; }
static void sortIt_wrap(void* _closure, __insieme_type_2* arr, int beg, int end) { sortIt(arr, beg, end); }

// start code fragment :: Definition of reverseIt ... type: ((ref<array<int<4>,1>>,int<4>,int<4>)->unit) //
void reverseIt(__insieme_type_2* a, int S, int E) { for(int var_16 = 0; var_16 < ((E-S)/2); var_16 += 1)  { swapIt((&((__insieme_type_2){&((*a).data[((unsigned int)((S+var_16)))])})), (&((__insieme_type_2){&((*a).data[((unsigned int)(((E-var_16)-1)))])}))); }; }
static void reverseIt_wrap(void* _closure, __insieme_type_2* a, int S, int E) { reverseIt(a, S, E); }

// start code fragment :: Prototype for external function: printf ... type: ((ref<array<char,1>>,var_list)->int<4>) //
int printf(char*, ...);

// start code fragment :: main function //
int main(int __argc, char** __argv) {
	
	// encapsulating arguments within Insieme Types ...
	int argc = __argc;
	__insieme_type_0 argv = (__insieme_type_0){alloca(sizeof(__insieme_type_1) * argc)};
	for(int i=0; i<argc; ++i) {
		argv.data[i] = (__insieme_type_1){__argv[i]};
	}
	
	// ---- begin of actual code body ----
	{
		__insieme_type_2* a = _ref_new___insieme_type_3((__insieme_type_2_ctr(((((unsigned long)(20000))*sizeof(int))/sizeof(int)))));
		for(int var_24 = 0; var_24 < 10; var_24 += 1) {
			for(int var_22 = 0; var_22 < 20000; var_22 += 1)  { ((((*a).data[((unsigned int)(var_22))])) = (rand()%20000)); };
			sortIt(a, 0, 20000);
			reverseIt(a, 0, 20000);
			sortIt(a, 0, 20000);
			printf(((char*)((*(&((__insieme_type_1){"a[N/2] == %d\n"}))).data)), (((*a).data[((unsigned int)((20000/2)))])));
		};
		free((*a).data);
		return 0;
	}
	// ----  end of actual code body  ----
	
}

