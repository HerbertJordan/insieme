// --- Generated Inspire Code ---
#include <alloca.h>
#include <stddef.h>
#include <runtime.h>
#define bool int
#define true 1
#define false 0
#define null 0

// start code fragment :: vector_type_declaration of __insieme_type_1 <=> vector<int<4>,12> //
typedef struct ___insieme_type_1 { 
    int data[12];
} __insieme_type_1;

// A constructor initializing a vector of the type __insieme_type_1 uniformly
static inline __insieme_type_1 __insieme_type_1_init_uniform(int value) {
	__insieme_type_1 res;
	for (int i=0; i<12;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_2 <=> vector<int<4>,8> //
typedef struct ___insieme_type_2 { 
    int data[8];
} __insieme_type_2;

// A constructor initializing a vector of the type __insieme_type_2 uniformly
static inline __insieme_type_2 __insieme_type_2_init_uniform(int value) {
	__insieme_type_2 res;
	for (int i=0; i<8;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_3 <=> vector<real<8>,64> //
typedef struct ___insieme_type_3 { 
    double data[64];
} __insieme_type_3;

// A constructor initializing a vector of the type __insieme_type_3 uniformly
static inline __insieme_type_3 __insieme_type_3_init_uniform(double value) {
	__insieme_type_3 res;
	for (int i=0; i<64;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: type_declaration___insieme_globals //
struct __insieme_globals { 
    __insieme_type_1 nx;
    __insieme_type_1 ny;
    __insieme_type_1 nz;
    char Class;
    __insieme_type_2 debug_vec;
    __insieme_type_1 m1;
    __insieme_type_1 m2;
    __insieme_type_1 m3;
    int lt;
    int lb;
    int is1;
    int is2;
    int is3;
    int ie1;
    int ie2;
    int ie3;
    double s;
    __insieme_type_3 start;
    __insieme_type_3 elapsed;
    int sec;
};

// start code fragment :: vector_type_declaration of __insieme_type_4 <=> vector<real<8>,4> //
typedef struct ___insieme_type_4 { 
    double data[4];
} __insieme_type_4;

// A constructor initializing a vector of the type __insieme_type_4 uniformly
static inline __insieme_type_4 __insieme_type_4_init_uniform(double value) {
	__insieme_type_4 res;
	for (int i=0; i<4;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: Definition of timer_clear ... type: ((ref<struct<nx:vector<int<4>,12>,ny:vector<int<4>,12>,nz:vector<int<4>,12>,Class:char,debug_vec:vector<int<4>,8>,m1:vector<int<4>,12>,m2:vector<int<4>,12>,m3:vector<int<4>,12>,lt:int<4>,lb:int<4>,is1:int<4>,is2:int<4>,is3:int<4>,ie1:int<4>,ie2:int<4>,ie3:int<4>,s:real<8>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,int<4>)->unit) //
void timer_clear(struct __insieme_globals* var_56, int n) { ((((*(&((*var_56).elapsed))).data[((unsigned int)(n))])) = 0.0); }
static void timer_clear_wrap(void* _closure, struct __insieme_globals* var_56, int n) { timer_clear(var_56, n); }

// start code fragment :: type_declaration_timeval //
struct timeval { 
    long tv_sec;
    long tv_usec;
};

// start code fragment :: type_declaration_timezone //
struct timezone { 
    int tz_minuteswest;
    int tz_dsttime;
};

// start code fragment :: Prototype for external function: gettimeofday ... type: ((ref<array<struct<tv_sec:int<8>,tv_usec:int<8>>,1>>,ref<array<struct<tz_minuteswest:int<4>,tz_dsttime:int<4>>,1>>)->int<4>) //
int gettimeofday(struct timeval*, struct timezone*);
static int gettimeofday_wrap(void* _closure, struct timeval* var_490, struct timezone* var_491) { return gettimeofday(var_490, var_491); }

// start code fragment :: Definition of wtime ... type: ((ref<struct<nx:vector<int<4>,12>,ny:vector<int<4>,12>,nz:vector<int<4>,12>,Class:char,debug_vec:vector<int<4>,8>,m1:vector<int<4>,12>,m2:vector<int<4>,12>,m3:vector<int<4>,12>,lt:int<4>,lb:int<4>,is1:int<4>,is2:int<4>,is3:int<4>,ie1:int<4>,ie2:int<4>,ie3:int<4>,s:real<8>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,ref<array<real<8>,1>>)->unit) //
void wtime(struct __insieme_globals* var_59, double* t){
	struct timeval tv;
	gettimeofday((&tv), 0);
	if(((*(&((*var_59).sec)))<0)) { ((*(&((*var_59).sec))) = ((int)((*(&((tv).tv_sec)))))); };
	(((t[0])) = (((double)(((*(&((tv).tv_sec)))-((long)((*(&((*var_59).sec))))))))+(1.0e-6*((double)((*(&((tv).tv_usec))))))));
}
static void wtime_wrap(void* _closure, struct __insieme_globals* var_59, double* t) { wtime(var_59, t); }

// start code fragment :: Definition of elapsed_time ... type: ((ref<struct<nx:vector<int<4>,12>,ny:vector<int<4>,12>,nz:vector<int<4>,12>,Class:char,debug_vec:vector<int<4>,8>,m1:vector<int<4>,12>,m2:vector<int<4>,12>,m3:vector<int<4>,12>,lt:int<4>,lb:int<4>,is1:int<4>,is2:int<4>,is3:int<4>,ie1:int<4>,ie2:int<4>,ie3:int<4>,s:real<8>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>)->real<8>) //
double elapsed_time(struct __insieme_globals* var_63){
	double t = 0.0;
	wtime(var_63, (&t));
	return (t);
}
static double elapsed_time_wrap(void* _closure, struct __insieme_globals* var_63) { return elapsed_time(var_63); }

// start code fragment :: Definition of timer_start ... type: ((ref<struct<nx:vector<int<4>,12>,ny:vector<int<4>,12>,nz:vector<int<4>,12>,Class:char,debug_vec:vector<int<4>,8>,m1:vector<int<4>,12>,m2:vector<int<4>,12>,m3:vector<int<4>,12>,lt:int<4>,lb:int<4>,is1:int<4>,is2:int<4>,is3:int<4>,ie1:int<4>,ie2:int<4>,ie3:int<4>,s:real<8>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,int<4>)->unit) //
void timer_start(struct __insieme_globals* var_66, int n) { ((((*(&((*var_66).start))).data[((unsigned int)(n))])) = elapsed_time(var_66)); }
static void timer_start_wrap(void* _closure, struct __insieme_globals* var_66, int n) { timer_start(var_66, n); }

// start code fragment :: Prototype for external function: printf ... type: ((ref<array<char,1>>,var_list)->int<4>) //
int printf(char*, ...);

// start code fragment :: Prototype for external function: fopen ... type: ((ref<array<char,1>>,ref<array<char,1>>)->ref<array<rec '_IO_FILE.{'_IO_FILE=struct<_flags:int<4>,_IO_read_ptr:ref<array<char,1>>,_IO_read_end:ref<array<char,1>>,_IO_read_base:ref<array<char,1>>,_IO_write_base:ref<array<char,1>>,_IO_write_ptr:ref<array<char,1>>,_IO_write_end:ref<array<char,1>>,_IO_buf_base:ref<array<char,1>>,_IO_buf_end:ref<array<char,1>>,_IO_save_base:ref<array<char,1>>,_IO_backup_base:ref<array<char,1>>,_IO_save_end:ref<array<char,1>>,_markers:ref<array<'_IO_marker,1>>,_chain:ref<array<'_IO_FILE,1>>,_fileno:int<4>,_flags2:int<4>,_old_offset:int<8>,_cur_column:uint<2>,_vtable_offset:char,_shortbuf:vector<char,1>,_lock:anyRef,_offset:int<8>,__pad1:anyRef,__pad2:anyRef,__pad3:anyRef,__pad4:anyRef,__pad5:uint<8>,_mode:int<4>,_unused2:vector<char,20>>, '_IO_marker=struct<_next:ref<array<'_IO_marker,1>>,_sbuf:ref<array<'_IO_FILE,1>>,_pos:int<4>>},1>>) //
struct FILE* fopen(char*, char*);
static struct FILE* fopen_wrap(void* _closure, char* var_492, char* var_493) { return fopen(var_492, var_493); }

// start code fragment :: Prototype for external function: fscanf ... type: ((ref<array<rec '_IO_FILE.{'_IO_FILE=struct<_flags:int<4>,_IO_read_ptr:ref<array<char,1>>,_IO_read_end:ref<array<char,1>>,_IO_read_base:ref<array<char,1>>,_IO_write_base:ref<array<char,1>>,_IO_write_ptr:ref<array<char,1>>,_IO_write_end:ref<array<char,1>>,_IO_buf_base:ref<array<char,1>>,_IO_buf_end:ref<array<char,1>>,_IO_save_base:ref<array<char,1>>,_IO_backup_base:ref<array<char,1>>,_IO_save_end:ref<array<char,1>>,_markers:ref<array<'_IO_marker,1>>,_chain:ref<array<'_IO_FILE,1>>,_fileno:int<4>,_flags2:int<4>,_old_offset:int<8>,_cur_column:uint<2>,_vtable_offset:char,_shortbuf:vector<char,1>,_lock:anyRef,_offset:int<8>,__pad1:anyRef,__pad2:anyRef,__pad3:anyRef,__pad4:anyRef,__pad5:uint<8>,_mode:int<4>,_unused2:vector<char,20>>, '_IO_marker=struct<_next:ref<array<'_IO_marker,1>>,_sbuf:ref<array<'_IO_FILE,1>>,_pos:int<4>>},1>>,ref<array<char,1>>,var_list)->int<4>) //
int fscanf(struct FILE*, char*, ...);

// start code fragment :: Prototype for external function: fgetc ... type: ((ref<array<rec '_IO_FILE.{'_IO_FILE=struct<_flags:int<4>,_IO_read_ptr:ref<array<char,1>>,_IO_read_end:ref<array<char,1>>,_IO_read_base:ref<array<char,1>>,_IO_write_base:ref<array<char,1>>,_IO_write_ptr:ref<array<char,1>>,_IO_write_end:ref<array<char,1>>,_IO_buf_base:ref<array<char,1>>,_IO_buf_end:ref<array<char,1>>,_IO_save_base:ref<array<char,1>>,_IO_backup_base:ref<array<char,1>>,_IO_save_end:ref<array<char,1>>,_markers:ref<array<'_IO_marker,1>>,_chain:ref<array<'_IO_FILE,1>>,_fileno:int<4>,_flags2:int<4>,_old_offset:int<8>,_cur_column:uint<2>,_vtable_offset:char,_shortbuf:vector<char,1>,_lock:anyRef,_offset:int<8>,__pad1:anyRef,__pad2:anyRef,__pad3:anyRef,__pad4:anyRef,__pad5:uint<8>,_mode:int<4>,_unused2:vector<char,20>>, '_IO_marker=struct<_next:ref<array<'_IO_marker,1>>,_sbuf:ref<array<'_IO_FILE,1>>,_pos:int<4>>},1>>)->int<4>) //
int fgetc(struct FILE*);
static int fgetc_wrap(void* _closure, struct FILE* var_494) { return fgetc(var_494); }

// start code fragment :: Prototype for external function: ceil ... type: ((real<8>)->real<8>) //
double ceil(double);
static double ceil_wrap(void* _closure, double var_495) { return ceil(var_495); }

// start code fragment :: Prototype for external function: fclose ... type: ((ref<array<rec '_IO_FILE.{'_IO_FILE=struct<_flags:int<4>,_IO_read_ptr:ref<array<char,1>>,_IO_read_end:ref<array<char,1>>,_IO_read_base:ref<array<char,1>>,_IO_write_base:ref<array<char,1>>,_IO_write_ptr:ref<array<char,1>>,_IO_write_end:ref<array<char,1>>,_IO_buf_base:ref<array<char,1>>,_IO_buf_end:ref<array<char,1>>,_IO_save_base:ref<array<char,1>>,_IO_backup_base:ref<array<char,1>>,_IO_save_end:ref<array<char,1>>,_markers:ref<array<'_IO_marker,1>>,_chain:ref<array<'_IO_FILE,1>>,_fileno:int<4>,_flags2:int<4>,_old_offset:int<8>,_cur_column:uint<2>,_vtable_offset:char,_shortbuf:vector<char,1>,_lock:anyRef,_offset:int<8>,__pad1:anyRef,__pad2:anyRef,__pad3:anyRef,__pad4:anyRef,__pad5:uint<8>,_mode:int<4>,_unused2:vector<char,20>>, '_IO_marker=struct<_next:ref<array<'_IO_marker,1>>,_sbuf:ref<array<'_IO_FILE,1>>,_pos:int<4>>},1>>)->int<4>) //
int fclose(struct FILE*);
static int fclose_wrap(void* _closure, struct FILE* var_496) { return fclose(var_496); }

// start code fragment :: Definition of setup ... type: ((ref<struct<nx:vector<int<4>,12>,ny:vector<int<4>,12>,nz:vector<int<4>,12>,Class:char,debug_vec:vector<int<4>,8>,m1:vector<int<4>,12>,m2:vector<int<4>,12>,m3:vector<int<4>,12>,lt:int<4>,lb:int<4>,is1:int<4>,is2:int<4>,is3:int<4>,ie1:int<4>,ie2:int<4>,ie3:int<4>,s:real<8>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,ref<array<int<4>,1>>,ref<array<int<4>,1>>,ref<array<int<4>,1>>,int<4>)->unit) //
void setup(struct __insieme_globals* var_123, int* n1, int* n2, int* n3, int lt){
	int k = 0;
	{
		for(int var_130 = (((int)(0))-(lt-1)); var_130 < ((((int)(0))-1)+1); var_130 += 1) {
			((((*(&((*var_123).nx))).data[((unsigned int)((((int)(0))-var_130)))])) = ((((*(&((*var_123).nx))).data[((unsigned int)(((((int)(0))-var_130)+1)))]))/2));
			((((*(&((*var_123).ny))).data[((unsigned int)((((int)(0))-var_130)))])) = ((((*(&((*var_123).ny))).data[((unsigned int)(((((int)(0))-var_130)+1)))]))/2));
			((((*(&((*var_123).nz))).data[((unsigned int)((((int)(0))-var_130)))])) = ((((*(&((*var_123).nz))).data[((unsigned int)(((((int)(0))-var_130)+1)))]))/2));
		};
		((k) = ((lt-1)+(((int)(ceil((((double)((((((int)(0))-1)+1)-(lt-1))))/((double)(1))))))*1)));
	};
	{
		for(int var_132 = 1; var_132 < (lt+1); var_132 += 1) {
			((((*(&((*var_123).m1))).data[((unsigned int)(var_132))])) = ((((*(&((*var_123).nx))).data[((unsigned int)(var_132))]))+2));
			((((*(&((*var_123).m2))).data[((unsigned int)(var_132))])) = ((((*(&((*var_123).nz))).data[((unsigned int)(var_132))]))+2));
			((((*(&((*var_123).m3))).data[((unsigned int)(var_132))])) = ((((*(&((*var_123).ny))).data[((unsigned int)(var_132))]))+2));
		};
		((k) = (1+(((int)(ceil((((double)(((lt+1)-1)))/((double)(1))))))*1)));
	};
	((*(&((*var_123).is1))) = 1);
	((*(&((*var_123).ie1))) = (((*(&((*var_123).nx))).data[((unsigned int)(lt))])));
	(((n1[0])) = ((((*(&((*var_123).nx))).data[((unsigned int)(lt))]))+2));
	((*(&((*var_123).is2))) = 1);
	((*(&((*var_123).ie2))) = (((*(&((*var_123).ny))).data[((unsigned int)(lt))])));
	(((n2[0])) = ((((*(&((*var_123).ny))).data[((unsigned int)(lt))]))+2));
	((*(&((*var_123).is3))) = 1);
	((*(&((*var_123).ie3))) = (((*(&((*var_123).nz))).data[((unsigned int)(lt))])));
	(((n3[0])) = ((((*(&((*var_123).nz))).data[((unsigned int)(lt))]))+2));
	if(((((*(&((*var_123).debug_vec))).data[((unsigned int)(1))]))>=1)){
		printf(" in setup, \n", 0);
		printf("  lt  nx  ny  nz  n1  n2  n3 is1 is2 is3 ie1 ie2 ie3\n", 0);
		printf("%4d%4d%4d%4d%4d%4d%4d%4d%4d%4d%4d%4d%4d\n", lt, (((*(&((*var_123).nx))).data[((unsigned int)(lt))])), (((*(&((*var_123).ny))).data[((unsigned int)(lt))])), (((*(&((*var_123).nz))).data[((unsigned int)(lt))])), ((n1[0])), ((n2[0])), ((n3[0])), (*(&((*var_123).is1))), (*(&((*var_123).is2))), (*(&((*var_123).is3))), (*(&((*var_123).ie1))), (*(&((*var_123).ie2))), (*(&((*var_123).ie3))));
	};
}
static void setup_wrap(void* _closure, struct __insieme_globals* var_123, int* n1, int* n2, int* n3, int lt) { setup(var_123, n1, n2, n3, lt); }

// start code fragment :: Definition of zero3 ... type: ((ref<array<ref<array<ref<array<real<8>,1>>,1>>,1>>,int<4>,int<4>,int<4>)->unit) //
void zero3(double*** z, int n1, int n2, int n3){
	int i1 = 0;
	int i2 = 0;
	int i3 = 0;
	{
		for(int var_162 = 0; var_162 < n3; var_162 += 1)  { {
			for(int var_160 = 0; var_160 < n2; var_160 += 1)  { {
				for(int var_158 = 0; var_158 < n1; var_158 += 1)  { (((((((z[((unsigned int)(var_162))]))[((unsigned int)(var_160))]))[((unsigned int)(var_158))])) = 0.0); };
				((i1) = (0+(((int)(ceil((((double)((n1-0)))/((double)(1))))))*1)));
			}; };
			((i2) = (0+(((int)(ceil((((double)((n2-0)))/((double)(1))))))*1)));
		}; };
		((i3) = (0+(((int)(ceil((((double)((n3-0)))/((double)(1))))))*1)));
	};
}
static void zero3_wrap(void* _closure, double*** z, int n1, int n2, int n3) { zero3(z, n1, n2, n3); }

// start code fragment :: vector_type_declaration of __insieme_type_9 <=> vector<real<8>,2> //
typedef struct ___insieme_type_9 { 
    double data[2];
} __insieme_type_9;

// A constructor initializing a vector of the type __insieme_type_9 uniformly
static inline __insieme_type_9 __insieme_type_9_init_uniform(double value) {
	__insieme_type_9 res;
	for (int i=0; i<2;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_8 <=> vector<vector<real<8>,2>,10> //
typedef struct ___insieme_type_8 { 
    __insieme_type_9 data[10];
} __insieme_type_8;

// A constructor initializing a vector of the type __insieme_type_8 uniformly
static inline __insieme_type_8 __insieme_type_8_init_uniform(__insieme_type_9 value) {
	__insieme_type_8 res;
	for (int i=0; i<10;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_11 <=> vector<int<4>,2> //
typedef struct ___insieme_type_11 { 
    int data[2];
} __insieme_type_11;

// A constructor initializing a vector of the type __insieme_type_11 uniformly
static inline __insieme_type_11 __insieme_type_11_init_uniform(int value) {
	__insieme_type_11 res;
	for (int i=0; i<2;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_10 <=> vector<vector<int<4>,2>,10> //
typedef struct ___insieme_type_10 { 
    __insieme_type_11 data[10];
} __insieme_type_10;

// A constructor initializing a vector of the type __insieme_type_10 uniformly
static inline __insieme_type_10 __insieme_type_10_init_uniform(__insieme_type_11 value) {
	__insieme_type_10 res;
	for (int i=0; i<10;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: vector_type_declaration of __insieme_type_12 <=> vector<vector<vector<int<4>,2>,10>,4> //
typedef struct ___insieme_type_12 { 
    __insieme_type_10 data[4];
} __insieme_type_12;

// A constructor initializing a vector of the type __insieme_type_12 uniformly
static inline __insieme_type_12 __insieme_type_12_init_uniform(__insieme_type_10 value) {
	__insieme_type_12 res;
	for (int i=0; i<4;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: Definition of randlc ... type: ((ref<array<real<8>,1>>,real<8>)->real<8>) //
double randlc(double* x, double a){
	double t1 = 0.0;
	double t2 = 0.0;
	double t3 = 0.0;
	double t4 = 0.0;
	double a1 = 0.0;
	double a2 = 0.0;
	double x1 = 0.0;
	double x2 = 0.0;
	double z = 0.0;
	((t1) = (((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*a));
	((a1) = ((double)(((int)((t1))))));
	((a2) = (a-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(a1))));
	((t1) = (((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((x[0]))));
	((x1) = ((double)(((int)((t1))))));
	((x2) = (((x[0]))-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(x1))));
	((t1) = (((a1)*(x2))+((a2)*(x1))));
	((t2) = ((double)(((int)((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*(t1)))))));
	((z) = ((t1)-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(t2))));
	((t3) = ((((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(z))+((a2)*(x2))));
	((t4) = ((double)(((int)(((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5))*(t3)))))));
	(((x[0])) = ((t3)-((((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0))*(t4))));
	return ((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5))*((x[0])));
}
static double randlc_wrap(void* _closure, double* x, double a) { return randlc(x, a); }

// start code fragment :: Definition of power ... type: ((real<8>,int<4>)->real<8>) //
double power(double a, int n){
	double aj = 0.0;
	int nj = 0;
	double rdummy = 0.0;
	double power = 0.0;
	((power) = 1.0);
	((nj) = n);
	((aj) = a);
	while(((nj)!=0)) {
		if((((nj)%2)==1)) { ((rdummy) = randlc((&power), (aj))); };
		((rdummy) = randlc((&aj), (aj)));
		((nj) = ((nj)/2));
	};
	return (power);
}
static double power_wrap(void* _closure, double a, int n) { return power(a, n); }

// start code fragment :: Prototype for external function: pow ... type: ((real<8>,real<8>)->real<8>) //
double pow(double, double);
static double pow_wrap(void* _closure, double var_497, double var_498) { return pow(var_497, var_498); }

// start code fragment :: Definition of vranlc ... type: ((int<4>,ref<array<real<8>,1>>,real<8>,ref<array<real<8>,1>>)->unit) //
void vranlc(int n, double* x_seed, double a, double* y){
	int i = 0;
	double x = 0.0;
	double t1 = 0.0;
	double t2 = 0.0;
	double t3 = 0.0;
	double t4 = 0.0;
	double a1 = 0.0;
	double a2 = 0.0;
	double x1 = 0.0;
	double x2 = 0.0;
	double z = 0.0;
	((t1) = (((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*a));
	((a1) = ((double)(((int)((t1))))));
	((a2) = (a-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(a1))));
	((x) = ((x_seed[0])));
	{
		for(int var_30 = 1; var_30 < (n+1); var_30 += 1) {
			((t1) = (((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*(x)));
			((x1) = ((double)(((int)((t1))))));
			((x2) = ((x)-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(x1))));
			((t1) = (((a1)*(x2))+((a2)*(x1))));
			((t2) = ((double)(((int)((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*(t1)))))));
			((z) = ((t1)-(((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(t2))));
			((t3) = ((((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*(z))+((a2)*(x2))));
			((t4) = ((double)(((int)(((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5))*(t3)))))));
			((x) = ((t3)-((((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*((((((((((((((((((((((2.0*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0)*2.0))*(t4))));
			(((y[((unsigned int)(var_30))])) = ((((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*((((((((((((((((((((((0.5*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5)*0.5))*(x)));
		};
		((i) = (1+(((int)(ceil((((double)(((n+1)-1)))/((double)(1))))))*1)));
	};
	(((x_seed[0])) = (x));
}
static void vranlc_wrap(void* _closure, int n, double* x_seed, double a, double* y) { vranlc(n, x_seed, a, y); }

// start code fragment :: Definition of bubble ... type: ((ref<array<vector<real<8>,2>,1>>,ref<array<vector<int<4>,2>,1>>,ref<array<vector<int<4>,2>,1>>,ref<array<vector<int<4>,2>,1>>,int<4>,int<4>)->int<4>) //
int bubble(__insieme_type_9* ten, __insieme_type_11* j1, __insieme_type_11* j2, __insieme_type_11* j3, int m, int ind){
	double temp = 0.0;
	int i = 0;
	int j_temp = 0;
	if((ind==1)) { {
		for(int var_219 = 0; var_219 < (m-1); var_219 += 1)  { if((((((ten[((unsigned int)(var_219))])).data[((unsigned int)(ind))]))>((((ten[((unsigned int)((var_219+1)))])).data[((unsigned int)(ind))])))){
			((temp) = ((((ten[((unsigned int)((var_219+1)))])).data[((unsigned int)(ind))])));
			(((((ten[((unsigned int)((var_219+1)))])).data[((unsigned int)(ind))])) = ((((ten[((unsigned int)(var_219))])).data[((unsigned int)(ind))])));
			(((((ten[((unsigned int)(var_219))])).data[((unsigned int)(ind))])) = (temp));
			((j_temp) = ((((j1[((unsigned int)((var_219+1)))])).data[((unsigned int)(ind))])));
			(((((j1[((unsigned int)((var_219+1)))])).data[((unsigned int)(ind))])) = ((((j1[((unsigned int)(var_219))])).data[((unsigned int)(ind))])));
			(((((j1[((unsigned int)(var_219))])).data[((unsigned int)(ind))])) = (j_temp));
			((j_temp) = ((((j2[((unsigned int)((var_219+1)))])).data[((unsigned int)(ind))])));
			(((((j2[((unsigned int)((var_219+1)))])).data[((unsigned int)(ind))])) = ((((j2[((unsigned int)(var_219))])).data[((unsigned int)(ind))])));
			(((((j2[((unsigned int)(var_219))])).data[((unsigned int)(ind))])) = (j_temp));
			((j_temp) = ((((j3[((unsigned int)((var_219+1)))])).data[((unsigned int)(ind))])));
			(((((j3[((unsigned int)((var_219+1)))])).data[((unsigned int)(ind))])) = ((((j3[((unsigned int)(var_219))])).data[((unsigned int)(ind))])));
			(((((j3[((unsigned int)(var_219))])).data[((unsigned int)(ind))])) = (j_temp));
		} else  { return 0; }; };
		((i) = (0+(((int)(ceil((((double)(((m-1)-0)))/((double)(1))))))*1)));
	}; } else  { {
		for(int var_221 = 0; var_221 < (m-1); var_221 += 1)  { if((((((ten[((unsigned int)(var_221))])).data[((unsigned int)(ind))]))<((((ten[((unsigned int)((var_221+1)))])).data[((unsigned int)(ind))])))){
			((temp) = ((((ten[((unsigned int)((var_221+1)))])).data[((unsigned int)(ind))])));
			(((((ten[((unsigned int)((var_221+1)))])).data[((unsigned int)(ind))])) = ((((ten[((unsigned int)(var_221))])).data[((unsigned int)(ind))])));
			(((((ten[((unsigned int)(var_221))])).data[((unsigned int)(ind))])) = (temp));
			((j_temp) = ((((j1[((unsigned int)((var_221+1)))])).data[((unsigned int)(ind))])));
			(((((j1[((unsigned int)((var_221+1)))])).data[((unsigned int)(ind))])) = ((((j1[((unsigned int)(var_221))])).data[((unsigned int)(ind))])));
			(((((j1[((unsigned int)(var_221))])).data[((unsigned int)(ind))])) = (j_temp));
			((j_temp) = ((((j2[((unsigned int)((var_221+1)))])).data[((unsigned int)(ind))])));
			(((((j2[((unsigned int)((var_221+1)))])).data[((unsigned int)(ind))])) = ((((j2[((unsigned int)(var_221))])).data[((unsigned int)(ind))])));
			(((((j2[((unsigned int)(var_221))])).data[((unsigned int)(ind))])) = (j_temp));
			((j_temp) = ((((j3[((unsigned int)((var_221+1)))])).data[((unsigned int)(ind))])));
			(((((j3[((unsigned int)((var_221+1)))])).data[((unsigned int)(ind))])) = ((((j3[((unsigned int)(var_221))])).data[((unsigned int)(ind))])));
			(((((j3[((unsigned int)(var_221))])).data[((unsigned int)(ind))])) = (j_temp));
		} else  { return 0; }; };
		((i) = (0+(((int)(ceil((((double)(((m-1)-0)))/((double)(1))))))*1)));
	}; };
	return 1;
}
static int bubble_wrap(void* _closure, __insieme_type_9* ten, __insieme_type_11* j1, __insieme_type_11* j2, __insieme_type_11* j3, int m, int ind) { return bubble(ten, j1, j2, j3, m, ind); }

// start code fragment :: Definition of comm3 ... type: ((ref<array<ref<array<ref<array<real<8>,1>>,1>>,1>>,int<4>,int<4>,int<4>,int<4>)->unit) //
void comm3(double*** u, int n1, int n2, int n3, int kk){
	int i1 = 0;
	int i2 = 0;
	int i3 = 0;
	{
		for(int var_252 = 1; var_252 < (n3-1); var_252 += 1)  { {
			for(int var_250 = 1; var_250 < (n2-1); var_250 += 1) {
				(((((((u[((unsigned int)(var_252))]))[((unsigned int)(var_250))]))[((unsigned int)((n1-1)))])) = ((((((u[((unsigned int)(var_252))]))[((unsigned int)(var_250))]))[((unsigned int)(1))])));
				(((((((u[((unsigned int)(var_252))]))[((unsigned int)(var_250))]))[((unsigned int)(0))])) = ((((((u[((unsigned int)(var_252))]))[((unsigned int)(var_250))]))[((unsigned int)((n1-2)))])));
			};
			((i2) = (1+(((int)(ceil((((double)(((n2-1)-1)))/((double)(1))))))*1)));
		}; };
		((i3) = (1+(((int)(ceil((((double)(((n3-1)-1)))/((double)(1))))))*1)));
	};
	{
		for(int var_256 = 1; var_256 < (n3-1); var_256 += 1)  { {
			for(int var_254 = 0; var_254 < n1; var_254 += 1) {
				(((((((u[((unsigned int)(var_256))]))[((unsigned int)((n2-1)))]))[((unsigned int)(var_254))])) = ((((((u[((unsigned int)(var_256))]))[((unsigned int)(1))]))[((unsigned int)(var_254))])));
				(((((((u[((unsigned int)(var_256))]))[((unsigned int)(0))]))[((unsigned int)(var_254))])) = ((((((u[((unsigned int)(var_256))]))[((unsigned int)((n2-2)))]))[((unsigned int)(var_254))])));
			};
			((i1) = (0+(((int)(ceil((((double)((n1-0)))/((double)(1))))))*1)));
		}; };
		((i3) = (1+(((int)(ceil((((double)(((n3-1)-1)))/((double)(1))))))*1)));
	};
	{
		for(int var_260 = 0; var_260 < n2; var_260 += 1)  { {
			for(int var_258 = 0; var_258 < n1; var_258 += 1) {
				(((((((u[((unsigned int)((n3-1)))]))[((unsigned int)(var_260))]))[((unsigned int)(var_258))])) = ((((((u[((unsigned int)(1))]))[((unsigned int)(var_260))]))[((unsigned int)(var_258))])));
				(((((((u[((unsigned int)(0))]))[((unsigned int)(var_260))]))[((unsigned int)(var_258))])) = ((((((u[((unsigned int)((n3-2)))]))[((unsigned int)(var_260))]))[((unsigned int)(var_258))])));
			};
			((i1) = (0+(((int)(ceil((((double)((n1-0)))/((double)(1))))))*1)));
		}; };
		((i2) = (0+(((int)(ceil((((double)((n2-0)))/((double)(1))))))*1)));
	};
}
static void comm3_wrap(void* _closure, double*** u, int n1, int n2, int n3, int kk) { comm3(u, n1, n2, n3, kk); }

// start code fragment :: Definition of zran3 ... type: ((ref<struct<nx:vector<int<4>,12>,ny:vector<int<4>,12>,nz:vector<int<4>,12>,Class:char,debug_vec:vector<int<4>,8>,m1:vector<int<4>,12>,m2:vector<int<4>,12>,m3:vector<int<4>,12>,lt:int<4>,lb:int<4>,is1:int<4>,is2:int<4>,is3:int<4>,ie1:int<4>,ie2:int<4>,ie3:int<4>,s:real<8>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,ref<array<ref<array<ref<array<real<8>,1>>,1>>,1>>,int<4>,int<4>,int<4>,int<4>,int<4>,int<4>)->unit) //
void zran3(struct __insieme_globals* var_164, double*** z, int n1, int n2, int n3, int nx, int ny, int k){
	int i0 = 0;
	int m0 = 0;
	int m1 = 0;
	int i1 = 0;
	int i2 = 0;
	int i3 = 0;
	int d1 = 0;
	int e1 = 0;
	int e2 = 0;
	int e3 = 0;
	double xx = 0.0;
	double x0 = 0.0;
	double x1 = 0.0;
	double a1 = 0.0;
	double a2 = 0.0;
	double ai = 0.0;
	__insieme_type_8 ten;
	double best = 0.0;
	int i = 0;
	__insieme_type_10 j1;
	__insieme_type_10 j2;
	__insieme_type_10 j3;
	__insieme_type_12 jg;
	double rdummy = 0.0;
	((a1) = power(pow(5.0, ((double)(13))), nx));
	((a2) = power(pow(5.0, ((double)(13))), (nx*ny)));
	 { zero3(z, n1, n2, n3); };
	((i) = (((*(&((*var_164).is1)))-1)+(nx*(((*(&((*var_164).is2)))-1)+(ny*((*(&((*var_164).is3)))-1))))));
	((ai) = power(pow(5.0, ((double)(13))), (i)));
	((d1) = (((*(&((*var_164).ie1)))-(*(&((*var_164).is1))))+1));
	((e1) = (((*(&((*var_164).ie1)))-(*(&((*var_164).is1))))+2));
	((e2) = (((*(&((*var_164).ie2)))-(*(&((*var_164).is2))))+2));
	((e3) = (((*(&((*var_164).ie3)))-(*(&((*var_164).is3))))+2));
	((x0) = 314159265.e0);
	((rdummy) = randlc((&x0), (ai)));
	{
		for(int var_206 = 1; var_206 < (e3); var_206 += 1) {
			((x1) = (x0));
			{
				for(int var_204 = 1; var_204 < (e2); var_204 += 1) {
					((xx) = (x1));
					vranlc((d1), (&xx), pow(5.0, ((double)(13))), (&(((((z[((unsigned int)(var_206))]))[((unsigned int)(var_204))]))[((unsigned int)(0))])));
					((rdummy) = randlc((&x1), (a1)));
				};
				((i2) = (1+(((int)(ceil((((double)(((e2)-1)))/((double)(1))))))*1)));
			};
			((rdummy) = randlc((&x0), (a2)));
		};
		((i3) = (1+(((int)(ceil((((double)(((e3)-1)))/((double)(1))))))*1)));
	};
	{
		for(int var_208 = 0; var_208 < 10; var_208 += 1) {
			((((((ten).data[((unsigned int)(var_208))])).data[((unsigned int)(1))])) = 0.0);
			((((((j1).data[((unsigned int)(var_208))])).data[((unsigned int)(1))])) = 0);
			((((((j2).data[((unsigned int)(var_208))])).data[((unsigned int)(1))])) = 0);
			((((((j3).data[((unsigned int)(var_208))])).data[((unsigned int)(1))])) = 0);
			((((((ten).data[((unsigned int)(var_208))])).data[((unsigned int)(0))])) = 1.0);
			((((((j1).data[((unsigned int)(var_208))])).data[((unsigned int)(0))])) = 0);
			((((((j2).data[((unsigned int)(var_208))])).data[((unsigned int)(0))])) = 0);
			((((((j3).data[((unsigned int)(var_208))])).data[((unsigned int)(0))])) = 0);
		};
		((i) = (0+(((int)(ceil((((double)((10-0)))/((double)(1))))))*1)));
	};
	{
		for(int var_228 = 1; var_228 < (n3-1); var_228 += 1)  { {
			for(int var_226 = 1; var_226 < (n2-1); var_226 += 1)  { {
				for(int var_224 = 1; var_224 < (n1-1); var_224 += 1) {
					if((((((((z[((unsigned int)(var_228))]))[((unsigned int)(var_226))]))[((unsigned int)(var_224))]))>(((((ten).data[((unsigned int)(0))])).data[((unsigned int)(1))])))){
						((((((ten).data[((unsigned int)(0))])).data[((unsigned int)(1))])) = ((((((z[((unsigned int)(var_228))]))[((unsigned int)(var_226))]))[((unsigned int)(var_224))])));
						((((((j1).data[((unsigned int)(0))])).data[((unsigned int)(1))])) = var_224);
						((((((j2).data[((unsigned int)(0))])).data[((unsigned int)(1))])) = var_226);
						((((((j3).data[((unsigned int)(0))])).data[((unsigned int)(1))])) = var_228);
						bubble((((__insieme_type_9*){(ten).data})), (((__insieme_type_11*){(j1).data})), (((__insieme_type_11*){(j2).data})), (((__insieme_type_11*){(j3).data})), 10, 1);
					};
					if((((((((z[((unsigned int)(var_228))]))[((unsigned int)(var_226))]))[((unsigned int)(var_224))]))<(((((ten).data[((unsigned int)(0))])).data[((unsigned int)(0))])))){
						((((((ten).data[((unsigned int)(0))])).data[((unsigned int)(0))])) = ((((((z[((unsigned int)(var_228))]))[((unsigned int)(var_226))]))[((unsigned int)(var_224))])));
						((((((j1).data[((unsigned int)(0))])).data[((unsigned int)(0))])) = var_224);
						((((((j2).data[((unsigned int)(0))])).data[((unsigned int)(0))])) = var_226);
						((((((j3).data[((unsigned int)(0))])).data[((unsigned int)(0))])) = var_228);
						bubble((((__insieme_type_9*){(ten).data})), (((__insieme_type_11*){(j1).data})), (((__insieme_type_11*){(j2).data})), (((__insieme_type_11*){(j3).data})), 10, 0);
					};
				};
				((i1) = (1+(((int)(ceil((((double)(((n1-1)-1)))/((double)(1))))))*1)));
			}; };
			((i2) = (1+(((int)(ceil((((double)(((n2-1)-1)))/((double)(1))))))*1)));
		}; };
		((i3) = (1+(((int)(ceil((((double)(((n3-1)-1)))/((double)(1))))))*1)));
	};
	((i1) = (10-1));
	((i0) = (10-1));
	{
		for(int var_230 = (((int)(0))-(10-1)); var_230 < ((((int)(0))-0)+1); var_230 += 1) {
			((best) = ((((((z[((unsigned int)((((((j3).data[((unsigned int)((i1)))])).data[((unsigned int)(1))]))))]))[((unsigned int)((((((j2).data[((unsigned int)((i1)))])).data[((unsigned int)(1))]))))]))[((unsigned int)((((((j1).data[((unsigned int)((i1)))])).data[((unsigned int)(1))]))))])));
			if(((best)==((((((z[((unsigned int)((((((j3).data[((unsigned int)((i1)))])).data[((unsigned int)(1))]))))]))[((unsigned int)((((((j2).data[((unsigned int)((i1)))])).data[((unsigned int)(1))]))))]))[((unsigned int)((((((j1).data[((unsigned int)((i1)))])).data[((unsigned int)(1))]))))])))){
				((((((((jg).data[((unsigned int)(0))])).data[((unsigned int)((((int)(0))-var_230)))])).data[((unsigned int)(1))])) = 0);
				((((((((jg).data[((unsigned int)(1))])).data[((unsigned int)((((int)(0))-var_230)))])).data[((unsigned int)(1))])) = (((*(&((*var_164).is1)))-1)+(((((j1).data[((unsigned int)((i1)))])).data[((unsigned int)(1))]))));
				((((((((jg).data[((unsigned int)(2))])).data[((unsigned int)((((int)(0))-var_230)))])).data[((unsigned int)(1))])) = (((*(&((*var_164).is2)))-1)+(((((j2).data[((unsigned int)((i1)))])).data[((unsigned int)(1))]))));
				((((((((jg).data[((unsigned int)(3))])).data[((unsigned int)((((int)(0))-var_230)))])).data[((unsigned int)(1))])) = (((*(&((*var_164).is3)))-1)+(((((j3).data[((unsigned int)((i1)))])).data[((unsigned int)(1))]))));
				((i1) = ((i1)-1));
			} else {
				((((((((jg).data[((unsigned int)(0))])).data[((unsigned int)((((int)(0))-var_230)))])).data[((unsigned int)(1))])) = 0);
				((((((((jg).data[((unsigned int)(1))])).data[((unsigned int)((((int)(0))-var_230)))])).data[((unsigned int)(1))])) = 0);
				((((((((jg).data[((unsigned int)(2))])).data[((unsigned int)((((int)(0))-var_230)))])).data[((unsigned int)(1))])) = 0);
				((((((((jg).data[((unsigned int)(3))])).data[((unsigned int)((((int)(0))-var_230)))])).data[((unsigned int)(1))])) = 0);
			};
			((((((ten).data[((unsigned int)((((int)(0))-var_230)))])).data[((unsigned int)(1))])) = (best));
			((best) = ((((((z[((unsigned int)((((((j3).data[((unsigned int)((i0)))])).data[((unsigned int)(0))]))))]))[((unsigned int)((((((j2).data[((unsigned int)((i0)))])).data[((unsigned int)(0))]))))]))[((unsigned int)((((((j1).data[((unsigned int)((i0)))])).data[((unsigned int)(0))]))))])));
			if(((best)==((((((z[((unsigned int)((((((j3).data[((unsigned int)((i0)))])).data[((unsigned int)(0))]))))]))[((unsigned int)((((((j2).data[((unsigned int)((i0)))])).data[((unsigned int)(0))]))))]))[((unsigned int)((((((j1).data[((unsigned int)((i0)))])).data[((unsigned int)(0))]))))])))){
				((((((((jg).data[((unsigned int)(0))])).data[((unsigned int)((((int)(0))-var_230)))])).data[((unsigned int)(0))])) = 0);
				((((((((jg).data[((unsigned int)(1))])).data[((unsigned int)((((int)(0))-var_230)))])).data[((unsigned int)(0))])) = (((*(&((*var_164).is1)))-1)+(((((j1).data[((unsigned int)((i0)))])).data[((unsigned int)(0))]))));
				((((((((jg).data[((unsigned int)(2))])).data[((unsigned int)((((int)(0))-var_230)))])).data[((unsigned int)(0))])) = (((*(&((*var_164).is2)))-1)+(((((j2).data[((unsigned int)((i0)))])).data[((unsigned int)(0))]))));
				((((((((jg).data[((unsigned int)(3))])).data[((unsigned int)((((int)(0))-var_230)))])).data[((unsigned int)(0))])) = (((*(&((*var_164).is3)))-1)+(((((j3).data[((unsigned int)((i0)))])).data[((unsigned int)(0))]))));
				((i0) = ((i0)-1));
			} else {
				((((((((jg).data[((unsigned int)(0))])).data[((unsigned int)((((int)(0))-var_230)))])).data[((unsigned int)(0))])) = 0);
				((((((((jg).data[((unsigned int)(1))])).data[((unsigned int)((((int)(0))-var_230)))])).data[((unsigned int)(0))])) = 0);
				((((((((jg).data[((unsigned int)(2))])).data[((unsigned int)((((int)(0))-var_230)))])).data[((unsigned int)(0))])) = 0);
				((((((((jg).data[((unsigned int)(3))])).data[((unsigned int)((((int)(0))-var_230)))])).data[((unsigned int)(0))])) = 0);
			};
			((((((ten).data[((unsigned int)((((int)(0))-var_230)))])).data[((unsigned int)(0))])) = (best));
		};
		((i) = ((10-1)+(((int)(ceil((((double)((((((int)(0))-0)+1)-(10-1))))/((double)(1))))))*1)));
	};
	((m1) = ((i1)+1));
	((m0) = ((i0)+1));
	{
		for(int var_236 = 0; var_236 < n3; var_236 += 1)  { {
			for(int var_234 = 0; var_234 < n2; var_234 += 1)  { {
				for(int var_232 = 0; var_232 < n1; var_232 += 1)  { (((((((z[((unsigned int)(var_236))]))[((unsigned int)(var_234))]))[((unsigned int)(var_232))])) = 0.0); };
				((i1) = (0+(((int)(ceil((((double)((n1-0)))/((double)(1))))))*1)));
			}; };
			((i2) = (0+(((int)(ceil((((double)((n2-0)))/((double)(1))))))*1)));
		}; };
		((i3) = (0+(((int)(ceil((((double)((n3-0)))/((double)(1))))))*1)));
	};
	{
		for(int var_238 = (((int)(0))-(10-1)); var_238 < ((((int)(0))-(m0))+1); var_238 += 1)  { (((((((z[((unsigned int)((((((j3).data[((unsigned int)((((int)(0))-var_238)))])).data[((unsigned int)(0))]))))]))[((unsigned int)((((((j2).data[((unsigned int)((((int)(0))-var_238)))])).data[((unsigned int)(0))]))))]))[((unsigned int)((((((j1).data[((unsigned int)((((int)(0))-var_238)))])).data[((unsigned int)(0))]))))])) = (((double)(0))-1.0)); };
		((i) = ((10-1)+(((int)(ceil((((double)((((((int)(0))-(m0))+1)-(10-1))))/((double)(1))))))*1)));
	};
	{
		for(int var_240 = (((int)(0))-(10-1)); var_240 < ((((int)(0))-(m1))+1); var_240 += 1)  { (((((((z[((unsigned int)((((((j3).data[((unsigned int)((((int)(0))-var_240)))])).data[((unsigned int)(1))]))))]))[((unsigned int)((((((j2).data[((unsigned int)((((int)(0))-var_240)))])).data[((unsigned int)(1))]))))]))[((unsigned int)((((((j1).data[((unsigned int)((((int)(0))-var_240)))])).data[((unsigned int)(1))]))))])) = 1.0); };
		((i) = ((10-1)+(((int)(ceil((((double)((((((int)(0))-(m1))+1)-(10-1))))/((double)(1))))))*1)));
	};
	comm3(z, n1, n2, n3, k);
}
static void zran3_wrap(void* _closure, struct __insieme_globals* var_164, double*** z, int n1, int n2, int n3, int nx, int ny, int k) { zran3(var_164, z, n1, n2, n3, nx, ny, k); }

// start code fragment :: Prototype for external function: fabs ... type: ((real<8>)->real<8>) //
double fabs(double);
static double fabs_wrap(void* _closure, double var_499) { return fabs(var_499); }

// start code fragment :: Prototype for external function: sqrt ... type: ((real<8>)->real<8>) //
double sqrt(double);
static double sqrt_wrap(void* _closure, double var_500) { return sqrt(var_500); }

// start code fragment :: Definition of norm2u3 ... type: ((ref<struct<nx:vector<int<4>,12>,ny:vector<int<4>,12>,nz:vector<int<4>,12>,Class:char,debug_vec:vector<int<4>,8>,m1:vector<int<4>,12>,m2:vector<int<4>,12>,m3:vector<int<4>,12>,lt:int<4>,lb:int<4>,is1:int<4>,is2:int<4>,is3:int<4>,ie1:int<4>,ie2:int<4>,ie3:int<4>,s:real<8>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,ref<array<ref<array<ref<array<real<8>,1>>,1>>,1>>,int<4>,int<4>,int<4>,ref<array<real<8>,1>>,ref<array<real<8>,1>>,int<4>,int<4>,int<4>)->unit) //
void norm2u3(struct __insieme_globals* var_263, double*** r, int n1, int n2, int n3, double* rnm2, double* rnmu, int nx, int ny, int nz){
	double tmp = 0.0;
	int i3 = 0;
	int i2 = 0;
	int i1 = 0;
	int n = 0;
	double p_s = 0.0;
	double p_a = 0.0;
	((n) = ((nx*ny)*nz));
	{
		for(int var_285 = 1; var_285 < (n3-1); var_285 += 1)  { {
			for(int var_283 = 1; var_283 < (n2-1); var_283 += 1)  { {
				for(int var_281 = 1; var_281 < (n1-1); var_281 += 1) {
					((p_s) = ((p_s)+(((((((r[((unsigned int)(var_285))]))[((unsigned int)(var_283))]))[((unsigned int)(var_281))]))*((((((r[((unsigned int)(var_285))]))[((unsigned int)(var_283))]))[((unsigned int)(var_281))])))));
					((tmp) = fabs(((((((r[((unsigned int)(var_285))]))[((unsigned int)(var_283))]))[((unsigned int)(var_281))]))));
					if(((tmp)>(p_a))) { ((p_a) = (tmp)); };
				};
				((i1) = (1+(((int)(ceil((((double)(((n1-1)-1)))/((double)(1))))))*1)));
			}; };
			((i2) = (1+(((int)(ceil((((double)(((n2-1)-1)))/((double)(1))))))*1)));
		}; };
		((i3) = (1+(((int)(ceil((((double)(((n3-1)-1)))/((double)(1))))))*1)));
	};
	{
		((*(&((*var_263).s))) = ((*(&((*var_263).s)))+(p_s)));
		if(((p_a)>((rnmu[0])))) { (((rnmu[0])) = (p_a)); };
	};
	{
		(((rnm2[0])) = sqrt(((*(&((*var_263).s)))/((double)((n))))));
		((*(&((*var_263).s))) = 0.0);
	};
}
static void norm2u3_wrap(void* _closure, struct __insieme_globals* var_263, double*** r, int n1, int n2, int n3, double* rnm2, double* rnmu, int nx, int ny, int nz) { norm2u3(var_263, r, n1, n2, n3, rnm2, rnmu, nx, ny, nz); }

// start code fragment :: vector_type_declaration of __insieme_type_13 <=> vector<real<8>,1037> //
typedef struct ___insieme_type_13 { 
    double data[1037];
} __insieme_type_13;

// A constructor initializing a vector of the type __insieme_type_13 uniformly
static inline __insieme_type_13 __insieme_type_13_init_uniform(double value) {
	__insieme_type_13 res;
	for (int i=0; i<1037;++i) {
	    res.data[i] = value;
	}
	return res;
}


// start code fragment :: Definition of rep_nrm ... type: ((ref<struct<nx:vector<int<4>,12>,ny:vector<int<4>,12>,nz:vector<int<4>,12>,Class:char,debug_vec:vector<int<4>,8>,m1:vector<int<4>,12>,m2:vector<int<4>,12>,m3:vector<int<4>,12>,lt:int<4>,lb:int<4>,is1:int<4>,is2:int<4>,is3:int<4>,ie1:int<4>,ie2:int<4>,ie3:int<4>,s:real<8>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,ref<array<ref<array<ref<array<real<8>,1>>,1>>,1>>,int<4>,int<4>,int<4>,ref<array<char,1>>,int<4>)->unit) //
void rep_nrm(struct __insieme_globals* var_309, double*** u, int n1, int n2, int n3, char* title, int kk){
	double rnm2 = 0.0;
	double rnmu = 0.0;
	norm2u3(var_309, u, n1, n2, n3, (&rnm2), (&rnmu), (((*(&((*var_309).nx))).data[((unsigned int)(kk))])), (((*(&((*var_309).ny))).data[((unsigned int)(kk))])), (((*(&((*var_309).nz))).data[((unsigned int)(kk))])));
	printf(" Level%2d in %8s: norms =%21.14e%21.14e\n", kk, title, (rnm2), (rnmu));
}
static void rep_nrm_wrap(void* _closure, struct __insieme_globals* var_309, double*** u, int n1, int n2, int n3, char* title, int kk) { rep_nrm(var_309, u, n1, n2, n3, title, kk); }

// start code fragment :: Definition of showall ... type: ((ref<array<ref<array<ref<array<real<8>,1>>,1>>,1>>,int<4>,int<4>,int<4>)->unit) //
void showall(double*** z, int n1, int n2, int n3){
	int i1 = 0;
	int i2 = 0;
	int i3 = 0;
	int m1 = 0;
	int m2 = 0;
	int m3 = 0;
	((m1) = (((n1<18))?(n1):(18)));
	((m2) = (((n2<14))?(n2):(14)));
	((m3) = (((n3<18))?(n3):(18)));
	printf("\n", 0);{
		for(int var_343 = 0; var_343 < (m3); var_343 += 1) {
			{
				for(int var_341 = 0; var_341 < (m1); var_341 += 1) {
					{
						for(int var_339 = 0; var_339 < (m2); var_339 += 1)  { printf("%6.3f", ((((((z[((unsigned int)(var_343))]))[((unsigned int)(var_339))]))[((unsigned int)(var_341))]))); };
						((i2) = (0+(((int)(ceil((((double)(((m2)-0)))/((double)(1))))))*1)));
					};
					printf("\n", 0);
				};
				((i1) = (0+(((int)(ceil((((double)(((m1)-0)))/((double)(1))))))*1)));
			};
			printf(" - - - - - - - \n", 0);
		};
		((i3) = (0+(((int)(ceil((((double)(((m3)-0)))/((double)(1))))))*1)));
	};
	printf("\n", 0);
}
static void showall_wrap(void* _closure, double*** z, int n1, int n2, int n3) { showall(z, n1, n2, n3); }

// start code fragment :: Definition of resid ... type: ((ref<struct<nx:vector<int<4>,12>,ny:vector<int<4>,12>,nz:vector<int<4>,12>,Class:char,debug_vec:vector<int<4>,8>,m1:vector<int<4>,12>,m2:vector<int<4>,12>,m3:vector<int<4>,12>,lt:int<4>,lb:int<4>,is1:int<4>,is2:int<4>,is3:int<4>,ie1:int<4>,ie2:int<4>,ie3:int<4>,s:real<8>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,ref<array<ref<array<ref<array<real<8>,1>>,1>>,1>>,ref<array<ref<array<ref<array<real<8>,1>>,1>>,1>>,ref<array<ref<array<ref<array<real<8>,1>>,1>>,1>>,int<4>,int<4>,int<4>,ref<array<real<8>,1>>,int<4>)->unit) //
void resid(struct __insieme_globals* var_287, double*** u, double*** v, double*** r, int n1, int n2, int n3, double* a, int k){
	int i3 = 0;
	int i2 = 0;
	int i1 = 0;
	__insieme_type_13 u1;
	__insieme_type_13 u2;
	{
		for(int var_308 = 1; var_308 < (n3-1); var_308 += 1)  { {
			for(int var_306 = 1; var_306 < (n2-1); var_306 += 1) {
				{
					for(int var_302 = 0; var_302 < n1; var_302 += 1) {
						((((u1).data[((unsigned int)(var_302))])) = (((((((((u[((unsigned int)(var_308))]))[((unsigned int)((var_306-1)))]))[((unsigned int)(var_302))]))+((((((u[((unsigned int)(var_308))]))[((unsigned int)((var_306+1)))]))[((unsigned int)(var_302))])))+((((((u[((unsigned int)((var_308-1)))]))[((unsigned int)(var_306))]))[((unsigned int)(var_302))])))+((((((u[((unsigned int)((var_308+1)))]))[((unsigned int)(var_306))]))[((unsigned int)(var_302))]))));
						((((u2).data[((unsigned int)(var_302))])) = (((((((((u[((unsigned int)((var_308-1)))]))[((unsigned int)((var_306-1)))]))[((unsigned int)(var_302))]))+((((((u[((unsigned int)((var_308-1)))]))[((unsigned int)((var_306+1)))]))[((unsigned int)(var_302))])))+((((((u[((unsigned int)((var_308+1)))]))[((unsigned int)((var_306-1)))]))[((unsigned int)(var_302))])))+((((((u[((unsigned int)((var_308+1)))]))[((unsigned int)((var_306+1)))]))[((unsigned int)(var_302))]))));
					};
					((i1) = (0+(((int)(ceil((((double)((n1-0)))/((double)(1))))))*1)));
				};
				{
					for(int var_304 = 1; var_304 < (n1-1); var_304 += 1)  { (((((((r[((unsigned int)(var_308))]))[((unsigned int)(var_306))]))[((unsigned int)(var_304))])) = (((((((((v[((unsigned int)(var_308))]))[((unsigned int)(var_306))]))[((unsigned int)(var_304))]))-(((a[((unsigned int)(0))]))*((((((u[((unsigned int)(var_308))]))[((unsigned int)(var_306))]))[((unsigned int)(var_304))]))))-(((a[((unsigned int)(2))]))*(((((u2).data[((unsigned int)(var_304))]))+(((u1).data[((unsigned int)((var_304-1)))])))+(((u1).data[((unsigned int)((var_304+1)))])))))-(((a[((unsigned int)(3))]))*((((u2).data[((unsigned int)((var_304-1)))]))+(((u2).data[((unsigned int)((var_304+1)))])))))); };
					((i1) = (1+(((int)(ceil((((double)(((n1-1)-1)))/((double)(1))))))*1)));
				};
			};
			((i2) = (1+(((int)(ceil((((double)(((n2-1)-1)))/((double)(1))))))*1)));
		}; };
		((i3) = (1+(((int)(ceil((((double)(((n3-1)-1)))/((double)(1))))))*1)));
	};
	comm3(r, n1, n2, n3, k);
	if(((((*(&((*var_287).debug_vec))).data[((unsigned int)(0))]))>=1)) { rep_nrm(var_287, r, n1, n2, n3, "   resid", k); };
	if(((((*(&((*var_287).debug_vec))).data[((unsigned int)(2))]))>=k)) { showall(r, n1, n2, n3); };
}
static void resid_wrap(void* _closure, struct __insieme_globals* var_287, double*** u, double*** v, double*** r, int n1, int n2, int n3, double* a, int k) { resid(var_287, u, v, r, n1, n2, n3, a, k); }

// start code fragment :: Definition of rprj3 ... type: ((ref<struct<nx:vector<int<4>,12>,ny:vector<int<4>,12>,nz:vector<int<4>,12>,Class:char,debug_vec:vector<int<4>,8>,m1:vector<int<4>,12>,m2:vector<int<4>,12>,m3:vector<int<4>,12>,lt:int<4>,lb:int<4>,is1:int<4>,is2:int<4>,is3:int<4>,ie1:int<4>,ie2:int<4>,ie3:int<4>,s:real<8>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,ref<array<ref<array<ref<array<real<8>,1>>,1>>,1>>,int<4>,int<4>,int<4>,ref<array<ref<array<ref<array<real<8>,1>>,1>>,1>>,int<4>,int<4>,int<4>,int<4>)->unit) //
void rprj3(struct __insieme_globals* var_357, double*** r, int m1k, int m2k, int m3k, double*** s, int m1j, int m2j, int m3j, int k){
	int j3 = 0;
	int j2 = 0;
	int j1 = 0;
	int i3 = 0;
	int i2 = 0;
	int i1 = 0;
	int d1 = 0;
	int d2 = 0;
	int d3 = 0;
	__insieme_type_13 x1;
	__insieme_type_13 y1;
	double x2 = 0.0;
	double y2 = 0.0;
	if((m1k==3)) { ((d1) = 2); } else  { ((d1) = 1); };
	if((m2k==3)) { ((d2) = 2); } else  { ((d2) = 1); };
	if((m3k==3)) { ((d3) = 2); } else  { ((d3) = 1); };
	{
		for(int var_387 = 1; var_387 < (m3j-1); var_387 += 1) {
			((i3) = ((2*var_387)-(d3)));
			{
				for(int var_385 = 1; var_385 < (m2j-1); var_385 += 1) {
					((i2) = ((2*var_385)-(d2)));
					{
						for(int var_381 = 1; var_381 < m1j; var_381 += 1) {
							((i1) = ((2*var_381)-(d1)));
							((((x1).data[((unsigned int)((i1)))])) = (((((((((r[((unsigned int)(((i3)+1)))]))[((unsigned int)((i2)))]))[((unsigned int)((i1)))]))+((((((r[((unsigned int)(((i3)+1)))]))[((unsigned int)(((i2)+2)))]))[((unsigned int)((i1)))])))+((((((r[((unsigned int)((i3)))]))[((unsigned int)(((i2)+1)))]))[((unsigned int)((i1)))])))+((((((r[((unsigned int)(((i3)+2)))]))[((unsigned int)(((i2)+1)))]))[((unsigned int)((i1)))]))));
							((((y1).data[((unsigned int)((i1)))])) = (((((((((r[((unsigned int)((i3)))]))[((unsigned int)((i2)))]))[((unsigned int)((i1)))]))+((((((r[((unsigned int)(((i3)+2)))]))[((unsigned int)((i2)))]))[((unsigned int)((i1)))])))+((((((r[((unsigned int)((i3)))]))[((unsigned int)(((i2)+2)))]))[((unsigned int)((i1)))])))+((((((r[((unsigned int)(((i3)+2)))]))[((unsigned int)(((i2)+2)))]))[((unsigned int)((i1)))]))));
						};
						((j1) = (1+(((int)(ceil((((double)((m1j-1)))/((double)(1))))))*1)));
					};
					{
						for(int var_383 = 1; var_383 < (m1j-1); var_383 += 1) {
							((i1) = ((2*var_383)-(d1)));
							((y2) = (((((((((r[((unsigned int)((i3)))]))[((unsigned int)((i2)))]))[((unsigned int)(((i1)+1)))]))+((((((r[((unsigned int)(((i3)+2)))]))[((unsigned int)((i2)))]))[((unsigned int)(((i1)+1)))])))+((((((r[((unsigned int)((i3)))]))[((unsigned int)(((i2)+2)))]))[((unsigned int)(((i1)+1)))])))+((((((r[((unsigned int)(((i3)+2)))]))[((unsigned int)(((i2)+2)))]))[((unsigned int)(((i1)+1)))]))));
							((x2) = (((((((((r[((unsigned int)(((i3)+1)))]))[((unsigned int)((i2)))]))[((unsigned int)(((i1)+1)))]))+((((((r[((unsigned int)(((i3)+1)))]))[((unsigned int)(((i2)+2)))]))[((unsigned int)(((i1)+1)))])))+((((((r[((unsigned int)((i3)))]))[((unsigned int)(((i2)+1)))]))[((unsigned int)(((i1)+1)))])))+((((((r[((unsigned int)(((i3)+2)))]))[((unsigned int)(((i2)+1)))]))[((unsigned int)(((i1)+1)))]))));
							(((((((s[((unsigned int)(var_387))]))[((unsigned int)(var_385))]))[((unsigned int)(var_383))])) = ((((0.5*((((((r[((unsigned int)(((i3)+1)))]))[((unsigned int)(((i2)+1)))]))[((unsigned int)(((i1)+1)))])))+(0.25*((((((((r[((unsigned int)(((i3)+1)))]))[((unsigned int)(((i2)+1)))]))[((unsigned int)((i1)))]))+((((((r[((unsigned int)(((i3)+1)))]))[((unsigned int)(((i2)+1)))]))[((unsigned int)(((i1)+2)))])))+(x2))))+(0.125*(((((x1).data[((unsigned int)((i1)))]))+(((x1).data[((unsigned int)(((i1)+2)))])))+(y2))))+(0.0625*((((y1).data[((unsigned int)((i1)))]))+(((y1).data[((unsigned int)(((i1)+2)))]))))));
						};
						((j1) = (1+(((int)(ceil((((double)(((m1j-1)-1)))/((double)(1))))))*1)));
					};
				};
				((j2) = (1+(((int)(ceil((((double)(((m2j-1)-1)))/((double)(1))))))*1)));
			};
		};
		((j3) = (1+(((int)(ceil((((double)(((m3j-1)-1)))/((double)(1))))))*1)));
	};
	comm3(s, m1j, m2j, m3j, (k-1));
	if(((((*(&((*var_357).debug_vec))).data[((unsigned int)(0))]))>=1)) { rep_nrm(var_357, s, m1j, m2j, m3j, "   rprj3", (k-1)); };
	if(((((*(&((*var_357).debug_vec))).data[((unsigned int)(4))]))>=k)) { showall(s, m1j, m2j, m3j); };
}
static void rprj3_wrap(void* _closure, struct __insieme_globals* var_357, double*** r, int m1k, int m2k, int m3k, double*** s, int m1j, int m2j, int m3j, int k) { rprj3(var_357, r, m1k, m2k, m3k, s, m1j, m2j, m3j, k); }

// start code fragment :: Definition of psinv ... type: ((ref<struct<nx:vector<int<4>,12>,ny:vector<int<4>,12>,nz:vector<int<4>,12>,Class:char,debug_vec:vector<int<4>,8>,m1:vector<int<4>,12>,m2:vector<int<4>,12>,m3:vector<int<4>,12>,lt:int<4>,lb:int<4>,is1:int<4>,is2:int<4>,is3:int<4>,ie1:int<4>,ie2:int<4>,ie3:int<4>,s:real<8>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,ref<array<ref<array<ref<array<real<8>,1>>,1>>,1>>,ref<array<ref<array<ref<array<real<8>,1>>,1>>,1>>,int<4>,int<4>,int<4>,ref<array<real<8>,1>>,int<4>)->unit) //
void psinv(struct __insieme_globals* var_392, double*** r, double*** u, int n1, int n2, int n3, double* c, int k){
	int i3 = 0;
	int i2 = 0;
	int i1 = 0;
	__insieme_type_13 r1;
	__insieme_type_13 r2;
	{
		for(int var_412 = 1; var_412 < (n3-1); var_412 += 1)  { {
			for(int var_410 = 1; var_410 < (n2-1); var_410 += 1) {
				{
					for(int var_406 = 0; var_406 < n1; var_406 += 1) {
						((((r1).data[((unsigned int)(var_406))])) = (((((((((r[((unsigned int)(var_412))]))[((unsigned int)((var_410-1)))]))[((unsigned int)(var_406))]))+((((((r[((unsigned int)(var_412))]))[((unsigned int)((var_410+1)))]))[((unsigned int)(var_406))])))+((((((r[((unsigned int)((var_412-1)))]))[((unsigned int)(var_410))]))[((unsigned int)(var_406))])))+((((((r[((unsigned int)((var_412+1)))]))[((unsigned int)(var_410))]))[((unsigned int)(var_406))]))));
						((((r2).data[((unsigned int)(var_406))])) = (((((((((r[((unsigned int)((var_412-1)))]))[((unsigned int)((var_410-1)))]))[((unsigned int)(var_406))]))+((((((r[((unsigned int)((var_412-1)))]))[((unsigned int)((var_410+1)))]))[((unsigned int)(var_406))])))+((((((r[((unsigned int)((var_412+1)))]))[((unsigned int)((var_410-1)))]))[((unsigned int)(var_406))])))+((((((r[((unsigned int)((var_412+1)))]))[((unsigned int)((var_410+1)))]))[((unsigned int)(var_406))]))));
					};
					((i1) = (0+(((int)(ceil((((double)((n1-0)))/((double)(1))))))*1)));
				};
				{
					for(int var_408 = 1; var_408 < (n1-1); var_408 += 1)  { (((((((u[((unsigned int)(var_412))]))[((unsigned int)(var_410))]))[((unsigned int)(var_408))])) = (((((((((u[((unsigned int)(var_412))]))[((unsigned int)(var_410))]))[((unsigned int)(var_408))]))+(((c[((unsigned int)(0))]))*((((((r[((unsigned int)(var_412))]))[((unsigned int)(var_410))]))[((unsigned int)(var_408))]))))+(((c[((unsigned int)(1))]))*((((((((r[((unsigned int)(var_412))]))[((unsigned int)(var_410))]))[((unsigned int)((var_408-1)))]))+((((((r[((unsigned int)(var_412))]))[((unsigned int)(var_410))]))[((unsigned int)((var_408+1)))])))+(((r1).data[((unsigned int)(var_408))])))))+(((c[((unsigned int)(2))]))*(((((r2).data[((unsigned int)(var_408))]))+(((r1).data[((unsigned int)((var_408-1)))])))+(((r1).data[((unsigned int)((var_408+1)))])))))); };
					((i1) = (1+(((int)(ceil((((double)(((n1-1)-1)))/((double)(1))))))*1)));
				};
			};
			((i2) = (1+(((int)(ceil((((double)(((n2-1)-1)))/((double)(1))))))*1)));
		}; };
		((i3) = (1+(((int)(ceil((((double)(((n3-1)-1)))/((double)(1))))))*1)));
	};
	comm3(u, n1, n2, n3, k);
	if(((((*(&((*var_392).debug_vec))).data[((unsigned int)(0))]))>=1)) { rep_nrm(var_392, u, n1, n2, n3, "   psinv", k); };
	if(((((*(&((*var_392).debug_vec))).data[((unsigned int)(3))]))>=k)) { showall(u, n1, n2, n3); };
}
static void psinv_wrap(void* _closure, struct __insieme_globals* var_392, double*** r, double*** u, int n1, int n2, int n3, double* c, int k) { psinv(var_392, r, u, n1, n2, n3, c, k); }

// start code fragment :: Definition of interp ... type: ((ref<struct<nx:vector<int<4>,12>,ny:vector<int<4>,12>,nz:vector<int<4>,12>,Class:char,debug_vec:vector<int<4>,8>,m1:vector<int<4>,12>,m2:vector<int<4>,12>,m3:vector<int<4>,12>,lt:int<4>,lb:int<4>,is1:int<4>,is2:int<4>,is3:int<4>,ie1:int<4>,ie2:int<4>,ie3:int<4>,s:real<8>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,ref<array<ref<array<ref<array<real<8>,1>>,1>>,1>>,int<4>,int<4>,int<4>,ref<array<ref<array<ref<array<real<8>,1>>,1>>,1>>,int<4>,int<4>,int<4>,int<4>)->unit) //
void interp(struct __insieme_globals* var_414, double*** z, int mm1, int mm2, int mm3, double*** u, int n1, int n2, int n3, int k){
	int i3 = 0;
	int i2 = 0;
	int i1 = 0;
	int d1 = 0;
	int d2 = 0;
	int d3 = 0;
	int t1 = 0;
	int t2 = 0;
	int t3 = 0;
	__insieme_type_13 z1;
	__insieme_type_13 z2;
	__insieme_type_13 z3;
	if((((n1!=3)&&(n2!=3))&&(n3!=3))) { {
		for(int var_449 = 0; var_449 < (mm3-1); var_449 += 1)  { {
			for(int var_447 = 0; var_447 < (mm2-1); var_447 += 1) {
				{
					for(int var_437 = 0; var_437 < mm1; var_437 += 1) {
						((((z1).data[((unsigned int)(var_437))])) = (((((((z[((unsigned int)(var_449))]))[((unsigned int)((var_447+1)))]))[((unsigned int)(var_437))]))+((((((z[((unsigned int)(var_449))]))[((unsigned int)(var_447))]))[((unsigned int)(var_437))]))));
						((((z2).data[((unsigned int)(var_437))])) = (((((((z[((unsigned int)((var_449+1)))]))[((unsigned int)(var_447))]))[((unsigned int)(var_437))]))+((((((z[((unsigned int)(var_449))]))[((unsigned int)(var_447))]))[((unsigned int)(var_437))]))));
						((((z3).data[((unsigned int)(var_437))])) = ((((((((z[((unsigned int)((var_449+1)))]))[((unsigned int)((var_447+1)))]))[((unsigned int)(var_437))]))+((((((z[((unsigned int)((var_449+1)))]))[((unsigned int)(var_447))]))[((unsigned int)(var_437))])))+(((z1).data[((unsigned int)(var_437))]))));
					};
					((i1) = (0+(((int)(ceil((((double)((mm1-0)))/((double)(1))))))*1)));
				};
				{
					for(int var_439 = 0; var_439 < (mm1-1); var_439 += 1) {
						(((((((u[((unsigned int)((2*var_449)))]))[((unsigned int)((2*var_447)))]))[((unsigned int)((2*var_439)))])) = (((((((u[((unsigned int)((2*var_449)))]))[((unsigned int)((2*var_447)))]))[((unsigned int)((2*var_439)))]))+((((((z[((unsigned int)(var_449))]))[((unsigned int)(var_447))]))[((unsigned int)(var_439))]))));
						(((((((u[((unsigned int)((2*var_449)))]))[((unsigned int)((2*var_447)))]))[((unsigned int)(((2*var_439)+1)))])) = (((((((u[((unsigned int)((2*var_449)))]))[((unsigned int)((2*var_447)))]))[((unsigned int)(((2*var_439)+1)))]))+(0.5*(((((((z[((unsigned int)(var_449))]))[((unsigned int)(var_447))]))[((unsigned int)((var_439+1)))]))+((((((z[((unsigned int)(var_449))]))[((unsigned int)(var_447))]))[((unsigned int)(var_439))]))))));
					};
					((i1) = (0+(((int)(ceil((((double)(((mm1-1)-0)))/((double)(1))))))*1)));
				};
				{
					for(int var_441 = 0; var_441 < (mm1-1); var_441 += 1) {
						(((((((u[((unsigned int)((2*var_449)))]))[((unsigned int)(((2*var_447)+1)))]))[((unsigned int)((2*var_441)))])) = (((((((u[((unsigned int)((2*var_449)))]))[((unsigned int)(((2*var_447)+1)))]))[((unsigned int)((2*var_441)))]))+(0.5*(((z1).data[((unsigned int)(var_441))])))));
						(((((((u[((unsigned int)((2*var_449)))]))[((unsigned int)(((2*var_447)+1)))]))[((unsigned int)(((2*var_441)+1)))])) = (((((((u[((unsigned int)((2*var_449)))]))[((unsigned int)(((2*var_447)+1)))]))[((unsigned int)(((2*var_441)+1)))]))+(0.25*((((z1).data[((unsigned int)(var_441))]))+(((z1).data[((unsigned int)((var_441+1)))]))))));
					};
					((i1) = (0+(((int)(ceil((((double)(((mm1-1)-0)))/((double)(1))))))*1)));
				};
				{
					for(int var_443 = 0; var_443 < (mm1-1); var_443 += 1) {
						(((((((u[((unsigned int)(((2*var_449)+1)))]))[((unsigned int)((2*var_447)))]))[((unsigned int)((2*var_443)))])) = (((((((u[((unsigned int)(((2*var_449)+1)))]))[((unsigned int)((2*var_447)))]))[((unsigned int)((2*var_443)))]))+(0.5*(((z2).data[((unsigned int)(var_443))])))));
						(((((((u[((unsigned int)(((2*var_449)+1)))]))[((unsigned int)((2*var_447)))]))[((unsigned int)(((2*var_443)+1)))])) = (((((((u[((unsigned int)(((2*var_449)+1)))]))[((unsigned int)((2*var_447)))]))[((unsigned int)(((2*var_443)+1)))]))+(0.25*((((z2).data[((unsigned int)(var_443))]))+(((z2).data[((unsigned int)((var_443+1)))]))))));
					};
					((i1) = (0+(((int)(ceil((((double)(((mm1-1)-0)))/((double)(1))))))*1)));
				};
				{
					for(int var_445 = 0; var_445 < (mm1-1); var_445 += 1) {
						(((((((u[((unsigned int)(((2*var_449)+1)))]))[((unsigned int)(((2*var_447)+1)))]))[((unsigned int)((2*var_445)))])) = (((((((u[((unsigned int)(((2*var_449)+1)))]))[((unsigned int)(((2*var_447)+1)))]))[((unsigned int)((2*var_445)))]))+(0.25*(((z3).data[((unsigned int)(var_445))])))));
						(((((((u[((unsigned int)(((2*var_449)+1)))]))[((unsigned int)(((2*var_447)+1)))]))[((unsigned int)(((2*var_445)+1)))])) = (((((((u[((unsigned int)(((2*var_449)+1)))]))[((unsigned int)(((2*var_447)+1)))]))[((unsigned int)(((2*var_445)+1)))]))+(0.125*((((z3).data[((unsigned int)(var_445))]))+(((z3).data[((unsigned int)((var_445+1)))]))))));
					};
					((i1) = (0+(((int)(ceil((((double)(((mm1-1)-0)))/((double)(1))))))*1)));
				};
			};
			((i2) = (0+(((int)(ceil((((double)(((mm2-1)-0)))/((double)(1))))))*1)));
		}; };
		((i3) = (0+(((int)(ceil((((double)(((mm3-1)-0)))/((double)(1))))))*1)));
	}; } else {
		if((n1==3)){
			((d1) = 2);
			((t1) = 1);
		} else {
			((d1) = 1);
			((t1) = 0);
		};
		if((n2==3)){
			((d2) = 2);
			((t2) = 1);
		} else {
			((d2) = 1);
			((t2) = 0);
		};
		if((n3==3)){
			((d3) = 2);
			((t3) = 1);
		} else {
			((d3) = 1);
			((t3) = 0);
		};
		{
			for(int var_467 = (d3); var_467 < ((mm3-1)+1); var_467 += 1) {
				{
					for(int var_459 = (d2); var_459 < ((mm2-1)+1); var_459 += 1) {
						{
							for(int var_455 = (d1); var_455 < ((mm1-1)+1); var_455 += 1)  { (((((((u[((unsigned int)((((2*var_467)-(d3))-1)))]))[((unsigned int)((((2*var_459)-(d2))-1)))]))[((unsigned int)((((2*var_455)-(d1))-1)))])) = (((((((u[((unsigned int)((((2*var_467)-(d3))-1)))]))[((unsigned int)((((2*var_459)-(d2))-1)))]))[((unsigned int)((((2*var_455)-(d1))-1)))]))+((((((z[((unsigned int)((var_467-1)))]))[((unsigned int)((var_459-1)))]))[((unsigned int)((var_455-1)))])))); };
							((i1) = ((d1)+(((int)(ceil((((double)((((mm1-1)+1)-(d1))))/((double)(1))))))*1)));
						};
						{
							for(int var_457 = 1; var_457 < ((mm1-1)+1); var_457 += 1)  { (((((((u[((unsigned int)((((2*var_467)-(d3))-1)))]))[((unsigned int)((((2*var_459)-(d2))-1)))]))[((unsigned int)((((2*var_457)-(t1))-1)))])) = (((((((u[((unsigned int)((((2*var_467)-(d3))-1)))]))[((unsigned int)((((2*var_459)-(d2))-1)))]))[((unsigned int)((((2*var_457)-(t1))-1)))]))+(0.5*(((((((z[((unsigned int)((var_467-1)))]))[((unsigned int)((var_459-1)))]))[((unsigned int)(var_457))]))+((((((z[((unsigned int)((var_467-1)))]))[((unsigned int)((var_459-1)))]))[((unsigned int)((var_457-1)))])))))); };
							((i1) = (1+(((int)(ceil((((double)((((mm1-1)+1)-1)))/((double)(1))))))*1)));
						};
					};
					((i2) = ((d2)+(((int)(ceil((((double)((((mm2-1)+1)-(d2))))/((double)(1))))))*1)));
				};
				{
					for(int var_465 = 1; var_465 < ((mm2-1)+1); var_465 += 1) {
						{
							for(int var_461 = (d1); var_461 < ((mm1-1)+1); var_461 += 1)  { (((((((u[((unsigned int)((((2*var_467)-(d3))-1)))]))[((unsigned int)((((2*var_465)-(t2))-1)))]))[((unsigned int)((((2*var_461)-(d1))-1)))])) = (((((((u[((unsigned int)((((2*var_467)-(d3))-1)))]))[((unsigned int)((((2*var_465)-(t2))-1)))]))[((unsigned int)((((2*var_461)-(d1))-1)))]))+(0.5*(((((((z[((unsigned int)((var_467-1)))]))[((unsigned int)(var_465))]))[((unsigned int)((var_461-1)))]))+((((((z[((unsigned int)((var_467-1)))]))[((unsigned int)((var_465-1)))]))[((unsigned int)((var_461-1)))])))))); };
							((i1) = ((d1)+(((int)(ceil((((double)((((mm1-1)+1)-(d1))))/((double)(1))))))*1)));
						};
						{
							for(int var_463 = 1; var_463 < ((mm1-1)+1); var_463 += 1)  { (((((((u[((unsigned int)((((2*var_467)-(d3))-1)))]))[((unsigned int)((((2*var_465)-(t2))-1)))]))[((unsigned int)((((2*var_463)-(t1))-1)))])) = (((((((u[((unsigned int)((((2*var_467)-(d3))-1)))]))[((unsigned int)((((2*var_465)-(t2))-1)))]))[((unsigned int)((((2*var_463)-(t1))-1)))]))+(0.25*(((((((((z[((unsigned int)((var_467-1)))]))[((unsigned int)(var_465))]))[((unsigned int)(var_463))]))+((((((z[((unsigned int)((var_467-1)))]))[((unsigned int)((var_465-1)))]))[((unsigned int)(var_463))])))+((((((z[((unsigned int)((var_467-1)))]))[((unsigned int)(var_465))]))[((unsigned int)((var_463-1)))])))+((((((z[((unsigned int)((var_467-1)))]))[((unsigned int)((var_465-1)))]))[((unsigned int)((var_463-1)))])))))); };
							((i1) = (1+(((int)(ceil((((double)((((mm1-1)+1)-1)))/((double)(1))))))*1)));
						};
					};
					((i2) = (1+(((int)(ceil((((double)((((mm2-1)+1)-1)))/((double)(1))))))*1)));
				};
			};
			((i3) = ((d3)+(((int)(ceil((((double)((((mm3-1)+1)-(d3))))/((double)(1))))))*1)));
		};
		{
			for(int var_481 = 1; var_481 < ((mm3-1)+1); var_481 += 1) {
				{
					for(int var_473 = (d2); var_473 < ((mm2-1)+1); var_473 += 1) {
						{
							for(int var_469 = (d1); var_469 < ((mm1-1)+1); var_469 += 1)  { (((((((u[((unsigned int)((((2*var_481)-(t3))-1)))]))[((unsigned int)((((2*var_473)-(d2))-1)))]))[((unsigned int)((((2*var_469)-(d1))-1)))])) = (((((((u[((unsigned int)((((2*var_481)-(t3))-1)))]))[((unsigned int)((((2*var_473)-(d2))-1)))]))[((unsigned int)((((2*var_469)-(d1))-1)))]))+(0.5*(((((((z[((unsigned int)(var_481))]))[((unsigned int)((var_473-1)))]))[((unsigned int)((var_469-1)))]))+((((((z[((unsigned int)((var_481-1)))]))[((unsigned int)((var_473-1)))]))[((unsigned int)((var_469-1)))])))))); };
							((i1) = ((d1)+(((int)(ceil((((double)((((mm1-1)+1)-(d1))))/((double)(1))))))*1)));
						};
						{
							for(int var_471 = 1; var_471 < ((mm1-1)+1); var_471 += 1)  { (((((((u[((unsigned int)((((2*var_481)-(t3))-1)))]))[((unsigned int)((((2*var_473)-(d2))-1)))]))[((unsigned int)((((2*var_471)-(t1))-1)))])) = (((((((u[((unsigned int)((((2*var_481)-(t3))-1)))]))[((unsigned int)((((2*var_473)-(d2))-1)))]))[((unsigned int)((((2*var_471)-(t1))-1)))]))+(0.25*(((((((((z[((unsigned int)(var_481))]))[((unsigned int)((var_473-1)))]))[((unsigned int)(var_471))]))+((((((z[((unsigned int)(var_481))]))[((unsigned int)((var_473-1)))]))[((unsigned int)((var_471-1)))])))+((((((z[((unsigned int)((var_481-1)))]))[((unsigned int)((var_473-1)))]))[((unsigned int)(var_471))])))+((((((z[((unsigned int)((var_481-1)))]))[((unsigned int)((var_473-1)))]))[((unsigned int)((var_471-1)))])))))); };
							((i1) = (1+(((int)(ceil((((double)((((mm1-1)+1)-1)))/((double)(1))))))*1)));
						};
					};
					((i2) = ((d2)+(((int)(ceil((((double)((((mm2-1)+1)-(d2))))/((double)(1))))))*1)));
				};
				{
					for(int var_479 = 1; var_479 < ((mm2-1)+1); var_479 += 1) {
						{
							for(int var_475 = (d1); var_475 < ((mm1-1)+1); var_475 += 1)  { (((((((u[((unsigned int)((((2*var_481)-(t3))-1)))]))[((unsigned int)((((2*var_479)-(t2))-1)))]))[((unsigned int)((((2*var_475)-(d1))-1)))])) = (((((((u[((unsigned int)((((2*var_481)-(t3))-1)))]))[((unsigned int)((((2*var_479)-(t2))-1)))]))[((unsigned int)((((2*var_475)-(d1))-1)))]))+(0.25*(((((((((z[((unsigned int)(var_481))]))[((unsigned int)(var_479))]))[((unsigned int)((var_475-1)))]))+((((((z[((unsigned int)(var_481))]))[((unsigned int)((var_479-1)))]))[((unsigned int)((var_475-1)))])))+((((((z[((unsigned int)((var_481-1)))]))[((unsigned int)(var_479))]))[((unsigned int)((var_475-1)))])))+((((((z[((unsigned int)((var_481-1)))]))[((unsigned int)((var_479-1)))]))[((unsigned int)((var_475-1)))])))))); };
							((i1) = ((d1)+(((int)(ceil((((double)((((mm1-1)+1)-(d1))))/((double)(1))))))*1)));
						};
						{
							for(int var_477 = 1; var_477 < ((mm1-1)+1); var_477 += 1)  { (((((((u[((unsigned int)((((2*var_481)-(t3))-1)))]))[((unsigned int)((((2*var_479)-(t2))-1)))]))[((unsigned int)((((2*var_477)-(t1))-1)))])) = (((((((u[((unsigned int)((((2*var_481)-(t3))-1)))]))[((unsigned int)((((2*var_479)-(t2))-1)))]))[((unsigned int)((((2*var_477)-(t1))-1)))]))+(0.125*(((((((((((((z[((unsigned int)(var_481))]))[((unsigned int)(var_479))]))[((unsigned int)(var_477))]))+((((((z[((unsigned int)(var_481))]))[((unsigned int)((var_479-1)))]))[((unsigned int)(var_477))])))+((((((z[((unsigned int)(var_481))]))[((unsigned int)(var_479))]))[((unsigned int)((var_477-1)))])))+((((((z[((unsigned int)(var_481))]))[((unsigned int)((var_479-1)))]))[((unsigned int)((var_477-1)))])))+((((((z[((unsigned int)((var_481-1)))]))[((unsigned int)(var_479))]))[((unsigned int)(var_477))])))+((((((z[((unsigned int)((var_481-1)))]))[((unsigned int)((var_479-1)))]))[((unsigned int)(var_477))])))+((((((z[((unsigned int)((var_481-1)))]))[((unsigned int)(var_479))]))[((unsigned int)((var_477-1)))])))+((((((z[((unsigned int)((var_481-1)))]))[((unsigned int)((var_479-1)))]))[((unsigned int)((var_477-1)))])))))); };
							((i1) = (1+(((int)(ceil((((double)((((mm1-1)+1)-1)))/((double)(1))))))*1)));
						};
					};
					((i2) = (1+(((int)(ceil((((double)((((mm2-1)+1)-1)))/((double)(1))))))*1)));
				};
			};
			((i3) = (1+(((int)(ceil((((double)((((mm3-1)+1)-1)))/((double)(1))))))*1)));
		};
	};
	{
		if(((((*(&((*var_414).debug_vec))).data[((unsigned int)(0))]))>=1)){
			rep_nrm(var_414, z, mm1, mm2, mm3, "z: inter", (k-1));
			rep_nrm(var_414, u, n1, n2, n3, "u: inter", k);
		};
		if(((((*(&((*var_414).debug_vec))).data[((unsigned int)(5))]))>=k)){
			showall(z, mm1, mm2, mm3);
			showall(u, n1, n2, n3);
		};
	};
}
static void interp_wrap(void* _closure, struct __insieme_globals* var_414, double*** z, int mm1, int mm2, int mm3, double*** u, int n1, int n2, int n3, int k) { interp(var_414, z, mm1, mm2, mm3, u, n1, n2, n3, k); }

// start code fragment :: Definition of mg3P ... type: ((ref<struct<nx:vector<int<4>,12>,ny:vector<int<4>,12>,nz:vector<int<4>,12>,Class:char,debug_vec:vector<int<4>,8>,m1:vector<int<4>,12>,m2:vector<int<4>,12>,m3:vector<int<4>,12>,lt:int<4>,lb:int<4>,is1:int<4>,is2:int<4>,is3:int<4>,ie1:int<4>,ie2:int<4>,ie3:int<4>,s:real<8>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,ref<array<ref<array<ref<array<ref<array<real<8>,1>>,1>>,1>>,1>>,ref<array<ref<array<ref<array<real<8>,1>>,1>>,1>>,ref<array<ref<array<ref<array<ref<array<real<8>,1>>,1>>,1>>,1>>,ref<array<real<8>,1>>,ref<array<real<8>,1>>,int<4>,int<4>,int<4>,int<4>)->unit) //
void mg3P(struct __insieme_globals* var_346, double**** u, double*** v, double**** r, double* a, double* c, int n1, int n2, int n3, int k){
	int var_389 = k;
	{
		int j = 0;
		{
			for(int var_391 = (((int)(0))-(*(&((*var_346).lt)))); var_391 < ((((int)(0))-((*(&((*var_346).lb)))+1))+1); var_391 += 1) {
				((j) = ((((int)(0))-var_391)-1));
				rprj3(var_346, ((r[((unsigned int)((((int)(0))-var_391)))])), (((*(&((*var_346).m1))).data[((unsigned int)((((int)(0))-var_391)))])), (((*(&((*var_346).m2))).data[((unsigned int)((((int)(0))-var_391)))])), (((*(&((*var_346).m3))).data[((unsigned int)((((int)(0))-var_391)))])), ((r[((unsigned int)((j)))])), (((*(&((*var_346).m1))).data[((unsigned int)((j)))])), (((*(&((*var_346).m2))).data[((unsigned int)((j)))])), (((*(&((*var_346).m3))).data[((unsigned int)((j)))])), (((int)(0))-var_391));
			};
			((var_389) = ((*(&((*var_346).lt)))+(((int)(ceil((((double)((((((int)(0))-((*(&((*var_346).lb)))+1))+1)-(*(&((*var_346).lt))))))/((double)(1))))))*1)));
		};
		((var_389) = (*(&((*var_346).lb))));
		zero3(((u[((unsigned int)((var_389)))])), (((*(&((*var_346).m1))).data[((unsigned int)((var_389)))])), (((*(&((*var_346).m2))).data[((unsigned int)((var_389)))])), (((*(&((*var_346).m3))).data[((unsigned int)((var_389)))])));
		psinv(var_346, ((r[((unsigned int)((var_389)))])), ((u[((unsigned int)((var_389)))])), (((*(&((*var_346).m1))).data[((unsigned int)((var_389)))])), (((*(&((*var_346).m2))).data[((unsigned int)((var_389)))])), (((*(&((*var_346).m3))).data[((unsigned int)((var_389)))])), c, (var_389));
		{
			for(int var_484 = ((*(&((*var_346).lb)))+1); var_484 < (((*(&((*var_346).lt)))-1)+1); var_484 += 1) {
				((j) = (var_484-1));
				zero3(((u[((unsigned int)(var_484))])), (((*(&((*var_346).m1))).data[((unsigned int)(var_484))])), (((*(&((*var_346).m2))).data[((unsigned int)(var_484))])), (((*(&((*var_346).m3))).data[((unsigned int)(var_484))])));
				interp(var_346, ((u[((unsigned int)((j)))])), (((*(&((*var_346).m1))).data[((unsigned int)((j)))])), (((*(&((*var_346).m2))).data[((unsigned int)((j)))])), (((*(&((*var_346).m3))).data[((unsigned int)((j)))])), ((u[((unsigned int)(var_484))])), (((*(&((*var_346).m1))).data[((unsigned int)(var_484))])), (((*(&((*var_346).m2))).data[((unsigned int)(var_484))])), (((*(&((*var_346).m3))).data[((unsigned int)(var_484))])), var_484);
				resid(var_346, ((u[((unsigned int)(var_484))])), ((r[((unsigned int)(var_484))])), ((r[((unsigned int)(var_484))])), (((*(&((*var_346).m1))).data[((unsigned int)(var_484))])), (((*(&((*var_346).m2))).data[((unsigned int)(var_484))])), (((*(&((*var_346).m3))).data[((unsigned int)(var_484))])), a, var_484);
				psinv(var_346, ((r[((unsigned int)(var_484))])), ((u[((unsigned int)(var_484))])), (((*(&((*var_346).m1))).data[((unsigned int)(var_484))])), (((*(&((*var_346).m2))).data[((unsigned int)(var_484))])), (((*(&((*var_346).m3))).data[((unsigned int)(var_484))])), c, var_484);
			};
			((var_389) = (((*(&((*var_346).lb)))+1)+(((int)(ceil((((double)(((((*(&((*var_346).lt)))-1)+1)-((*(&((*var_346).lb)))+1))))/((double)(1))))))*1)));
		};
		((j) = ((*(&((*var_346).lt)))-1));
		((var_389) = (*(&((*var_346).lt))));
		interp(var_346, ((u[((unsigned int)((j)))])), (((*(&((*var_346).m1))).data[((unsigned int)((j)))])), (((*(&((*var_346).m2))).data[((unsigned int)((j)))])), (((*(&((*var_346).m3))).data[((unsigned int)((j)))])), ((u[((unsigned int)((*(&((*var_346).lt)))))])), n1, n2, n3, (var_389));
		resid(var_346, ((u[((unsigned int)((*(&((*var_346).lt)))))])), v, ((r[((unsigned int)((*(&((*var_346).lt)))))])), n1, n2, n3, a, (var_389));
		psinv(var_346, ((r[((unsigned int)((*(&((*var_346).lt)))))])), ((u[((unsigned int)((*(&((*var_346).lt)))))])), n1, n2, n3, c, (var_389));
	};
}
static void mg3P_wrap(void* _closure, struct __insieme_globals* var_346, double**** u, double*** v, double**** r, double* a, double* c, int n1, int n2, int n3, int k) { mg3P(var_346, u, v, r, a, c, n1, n2, n3, k); }

// start code fragment :: Definition of timer_stop ... type: ((ref<struct<nx:vector<int<4>,12>,ny:vector<int<4>,12>,nz:vector<int<4>,12>,Class:char,debug_vec:vector<int<4>,8>,m1:vector<int<4>,12>,m2:vector<int<4>,12>,m3:vector<int<4>,12>,lt:int<4>,lb:int<4>,is1:int<4>,is2:int<4>,is3:int<4>,ie1:int<4>,ie2:int<4>,ie3:int<4>,s:real<8>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,int<4>)->unit) //
void timer_stop(struct __insieme_globals* var_69, int n){
	double t = 0.0;
	double now = 0.0;
	((now) = elapsed_time(var_69));
	((t) = ((now)-(((*(&((*var_69).start))).data[((unsigned int)(n))]))));
	((((*(&((*var_69).elapsed))).data[((unsigned int)(n))])) = ((((*(&((*var_69).elapsed))).data[((unsigned int)(n))]))+(t)));
}
static void timer_stop_wrap(void* _closure, struct __insieme_globals* var_69, int n) { timer_stop(var_69, n); }

// start code fragment :: Definition of timer_read ... type: ((ref<struct<nx:vector<int<4>,12>,ny:vector<int<4>,12>,nz:vector<int<4>,12>,Class:char,debug_vec:vector<int<4>,8>,m1:vector<int<4>,12>,m2:vector<int<4>,12>,m3:vector<int<4>,12>,lt:int<4>,lb:int<4>,is1:int<4>,is2:int<4>,is3:int<4>,ie1:int<4>,ie2:int<4>,ie3:int<4>,s:real<8>,start:vector<real<8>,64>,elapsed:vector<real<8>,64>,sec:int<4>>>,int<4>)->real<8>) //
double timer_read(struct __insieme_globals* var_74, int n) { return (((*(&((*var_74).elapsed))).data[((unsigned int)(n))])); }
static double timer_read_wrap(void* _closure, struct __insieme_globals* var_74, int n) { return timer_read(var_74, n); }

// start code fragment :: Definition of c_print_results ... type: ((ref<array<char,1>>,char,int<4>,int<4>,int<4>,int<4>,int<4>,real<8>,real<8>,ref<array<char,1>>,int<4>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>,ref<array<char,1>>)->unit) //
void c_print_results(char* name, char class, int n1, int n2, int n3, int niter, int nthreads, double t, double mops, char* optype, int passed_verification, char* npbversion, char* compiletime, char* cc, char* clink, char* c_lib, char* c_inc, char* cflags, char* clinkflags, char* rand){
	char* evalue = "1000";
	printf("\n\n %s Benchmark Completed\n", name);
	printf(" Class           =                        %c\n", ((int)(class)));
	if(((n2==0)&&(n3==0))) { printf(" Size            =             %12d\n", n1); } else  { printf(" Size            =              %3dx%3dx%3d\n", n1, n2, n3); };
	printf(" Iterations      =             %12d\n", niter);
	printf(" Threads         =             %12d\n", nthreads);
	printf(" Time in seconds =             %12.2f\n", 0.0);
	printf(" Mop/s total     =             %12.2f\n", 0.0);
	printf(" Operation type  = %24s\n", optype);
	if((passed_verification!=0)) { printf(" Verification    =               SUCCESSFUL\n", 0); } else  { printf(" Verification    =             UNSUCCESSFUL\n", 0); };
	printf(" Version         =             %12s\n", npbversion);
	printf(" Compile date    =             %12s\n", compiletime);
	printf("\n Compile options:\n", 0);
	printf("    CC           = %s\n", cc);
	printf("    CLINK        = %s\n", clink);
	printf("    C_LIB        = %s\n", c_lib);
	printf("    C_INC        = %s\n", c_inc);
	printf("    CFLAGS       = %s\n", cflags);
	printf("    CLINKFLAGS   = %s\n", clinkflags);
	printf("    RAND         = %s\n", rand);
}
static void c_print_results_wrap(void* _closure, char* name, char class, int n1, int n2, int n3, int niter, int nthreads, double t, double mops, char* optype, int passed_verification, char* npbversion, char* compiletime, char* cc, char* clink, char* c_lib, char* c_inc, char* cflags, char* clinkflags, char* rand) { c_print_results(name, class, n1, n2, n3, niter, nthreads, t, mops, optype, passed_verification, npbversion, compiletime, cc, clink, c_lib, c_inc, cflags, clinkflags, rand); }

// start code fragment :: Definition of main ... type: ((int<4>,ref<array<ref<array<char,1>>,1>>)->int<4>) //
int main(int argc, char** argv){
	struct __insieme_globals* var_1 = malloc(sizeof(struct __insieme_globals));
	((*(&((*var_1).Class))) = '\0');
	((*(&((*var_1).lt))) = 0);
	((*(&((*var_1).lb))) = 0);
	((*(&((*var_1).is1))) = 0);
	((*(&((*var_1).is2))) = 0);
	((*(&((*var_1).is3))) = 0);
	((*(&((*var_1).ie1))) = 0);
	((*(&((*var_1).ie2))) = 0);
	((*(&((*var_1).ie3))) = 0);
	((*(&((*var_1).s))) = 0.0);
	((*(&((*var_1).sec))) = (((int)(0))-1));
	int k = 0;
	int it = 0;
	double t = 0.0;
	double tinit = 0.0;
	double mflops = 0.0;
	int nthreads = 1;
	double**** u;
	double*** v;
	double**** r;
	__insieme_type_4 a;
	__insieme_type_4 c;
	double rnm2 = 0.0;
	double rnmu = 0.0;
	double epsilon = 1.0e-8;
	int n1 = 0;
	int n2 = 0;
	int n3 = 0;
	int nit = 0;
	double verify_value = 0.0;
	int verified = 0;
	int i = 0;
	int j = 0;
	int l = 0;
	struct FILE* fp;
	timer_clear(var_1, 1);
	timer_clear(var_1, 2);
	timer_start(var_1, 2);
	printf("\n\n NAS Parallel Benchmarks 2.3 OpenMP C version - MG Benchmark\n\n", 0);
	((fp) = fopen("mg.input", "r"));
	if((!((fp)==0))){
		printf(" Reading from input file mg.input\n", 0);
		fscanf((fp), "%d", ((&((*var_1).lt))));
		while((fgetc((fp))!=10)) {};
		fscanf((fp), "%d%d%d", (&((*(&((*var_1).nx))).data[((unsigned int)((*(&((*var_1).lt)))))])), (&((*(&((*var_1).ny))).data[((unsigned int)((*(&((*var_1).lt)))))])), (&((*(&((*var_1).nz))).data[((unsigned int)((*(&((*var_1).lt)))))])));
		while((fgetc((fp))!=10)) {};
		fscanf((fp), "%d", (&nit));
		while((fgetc((fp))!=10)) {};
		{
			for(int var_104 = 0; var_104 < (7+1); var_104 += 1)  { fscanf((fp), "%d", (&((*(&((*var_1).debug_vec))).data[((unsigned int)(var_104))]))); };
			((i) = (0+(((int)(ceil((((double)(((7+1)-0)))/((double)(1))))))*1)));
		};
		fclose((fp));
	} else {
		printf(" No input file. Using compiled defaults\n", 0);
		((*(&((*var_1).lt))) = 6);
		((nit) = 40);
		((((*(&((*var_1).nx))).data[((unsigned int)((*(&((*var_1).lt)))))])) = 64);
		((((*(&((*var_1).ny))).data[((unsigned int)((*(&((*var_1).lt)))))])) = 64);
		((((*(&((*var_1).nz))).data[((unsigned int)((*(&((*var_1).lt)))))])) = 64);
		{
			for(int var_106 = 0; var_106 < (7+1); var_106 += 1)  { ((((*(&((*var_1).debug_vec))).data[((unsigned int)(var_106))])) = 0); };
			((i) = (0+(((int)(ceil((((double)(((7+1)-0)))/((double)(1))))))*1)));
		};
	};
	if((((((*(&((*var_1).nx))).data[((unsigned int)((*(&((*var_1).lt)))))]))!=(((*(&((*var_1).ny))).data[((unsigned int)((*(&((*var_1).lt)))))])))||((((*(&((*var_1).nx))).data[((unsigned int)((*(&((*var_1).lt)))))]))!=(((*(&((*var_1).nz))).data[((unsigned int)((*(&((*var_1).lt)))))]))))) { ((*(&((*var_1).Class))) = 'U'); } else  { if((((((*(&((*var_1).nx))).data[((unsigned int)((*(&((*var_1).lt)))))]))==32)&&((nit)==4))) { ((*(&((*var_1).Class))) = 'S'); } else  { if((((((*(&((*var_1).nx))).data[((unsigned int)((*(&((*var_1).lt)))))]))==64)&&((nit)==40))) { ((*(&((*var_1).Class))) = 'W'); } else  { if((((((*(&((*var_1).nx))).data[((unsigned int)((*(&((*var_1).lt)))))]))==256)&&((nit)==20))) { ((*(&((*var_1).Class))) = 'B'); } else  { if((((((*(&((*var_1).nx))).data[((unsigned int)((*(&((*var_1).lt)))))]))==512)&&((nit)==20))) { ((*(&((*var_1).Class))) = 'C'); } else  { if((((((*(&((*var_1).nx))).data[((unsigned int)((*(&((*var_1).lt)))))]))==256)&&((nit)==4))) { ((*(&((*var_1).Class))) = 'A'); } else  { ((*(&((*var_1).Class))) = 'U'); }; }; }; }; }; };
	((((a).data[((unsigned int)(0))])) = ((((double)(0))-8.0)/3.0));
	((((a).data[((unsigned int)(1))])) = 0.0);
	((((a).data[((unsigned int)(2))])) = (1.0/6.0));
	((((a).data[((unsigned int)(3))])) = (1.0/12.0));
	if((((((int)((*(&((*var_1).Class)))))==65)||(((int)((*(&((*var_1).Class)))))==83))||(((int)((*(&((*var_1).Class)))))==87))){
		((((c).data[((unsigned int)(0))])) = ((((double)(0))-3.0)/8.0));
		((((c).data[((unsigned int)(1))])) = (1.0/32.0));
		((((c).data[((unsigned int)(2))])) = ((((double)(0))-1.0)/64.0));
		((((c).data[((unsigned int)(3))])) = 0.0);
	} else {
		((((c).data[((unsigned int)(0))])) = ((((double)(0))-3.0)/17.0));
		((((c).data[((unsigned int)(1))])) = (1.0/33.0));
		((((c).data[((unsigned int)(2))])) = ((((double)(0))-1.0)/61.0));
		((((c).data[((unsigned int)(3))])) = 0.0);
	};
	((*(&((*var_1).lb))) = 1);
	setup(var_1, (&n1), (&n2), (&n3), (*(&((*var_1).lt))));
	((u) = (((double****){malloc(sizeof(double****)*((((unsigned long)(((*(&((*var_1).lt)))+1)))*sizeof(double***))/sizeof(double***)))})));
	{
		for(int var_139 = (((int)(0))-(*(&((*var_1).lt)))); var_139 < ((((int)(0))-1)+1); var_139 += 1) {
			((((u)[((unsigned int)((((int)(0))-var_139)))])) = (((double***){malloc(sizeof(double***)*((((unsigned long)((((*(&((*var_1).m3))).data[((unsigned int)((((int)(0))-var_139)))]))))*sizeof(double**))/sizeof(double**)))})));
			{
				for(int var_137 = 0; var_137 < (((*(&((*var_1).m3))).data[((unsigned int)((((int)(0))-var_139)))])); var_137 += 1) {
					((((((u)[((unsigned int)((((int)(0))-var_139)))]))[((unsigned int)(var_137))])) = (((double**){malloc(sizeof(double**)*((((unsigned long)((((*(&((*var_1).m2))).data[((unsigned int)((((int)(0))-var_139)))]))))*sizeof(double*))/sizeof(double*)))})));
					{
						for(int var_135 = 0; var_135 < (((*(&((*var_1).m2))).data[((unsigned int)((((int)(0))-var_139)))])); var_135 += 1)  { ((((((((u)[((unsigned int)((((int)(0))-var_139)))]))[((unsigned int)(var_137))]))[((unsigned int)(var_135))])) = (((double*){malloc(sizeof(double*)*((((unsigned long)((((*(&((*var_1).m1))).data[((unsigned int)((((int)(0))-var_139)))]))))*sizeof(double))/sizeof(double)))}))); };
						((j) = (0+(((int)(ceil((((double)(((((*(&((*var_1).m2))).data[((unsigned int)((((int)(0))-var_139)))]))-0)))/((double)(1))))))*1)));
					};
				};
				((k) = (0+(((int)(ceil((((double)(((((*(&((*var_1).m3))).data[((unsigned int)((((int)(0))-var_139)))]))-0)))/((double)(1))))))*1)));
			};
		};
		((l) = ((*(&((*var_1).lt)))+(((int)(ceil((((double)((((((int)(0))-1)+1)-(*(&((*var_1).lt))))))/((double)(1))))))*1)));
	};
	((v) = (((double***){malloc(sizeof(double***)*((((unsigned long)((((*(&((*var_1).m3))).data[((unsigned int)((*(&((*var_1).lt)))))]))))*sizeof(double**))/sizeof(double**)))})));
	{
		for(int var_143 = 0; var_143 < (((*(&((*var_1).m3))).data[((unsigned int)((*(&((*var_1).lt)))))])); var_143 += 1) {
			((((v)[((unsigned int)(var_143))])) = (((double**){malloc(sizeof(double**)*((((unsigned long)((((*(&((*var_1).m2))).data[((unsigned int)((*(&((*var_1).lt)))))]))))*sizeof(double*))/sizeof(double*)))})));
			{
				for(int var_141 = 0; var_141 < (((*(&((*var_1).m2))).data[((unsigned int)((*(&((*var_1).lt)))))])); var_141 += 1)  { ((((((v)[((unsigned int)(var_143))]))[((unsigned int)(var_141))])) = (((double*){malloc(sizeof(double*)*((((unsigned long)((((*(&((*var_1).m1))).data[((unsigned int)((*(&((*var_1).lt)))))]))))*sizeof(double))/sizeof(double)))}))); };
				((j) = (0+(((int)(ceil((((double)(((((*(&((*var_1).m2))).data[((unsigned int)((*(&((*var_1).lt)))))]))-0)))/((double)(1))))))*1)));
			};
		};
		((k) = (0+(((int)(ceil((((double)(((((*(&((*var_1).m3))).data[((unsigned int)((*(&((*var_1).lt)))))]))-0)))/((double)(1))))))*1)));
	};
	((r) = (((double****){malloc(sizeof(double****)*((((unsigned long)(((*(&((*var_1).lt)))+1)))*sizeof(double***))/sizeof(double***)))})));
	{
		for(int var_149 = (((int)(0))-(*(&((*var_1).lt)))); var_149 < ((((int)(0))-1)+1); var_149 += 1) {
			((((r)[((unsigned int)((((int)(0))-var_149)))])) = (((double***){malloc(sizeof(double***)*((((unsigned long)((((*(&((*var_1).m3))).data[((unsigned int)((((int)(0))-var_149)))]))))*sizeof(double**))/sizeof(double**)))})));
			{
				for(int var_147 = 0; var_147 < (((*(&((*var_1).m3))).data[((unsigned int)((((int)(0))-var_149)))])); var_147 += 1) {
					((((((r)[((unsigned int)((((int)(0))-var_149)))]))[((unsigned int)(var_147))])) = (((double**){malloc(sizeof(double**)*((((unsigned long)((((*(&((*var_1).m2))).data[((unsigned int)((((int)(0))-var_149)))]))))*sizeof(double*))/sizeof(double*)))})));
					{
						for(int var_145 = 0; var_145 < (((*(&((*var_1).m2))).data[((unsigned int)((((int)(0))-var_149)))])); var_145 += 1)  { ((((((((r)[((unsigned int)((((int)(0))-var_149)))]))[((unsigned int)(var_147))]))[((unsigned int)(var_145))])) = (((double*){malloc(sizeof(double*)*((((unsigned long)((((*(&((*var_1).m1))).data[((unsigned int)((((int)(0))-var_149)))]))))*sizeof(double))/sizeof(double)))}))); };
						((j) = (0+(((int)(ceil((((double)(((((*(&((*var_1).m2))).data[((unsigned int)((((int)(0))-var_149)))]))-0)))/((double)(1))))))*1)));
					};
				};
				((k) = (0+(((int)(ceil((((double)(((((*(&((*var_1).m3))).data[((unsigned int)((((int)(0))-var_149)))]))-0)))/((double)(1))))))*1)));
			};
		};
		((l) = ((*(&((*var_1).lt)))+(((int)(ceil((((double)((((((int)(0))-1)+1)-(*(&((*var_1).lt))))))/((double)(1))))))*1)));
	};
	 { zero3((((u)[((unsigned int)((*(&((*var_1).lt)))))])), (n1), (n2), (n3)); };
	zran3(var_1, (v), (n1), (n2), (n3), (((*(&((*var_1).nx))).data[((unsigned int)((*(&((*var_1).lt)))))])), (((*(&((*var_1).ny))).data[((unsigned int)((*(&((*var_1).lt)))))])), (*(&((*var_1).lt))));
	{
		norm2u3(var_1, (v), (n1), (n2), (n3), (&rnm2), (&rnmu), (((*(&((*var_1).nx))).data[((unsigned int)((*(&((*var_1).lt)))))])), (((*(&((*var_1).ny))).data[((unsigned int)((*(&((*var_1).lt)))))])), (((*(&((*var_1).nz))).data[((unsigned int)((*(&((*var_1).lt)))))])));
		{
			printf(" Size: %3dx%3dx%3d (class %1c)\n", (((*(&((*var_1).nx))).data[((unsigned int)((*(&((*var_1).lt)))))])), (((*(&((*var_1).ny))).data[((unsigned int)((*(&((*var_1).lt)))))])), (((*(&((*var_1).nz))).data[((unsigned int)((*(&((*var_1).lt)))))])), ((int)((*(&((*var_1).Class))))));
			printf(" Iterations: %3d\n", (nit));
		};
		resid(var_1, (((u)[((unsigned int)((*(&((*var_1).lt)))))])), (v), (((r)[((unsigned int)((*(&((*var_1).lt)))))])), (n1), (n2), (n3), (((double*){(a).data})), (*(&((*var_1).lt))));
		norm2u3(var_1, (((r)[((unsigned int)((*(&((*var_1).lt)))))])), (n1), (n2), (n3), (&rnm2), (&rnmu), (((*(&((*var_1).nx))).data[((unsigned int)((*(&((*var_1).lt)))))])), (((*(&((*var_1).ny))).data[((unsigned int)((*(&((*var_1).lt)))))])), (((*(&((*var_1).nz))).data[((unsigned int)((*(&((*var_1).lt)))))])));
		mg3P(var_1, (u), (v), (r), (((double*){(a).data})), (((double*){(c).data})), (n1), (n2), (n3), (*(&((*var_1).lt))));
		resid(var_1, (((u)[((unsigned int)((*(&((*var_1).lt)))))])), (v), (((r)[((unsigned int)((*(&((*var_1).lt)))))])), (n1), (n2), (n3), (((double*){(a).data})), (*(&((*var_1).lt))));
		setup(var_1, (&n1), (&n2), (&n3), (*(&((*var_1).lt))));
		zero3((((u)[((unsigned int)((*(&((*var_1).lt)))))])), (n1), (n2), (n3));
	};
	zran3(var_1, (v), (n1), (n2), (n3), (((*(&((*var_1).nx))).data[((unsigned int)((*(&((*var_1).lt)))))])), (((*(&((*var_1).ny))).data[((unsigned int)((*(&((*var_1).lt)))))])), (*(&((*var_1).lt))));
	timer_stop(var_1, 2);
	timer_start(var_1, 1);
	{
		resid(var_1, (((u)[((unsigned int)((*(&((*var_1).lt)))))])), (v), (((r)[((unsigned int)((*(&((*var_1).lt)))))])), (n1), (n2), (n3), (((double*){(a).data})), (*(&((*var_1).lt))));
		norm2u3(var_1, (((r)[((unsigned int)((*(&((*var_1).lt)))))])), (n1), (n2), (n3), (&rnm2), (&rnmu), (((*(&((*var_1).nx))).data[((unsigned int)((*(&((*var_1).lt)))))])), (((*(&((*var_1).ny))).data[((unsigned int)((*(&((*var_1).lt)))))])), (((*(&((*var_1).nz))).data[((unsigned int)((*(&((*var_1).lt)))))])));{
			for(int var_487 = 1; var_487 < ((nit)+1); var_487 += 1) {
				mg3P(var_1, (u), (v), (r), (((double*){(a).data})), (((double*){(c).data})), (n1), (n2), (n3), (*(&((*var_1).lt))));
				resid(var_1, (((u)[((unsigned int)((*(&((*var_1).lt)))))])), (v), (((r)[((unsigned int)((*(&((*var_1).lt)))))])), (n1), (n2), (n3), (((double*){(a).data})), (*(&((*var_1).lt))));
			};
			((it) = (1+(((int)(ceil((((double)((((nit)+1)-1)))/((double)(1))))))*1)));
		};
		norm2u3(var_1, (((r)[((unsigned int)((*(&((*var_1).lt)))))])), (n1), (n2), (n3), (&rnm2), (&rnmu), (((*(&((*var_1).nx))).data[((unsigned int)((*(&((*var_1).lt)))))])), (((*(&((*var_1).ny))).data[((unsigned int)((*(&((*var_1).lt)))))])), (((*(&((*var_1).nz))).data[((unsigned int)((*(&((*var_1).lt)))))])));
	};
	timer_stop(var_1, 1);
	((t) = timer_read(var_1, 1));
	((tinit) = timer_read(var_1, 2));
	((verified) = 0);
	((verify_value) = 0.0);
	printf(" Initialization time: %15.3f seconds\n", 0.0);
	printf(" Benchmark completed\n", 0);
	if((((int)((*(&((*var_1).Class)))))!=85)){
		if((((int)((*(&((*var_1).Class)))))==83)) { ((verify_value) = 0.530770700573e-04); } else  { if((((int)((*(&((*var_1).Class)))))==87)) { ((verify_value) = 0.250391406439e-17); } else  { if((((int)((*(&((*var_1).Class)))))==65)) { ((verify_value) = 0.2433365309e-5); } else  { if((((int)((*(&((*var_1).Class)))))==66)) { ((verify_value) = 0.180056440132e-5); } else  { if((((int)((*(&((*var_1).Class)))))==67)) { ((verify_value) = 0.570674826298e-06); }; }; }; }; };
		if((fabs(((rnm2)-(verify_value)))<=(epsilon))){
			((verified) = 1);
			printf(" VERIFICATION SUCCESSFUL\n", 0);
			printf(" L2 Norm is %20.12e\n", (rnm2));
			printf(" Error is   %20.12e\n", ((rnm2)-(verify_value)));
		} else {
			((verified) = 0);
			printf(" VERIFICATION FAILED\n", 0);
			printf(" L2 Norm is             %20.12e\n", (rnm2));
			printf(" The correct L2 Norm is %20.12e\n", (verify_value));
		};
	} else {
		((verified) = 0);
		printf(" Problem size unknown\n", 0);
		printf(" NO VERIFICATION PERFORMED\n", 0);
	};
	if(((t)!=0.0)){
		int nn = (((((*(&((*var_1).nx))).data[((unsigned int)((*(&((*var_1).lt)))))]))*(((*(&((*var_1).ny))).data[((unsigned int)((*(&((*var_1).lt)))))])))*(((*(&((*var_1).nz))).data[((unsigned int)((*(&((*var_1).lt)))))])));
		((mflops) = ((((58.*((double)((nit))))*((double)((nn))))*1.0e-6)/(t)));
	} else  { ((mflops) = 0.0); };
	c_print_results("MG", (*(&((*var_1).Class))), (((*(&((*var_1).nx))).data[((unsigned int)((*(&((*var_1).lt)))))])), (((*(&((*var_1).ny))).data[((unsigned int)((*(&((*var_1).lt)))))])), (((*(&((*var_1).nz))).data[((unsigned int)((*(&((*var_1).lt)))))])), (nit), (nthreads), (t), (mflops), "          floating point", (verified), "2.3", "02 Dec 2010", "cc", "cc", "-lm", "-I../common", "-O3 ", "-lm", "randdp");
}
static int main_wrap(void* _closure, int argc, char** argv) { return main(argc, argv); }
