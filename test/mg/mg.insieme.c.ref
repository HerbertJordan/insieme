// --- Generated Inspire Code ---
#include <alloca.h>
#include <stddef.h>
#include <stdlib.h>
#define bool int
#define true 1
#define false 0
#define null 0
// --- Entry Point ---

// start code fragment :: type_declaration___insieme_globals //
struct __insieme_globals { 
    int(* nx)[12];
    int(* ny)[12];
    int(* nz)[12];
    char Class;
    int(* debug_vec)[8];
    int(* m1)[12];
    int(* m2)[12];
    int(* m3)[12];
    int lt;
    int lb;
    int is1;
    int is2;
    int is3;
    int ie1;
    int ie2;
    int ie3;
    double s;
    double(* start)[64];
    double(* elapsed)[64];
    int sec;
};

// start code fragment :: Prototype of struct FILE //
struct FILE;

// start code fragment :: Prototype of struct __insieme_userdefined_rec_type_type_0 //
struct __insieme_userdefined_rec_type_type_0;

// start code fragment :: type_declaration_FILE //
struct FILE { 
    int _flags;
    char* _IO_read_ptr;
    char* _IO_read_end;
    char* _IO_read_base;
    char* _IO_write_base;
    char* _IO_write_ptr;
    char* _IO_write_end;
    char* _IO_buf_base;
    char* _IO_buf_end;
    char* _IO_save_base;
    char* _IO_backup_base;
    char* _IO_save_end;
    struct __insieme_userdefined_rec_type_type_0* _markers;
    struct FILE* _chain;
    int _fileno;
    int _flags2;
    long _old_offset;
    unsigned short _cur_column;
    char _vtable_offset;
    char _shortbuf[1];
    void* _lock;
    long _offset;
    void* __pad1;
    void* __pad2;
    void* __pad3;
    void* __pad4;
    unsigned long __pad5;
    int _mode;
    char _unused2[20];
};

// start code fragment :: type_declaration___insieme_userdefined_rec_type_type_0 //
struct __insieme_userdefined_rec_type_type_0 { 
    struct __insieme_userdefined_rec_type_type_0* _next;
    struct FILE* _sbuf;
    int _pos;
};

// start code fragment :: Definitions for function type: __insieme_funType_type_1 //
// Abstract prototype for lambdas of type __insieme_funType_type_1
struct __insieme_funType_type_1 { 
    void(*fun)(void*,int);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_1
void call__insieme_funType_type_1(struct __insieme_funType_type_1* lambda,int p1) { return lambda->fun(lambda,p1); }

// start code fragment :: Definitions for function type: __insieme_funType_type_2 //
// Abstract prototype for lambdas of type __insieme_funType_type_2
struct __insieme_funType_type_2 { 
    void(*fun)(void*,int);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: Definition of timer_clear //
void timer_clear(void* _capture, int n) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_29 = ((struct __insieme_funType_type_2*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		((((*((*var_29).elapsed))[((unsigned int)(n))])) = 0.0);
	}
}


// start code fragment :: Definitions for function type: __insieme_funType_type_3 //
// Abstract prototype for lambdas of type __insieme_funType_type_3
struct __insieme_funType_type_3 { 
    double(*fun)(void*);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_3
double call__insieme_funType_type_3(struct __insieme_funType_type_3* lambda) { return lambda->fun(lambda); }

// start code fragment :: Definitions for function type: __insieme_funType_type_4 //
// Abstract prototype for lambdas of type __insieme_funType_type_4
struct __insieme_funType_type_4 { 
    double(*fun)(void*);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: Definitions for function type: __insieme_funType_type_5 //
// Abstract prototype for lambdas of type __insieme_funType_type_5
struct __insieme_funType_type_5 { 
    void(*fun)(void*,double*);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_5
void call__insieme_funType_type_5(struct __insieme_funType_type_5* lambda,double* p1) { return lambda->fun(lambda,p1); }

// start code fragment :: Definitions for function type: __insieme_funType_type_6 //
// Abstract prototype for lambdas of type __insieme_funType_type_6
struct __insieme_funType_type_6 { 
    void(*fun)(void*,double*);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: type_declaration_timeval //
struct timeval { 
    long tv_sec;
    long tv_usec;
};

// start code fragment :: type_declaration_timezone //
struct timezone { 
    int tz_minuteswest;
    int tz_dsttime;
};

// start code fragment :: Prototype for external function: gettimeofday //
int gettimeofday(struct timeval*, struct timezone*);

// start code fragment :: Definition of wtime //
void wtime(void* _capture, double* t) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_36 = ((struct __insieme_funType_type_6*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		struct timeval tv;
		gettimeofday(&tv, null);
		if(((((*var_36).sec))<0)) {
			((((*var_36).sec)) = ((int)((((tv).tv_sec)))));
		};
		(((t[0])) = (((double)(((((tv).tv_sec))-((long)((((*var_36).sec)))))))+(1.0e-6*((double)((((tv).tv_usec)))))));
	}
}


// start code fragment :: Definition of elapsed_time //
double elapsed_time(void* _capture) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_33 = ((struct __insieme_funType_type_4*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		double t = 0.0;
		call__insieme_funType_type_5(((struct __insieme_funType_type_5*)(&((struct __insieme_funType_type_6){&wtime, 0, var_33}))), &t);
		return (t);;
	}
}


// start code fragment :: Definition of timer_start //
void timer_start(void* _capture, int n) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_32 = ((struct __insieme_funType_type_2*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		((((*((*var_32).start))[((unsigned int)(n))])) = call__insieme_funType_type_3(((struct __insieme_funType_type_3*)(&((struct __insieme_funType_type_4){&elapsed_time, 0, var_32})))));
	}
}


// start code fragment :: Prototype for external function: printf //
int printf(char*, ...);

// start code fragment :: Prototype for external function: fopen //
struct FILE* fopen(char*, char*);

// start code fragment :: Prototype for external function: fscanf //
int fscanf(struct FILE*, char*, ...);

// start code fragment :: Prototype for external function: fgetc //
int fgetc(struct FILE*);

// start code fragment :: Prototype for external function: ceil //
double ceil(double);

// start code fragment :: Prototype for external function: fclose //
int fclose(struct FILE*);

// start code fragment :: Definitions for function type: __insieme_funType_type_7 //
// Abstract prototype for lambdas of type __insieme_funType_type_7
struct __insieme_funType_type_7 { 
    void(*fun)(void*,int*,int*,int*,int);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_7
void call__insieme_funType_type_7(struct __insieme_funType_type_7* lambda,int* p1,int* p2,int* p3,int p4) { return lambda->fun(lambda,p1,p2,p3,p4); }

// start code fragment :: Definitions for function type: __insieme_funType_type_8 //
// Abstract prototype for lambdas of type __insieme_funType_type_8
struct __insieme_funType_type_8 { 
    void(*fun)(void*,int*,int*,int*,int);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: Definition of setup //
void setup(void* _capture, int* n1, int* n2, int* n3, int lt) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_47 = ((struct __insieme_funType_type_8*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		int k = 0;
		{
			for(int var_49 = (((int)(0))-(lt-1)); var_49 < ((((int)(0))-1)+1); var_49 += 1) {
				((((*((*var_47).nx))[((unsigned int)((((int)(0))-(var_49))))])) = ((((*((*var_47).nx))[((unsigned int)(((((int)(0))-(var_49))+1)))]))/2));
				((((*((*var_47).ny))[((unsigned int)((((int)(0))-(var_49))))])) = ((((*((*var_47).ny))[((unsigned int)(((((int)(0))-(var_49))+1)))]))/2));
				((((*((*var_47).nz))[((unsigned int)((((int)(0))-(var_49))))])) = ((((*((*var_47).nz))[((unsigned int)(((((int)(0))-(var_49))+1)))]))/2));
			};
			((k) = ((lt-1)+(((int)(ceil((((double)((((((int)(0))-1)+1)-(lt-1))))/((double)(1))))))*1)));
		};
		{
			for(int var_50 = 1; var_50 < (lt+1); var_50 += 1) {
				((((*((*var_47).m1))[((unsigned int)((var_50)))])) = ((((*((*var_47).nx))[((unsigned int)((var_50)))]))+2));
				((((*((*var_47).m2))[((unsigned int)((var_50)))])) = ((((*((*var_47).nz))[((unsigned int)((var_50)))]))+2));
				((((*((*var_47).m3))[((unsigned int)((var_50)))])) = ((((*((*var_47).ny))[((unsigned int)((var_50)))]))+2));
			};
			((k) = (1+(((int)(ceil((((double)(((lt+1)-1)))/((double)(1))))))*1)));
		};
		((((*var_47).is1)) = 1);
		((((*var_47).ie1)) = (((*((*var_47).nx))[((unsigned int)(lt))])));
		(((n1[0])) = ((((*((*var_47).nx))[((unsigned int)(lt))]))+2));
		((((*var_47).is2)) = 1);
		((((*var_47).ie2)) = (((*((*var_47).ny))[((unsigned int)(lt))])));
		(((n2[0])) = ((((*((*var_47).ny))[((unsigned int)(lt))]))+2));
		((((*var_47).is3)) = 1);
		((((*var_47).ie3)) = (((*((*var_47).nz))[((unsigned int)(lt))])));
		(((n3[0])) = ((((*((*var_47).nz))[((unsigned int)(lt))]))+2));
		if(((((*((*var_47).debug_vec))[((unsigned int)(1))]))>=1)) {
			printf(" in setup, \n", 0);
			printf("  lt  nx  ny  nz  n1  n2  n3 is1 is2 is3 ie1 ie2 ie3\n", 0);
			printf("%4d%4d%4d%4d%4d%4d%4d%4d%4d%4d%4d%4d%4d\n", lt, (((*((*var_47).nx))[((unsigned int)(lt))])), (((*((*var_47).ny))[((unsigned int)(lt))])), (((*((*var_47).nz))[((unsigned int)(lt))])), ((n1[0])), ((n2[0])), ((n3[0])), (((*var_47).is1)), (((*var_47).is2)), (((*var_47).is3)), (((*var_47).ie1)), (((*var_47).ie2)), (((*var_47).ie3)));
		};
	}
}


// start code fragment :: Definition of zero3 //
void zero3(double*** z, int n1, int n2, int n3) {
	{
		int i1 = 0;
		int i2 = 0;
		int i3 = 0;
		{
			for(int var_69 = 0; var_69 < n3; var_69 += 1) {
				{
					for(int var_68 = 0; var_68 < n2; var_68 += 1) {
						{
							for(int var_67 = 0; var_67 < n1; var_67 += 1) {
								(((((((z[((unsigned int)((var_69)))]))[((unsigned int)((var_68)))]))[((unsigned int)((var_67)))])) = 0.0);
							};
							((i1) = (0+(((int)(ceil((((double)((n1-0)))/((double)(1))))))*1)));
						};
					};
					((i2) = (0+(((int)(ceil((((double)((n2-0)))/((double)(1))))))*1)));
				};
			};
			((i3) = (0+(((int)(ceil((((double)((n3-0)))/((double)(1))))))*1)));
		};
	}
}


// start code fragment :: Definitions for function type: __insieme_funType_type_9 //
// Abstract prototype for lambdas of type __insieme_funType_type_9
struct __insieme_funType_type_9 { 
    void(*fun)(void*,double***,int,int,int,int,int,int);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_9
void call__insieme_funType_type_9(struct __insieme_funType_type_9* lambda,double*** p1,int p2,int p3,int p4,int p5,int p6,int p7) { return lambda->fun(lambda,p1,p2,p3,p4,p5,p6,p7); }

// start code fragment :: Definitions for function type: __insieme_funType_type_10 //
// Abstract prototype for lambdas of type __insieme_funType_type_10
struct __insieme_funType_type_10 { 
    void(*fun)(void*,double***,int,int,int,int,int,int);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: Prototype for external function: randlc //
double randlc(double*, double);

// start code fragment :: Definition of power //
double power(double a, int n) {
	{
		double aj = 0.0;
		int nj = 0;
		double rdummy = 0.0;
		double power = 0.0;
		((power) = 1.0);
		((nj) = n);
		((aj) = a);
		while(((nj)!=0)) {
			if((((nj)%2)==1)) {
				((rdummy) = randlc(&power, (aj)));
			};
			((rdummy) = randlc(&aj, (aj)));
			((nj) = ((nj)/2));
		};
		return (power);;
	}
}


// start code fragment :: Prototype for external function: pow //
double pow(double, double);

// start code fragment :: Prototype for external function: vranlc //
void vranlc(int, double*, double, double*);

// start code fragment :: Definition of bubble //
int bubble(double(* ten)[2], int(* j1)[2], int(* j2)[2], int(* j3)[2], int m, int ind) {
	{
		double temp = 0.0;
		int i = 0;
		int j_temp = 0;
		if((ind==1)) {
			{
				for(int var_122 = 0; var_122 < (m-1); var_122 += 1) {
					if((((((ten[((unsigned int)((var_122)))]))[((unsigned int)(ind))]))>((((ten[((unsigned int)(((var_122)+1)))]))[((unsigned int)(ind))])))) {
						((temp) = ((((ten[((unsigned int)(((var_122)+1)))]))[((unsigned int)(ind))])));
						(((((ten[((unsigned int)(((var_122)+1)))]))[((unsigned int)(ind))])) = ((((ten[((unsigned int)((var_122)))]))[((unsigned int)(ind))])));
						(((((ten[((unsigned int)((var_122)))]))[((unsigned int)(ind))])) = (temp));
						((j_temp) = ((((j1[((unsigned int)(((var_122)+1)))]))[((unsigned int)(ind))])));
						(((((j1[((unsigned int)(((var_122)+1)))]))[((unsigned int)(ind))])) = ((((j1[((unsigned int)((var_122)))]))[((unsigned int)(ind))])));
						(((((j1[((unsigned int)((var_122)))]))[((unsigned int)(ind))])) = (j_temp));
						((j_temp) = ((((j2[((unsigned int)(((var_122)+1)))]))[((unsigned int)(ind))])));
						(((((j2[((unsigned int)(((var_122)+1)))]))[((unsigned int)(ind))])) = ((((j2[((unsigned int)((var_122)))]))[((unsigned int)(ind))])));
						(((((j2[((unsigned int)((var_122)))]))[((unsigned int)(ind))])) = (j_temp));
						((j_temp) = ((((j3[((unsigned int)(((var_122)+1)))]))[((unsigned int)(ind))])));
						(((((j3[((unsigned int)(((var_122)+1)))]))[((unsigned int)(ind))])) = ((((j3[((unsigned int)((var_122)))]))[((unsigned int)(ind))])));
						(((((j3[((unsigned int)((var_122)))]))[((unsigned int)(ind))])) = (j_temp));
					} else {
						return 0;;
					};
				};
				((i) = (0+(((int)(ceil((((double)(((m-1)-0)))/((double)(1))))))*1)));
			};
		} else {
			{
				for(int var_123 = 0; var_123 < (m-1); var_123 += 1) {
					if((((((ten[((unsigned int)((var_123)))]))[((unsigned int)(ind))]))<((((ten[((unsigned int)(((var_123)+1)))]))[((unsigned int)(ind))])))) {
						((temp) = ((((ten[((unsigned int)(((var_123)+1)))]))[((unsigned int)(ind))])));
						(((((ten[((unsigned int)(((var_123)+1)))]))[((unsigned int)(ind))])) = ((((ten[((unsigned int)((var_123)))]))[((unsigned int)(ind))])));
						(((((ten[((unsigned int)((var_123)))]))[((unsigned int)(ind))])) = (temp));
						((j_temp) = ((((j1[((unsigned int)(((var_123)+1)))]))[((unsigned int)(ind))])));
						(((((j1[((unsigned int)(((var_123)+1)))]))[((unsigned int)(ind))])) = ((((j1[((unsigned int)((var_123)))]))[((unsigned int)(ind))])));
						(((((j1[((unsigned int)((var_123)))]))[((unsigned int)(ind))])) = (j_temp));
						((j_temp) = ((((j2[((unsigned int)(((var_123)+1)))]))[((unsigned int)(ind))])));
						(((((j2[((unsigned int)(((var_123)+1)))]))[((unsigned int)(ind))])) = ((((j2[((unsigned int)((var_123)))]))[((unsigned int)(ind))])));
						(((((j2[((unsigned int)((var_123)))]))[((unsigned int)(ind))])) = (j_temp));
						((j_temp) = ((((j3[((unsigned int)(((var_123)+1)))]))[((unsigned int)(ind))])));
						(((((j3[((unsigned int)(((var_123)+1)))]))[((unsigned int)(ind))])) = ((((j3[((unsigned int)((var_123)))]))[((unsigned int)(ind))])));
						(((((j3[((unsigned int)((var_123)))]))[((unsigned int)(ind))])) = (j_temp));
					} else {
						return 0;;
					};
				};
				((i) = (0+(((int)(ceil((((double)(((m-1)-0)))/((double)(1))))))*1)));
			};
		};
		return 1;;
	}
}


// start code fragment :: Definition of comm3 //
void comm3(double*** u, int n1, int n2, int n3, int kk) {
	{
		int i1 = 0;
		int i2 = 0;
		int i3 = 0;
		{
			for(int var_143 = 1; var_143 < (n3-1); var_143 += 1) {
				{
					for(int var_142 = 1; var_142 < (n2-1); var_142 += 1) {
						(((((((u[((unsigned int)((var_143)))]))[((unsigned int)((var_142)))]))[((unsigned int)((n1-1)))])) = ((((((u[((unsigned int)((var_143)))]))[((unsigned int)((var_142)))]))[((unsigned int)(1))])));
						(((((((u[((unsigned int)((var_143)))]))[((unsigned int)((var_142)))]))[((unsigned int)(0))])) = ((((((u[((unsigned int)((var_143)))]))[((unsigned int)((var_142)))]))[((unsigned int)((n1-2)))])));
					};
					((i2) = (1+(((int)(ceil((((double)(((n2-1)-1)))/((double)(1))))))*1)));
				};
			};
			((i3) = (1+(((int)(ceil((((double)(((n3-1)-1)))/((double)(1))))))*1)));
		};
		{
			for(int var_145 = 1; var_145 < (n3-1); var_145 += 1) {
				{
					for(int var_144 = 0; var_144 < n1; var_144 += 1) {
						(((((((u[((unsigned int)((var_145)))]))[((unsigned int)((n2-1)))]))[((unsigned int)((var_144)))])) = ((((((u[((unsigned int)((var_145)))]))[((unsigned int)(1))]))[((unsigned int)((var_144)))])));
						(((((((u[((unsigned int)((var_145)))]))[((unsigned int)(0))]))[((unsigned int)((var_144)))])) = ((((((u[((unsigned int)((var_145)))]))[((unsigned int)((n2-2)))]))[((unsigned int)((var_144)))])));
					};
					((i1) = (0+(((int)(ceil((((double)((n1-0)))/((double)(1))))))*1)));
				};
			};
			((i3) = (1+(((int)(ceil((((double)(((n3-1)-1)))/((double)(1))))))*1)));
		};
		{
			for(int var_147 = 0; var_147 < n2; var_147 += 1) {
				{
					for(int var_146 = 0; var_146 < n1; var_146 += 1) {
						(((((((u[((unsigned int)((n3-1)))]))[((unsigned int)((var_147)))]))[((unsigned int)((var_146)))])) = ((((((u[((unsigned int)(1))]))[((unsigned int)((var_147)))]))[((unsigned int)((var_146)))])));
						(((((((u[((unsigned int)(0))]))[((unsigned int)((var_147)))]))[((unsigned int)((var_146)))])) = ((((((u[((unsigned int)((n3-2)))]))[((unsigned int)((var_147)))]))[((unsigned int)((var_146)))])));
					};
					((i1) = (0+(((int)(ceil((((double)((n1-0)))/((double)(1))))))*1)));
				};
			};
			((i2) = (0+(((int)(ceil((((double)((n2-0)))/((double)(1))))))*1)));
		};
	}
}


// start code fragment :: Definition of zran3 //
void zran3(void* _capture, double*** z, int n1, int n2, int n3, int nx, int ny, int k) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_78 = ((struct __insieme_funType_type_10*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		int i0 = 0;
		int m0 = 0;
		int m1 = 0;
		int i1 = 0;
		int i2 = 0;
		int i3 = 0;
		int d1 = 0;
		int e1 = 0;
		int e2 = 0;
		int e3 = 0;
		double xx = 0.0;
		double x0 = 0.0;
		double x1 = 0.0;
		double a1 = 0.0;
		double a2 = 0.0;
		double ai = 0.0;
		double ten[10][2];
		double best = 0.0;
		int i = 0;
		int j1[10][2];
		int j2[10][2];
		int j3[10][2];
		int jg[4][10][2];
		double rdummy = 0.0;
		((a1) = power(pow(5.0, ((double)(13))), nx));
		((a2) = power(pow(5.0, ((double)(13))), (nx*ny)));
		{
			zero3(z, n1, n2, n3);
		};
		((i) = (((((*var_78).is1))-1)+(nx*(((((*var_78).is2))-1)+(ny*((((*var_78).is3))-1))))));
		((ai) = power(pow(5.0, ((double)(13))), (i)));
		((d1) = (((((*var_78).ie1))-(((*var_78).is1)))+1));
		((e1) = (((((*var_78).ie1))-(((*var_78).is1)))+2));
		((e2) = (((((*var_78).ie2))-(((*var_78).is2)))+2));
		((e3) = (((((*var_78).ie3))-(((*var_78).is3)))+2));
		((x0) = 314159265.e0);
		((rdummy) = randlc(&x0, (ai)));
		{
			for(int var_111 = 1; var_111 < (e3); var_111 += 1) {
				((x1) = (x0));
				{
					for(int var_110 = 1; var_110 < (e2); var_110 += 1) {
						((xx) = (x1));
						vranlc((d1), &xx, pow(5.0, ((double)(13))), &(((((z[((unsigned int)((var_111)))]))[((unsigned int)((var_110)))]))[((unsigned int)(0))]));
						((rdummy) = randlc(&x1, (a1)));
					};
					((i2) = (1+(((int)(ceil((((double)(((e2)-1)))/((double)(1))))))*1)));
				};
				((rdummy) = randlc(&x0, (a2)));
			};
			((i3) = (1+(((int)(ceil((((double)(((e3)-1)))/((double)(1))))))*1)));
		};
		{
			for(int var_112 = 0; var_112 < 10; var_112 += 1) {
				(((ten[((unsigned int)((var_112)))][((unsigned int)(1))])) = 0.0);
				(((j1[((unsigned int)((var_112)))][((unsigned int)(1))])) = 0);
				(((j2[((unsigned int)((var_112)))][((unsigned int)(1))])) = 0);
				(((j3[((unsigned int)((var_112)))][((unsigned int)(1))])) = 0);
				(((ten[((unsigned int)((var_112)))][((unsigned int)(0))])) = 1.0);
				(((j1[((unsigned int)((var_112)))][((unsigned int)(0))])) = 0);
				(((j2[((unsigned int)((var_112)))][((unsigned int)(0))])) = 0);
				(((j3[((unsigned int)((var_112)))][((unsigned int)(0))])) = 0);
			};
			((i) = (0+(((int)(ceil((((double)((10-0)))/((double)(1))))))*1)));
		};
		{
			for(int var_127 = 1; var_127 < (n3-1); var_127 += 1) {
				{
					for(int var_126 = 1; var_126 < (n2-1); var_126 += 1) {
						{
							for(int var_125 = 1; var_125 < (n1-1); var_125 += 1) {
								if((((((((z[((unsigned int)((var_127)))]))[((unsigned int)((var_126)))]))[((unsigned int)((var_125)))]))>((ten[((unsigned int)(0))][((unsigned int)(1))])))) {
									(((ten[((unsigned int)(0))][((unsigned int)(1))])) = ((((((z[((unsigned int)((var_127)))]))[((unsigned int)((var_126)))]))[((unsigned int)((var_125)))])));
									(((j1[((unsigned int)(0))][((unsigned int)(1))])) = (var_125));
									(((j2[((unsigned int)(0))][((unsigned int)(1))])) = (var_126));
									(((j3[((unsigned int)(0))][((unsigned int)(1))])) = (var_127));
									bubble(ten, j1, j2, j3, 10, 1);
								};
								if((((((((z[((unsigned int)((var_127)))]))[((unsigned int)((var_126)))]))[((unsigned int)((var_125)))]))<((ten[((unsigned int)(0))][((unsigned int)(0))])))) {
									(((ten[((unsigned int)(0))][((unsigned int)(0))])) = ((((((z[((unsigned int)((var_127)))]))[((unsigned int)((var_126)))]))[((unsigned int)((var_125)))])));
									(((j1[((unsigned int)(0))][((unsigned int)(0))])) = (var_125));
									(((j2[((unsigned int)(0))][((unsigned int)(0))])) = (var_126));
									(((j3[((unsigned int)(0))][((unsigned int)(0))])) = (var_127));
									bubble(ten, j1, j2, j3, 10, 0);
								};
							};
							((i1) = (1+(((int)(ceil((((double)(((n1-1)-1)))/((double)(1))))))*1)));
						};
					};
					((i2) = (1+(((int)(ceil((((double)(((n2-1)-1)))/((double)(1))))))*1)));
				};
			};
			((i3) = (1+(((int)(ceil((((double)(((n3-1)-1)))/((double)(1))))))*1)));
		};
		((i1) = (10-1));
		((i0) = (10-1));
		{
			for(int var_128 = (((int)(0))-(10-1)); var_128 < ((((int)(0))-0)+1); var_128 += 1) {
				((best) = ((((((z[((unsigned int)(((j3[((unsigned int)((i1)))][((unsigned int)(1))]))))]))[((unsigned int)(((j2[((unsigned int)((i1)))][((unsigned int)(1))]))))]))[((unsigned int)(((j1[((unsigned int)((i1)))][((unsigned int)(1))]))))])));
				if(((best)==((((((z[((unsigned int)(((j3[((unsigned int)((i1)))][((unsigned int)(1))]))))]))[((unsigned int)(((j2[((unsigned int)((i1)))][((unsigned int)(1))]))))]))[((unsigned int)(((j1[((unsigned int)((i1)))][((unsigned int)(1))]))))])))) {
					(((jg[((unsigned int)(0))][((unsigned int)((((int)(0))-(var_128))))][((unsigned int)(1))])) = 0);
					(((jg[((unsigned int)(1))][((unsigned int)((((int)(0))-(var_128))))][((unsigned int)(1))])) = (((((*var_78).is1))-1)+((j1[((unsigned int)((i1)))][((unsigned int)(1))]))));
					(((jg[((unsigned int)(2))][((unsigned int)((((int)(0))-(var_128))))][((unsigned int)(1))])) = (((((*var_78).is2))-1)+((j2[((unsigned int)((i1)))][((unsigned int)(1))]))));
					(((jg[((unsigned int)(3))][((unsigned int)((((int)(0))-(var_128))))][((unsigned int)(1))])) = (((((*var_78).is3))-1)+((j3[((unsigned int)((i1)))][((unsigned int)(1))]))));
					((i1) = ((i1)-1));
				} else {
					(((jg[((unsigned int)(0))][((unsigned int)((((int)(0))-(var_128))))][((unsigned int)(1))])) = 0);
					(((jg[((unsigned int)(1))][((unsigned int)((((int)(0))-(var_128))))][((unsigned int)(1))])) = 0);
					(((jg[((unsigned int)(2))][((unsigned int)((((int)(0))-(var_128))))][((unsigned int)(1))])) = 0);
					(((jg[((unsigned int)(3))][((unsigned int)((((int)(0))-(var_128))))][((unsigned int)(1))])) = 0);
				};
				(((ten[((unsigned int)((((int)(0))-(var_128))))][((unsigned int)(1))])) = (best));
				((best) = ((((((z[((unsigned int)(((j3[((unsigned int)((i0)))][((unsigned int)(0))]))))]))[((unsigned int)(((j2[((unsigned int)((i0)))][((unsigned int)(0))]))))]))[((unsigned int)(((j1[((unsigned int)((i0)))][((unsigned int)(0))]))))])));
				if(((best)==((((((z[((unsigned int)(((j3[((unsigned int)((i0)))][((unsigned int)(0))]))))]))[((unsigned int)(((j2[((unsigned int)((i0)))][((unsigned int)(0))]))))]))[((unsigned int)(((j1[((unsigned int)((i0)))][((unsigned int)(0))]))))])))) {
					(((jg[((unsigned int)(0))][((unsigned int)((((int)(0))-(var_128))))][((unsigned int)(0))])) = 0);
					(((jg[((unsigned int)(1))][((unsigned int)((((int)(0))-(var_128))))][((unsigned int)(0))])) = (((((*var_78).is1))-1)+((j1[((unsigned int)((i0)))][((unsigned int)(0))]))));
					(((jg[((unsigned int)(2))][((unsigned int)((((int)(0))-(var_128))))][((unsigned int)(0))])) = (((((*var_78).is2))-1)+((j2[((unsigned int)((i0)))][((unsigned int)(0))]))));
					(((jg[((unsigned int)(3))][((unsigned int)((((int)(0))-(var_128))))][((unsigned int)(0))])) = (((((*var_78).is3))-1)+((j3[((unsigned int)((i0)))][((unsigned int)(0))]))));
					((i0) = ((i0)-1));
				} else {
					(((jg[((unsigned int)(0))][((unsigned int)((((int)(0))-(var_128))))][((unsigned int)(0))])) = 0);
					(((jg[((unsigned int)(1))][((unsigned int)((((int)(0))-(var_128))))][((unsigned int)(0))])) = 0);
					(((jg[((unsigned int)(2))][((unsigned int)((((int)(0))-(var_128))))][((unsigned int)(0))])) = 0);
					(((jg[((unsigned int)(3))][((unsigned int)((((int)(0))-(var_128))))][((unsigned int)(0))])) = 0);
				};
				(((ten[((unsigned int)((((int)(0))-(var_128))))][((unsigned int)(0))])) = (best));
			};
			((i) = ((10-1)+(((int)(ceil((((double)((((((int)(0))-0)+1)-(10-1))))/((double)(1))))))*1)));
		};
		((m1) = ((i1)+1));
		((m0) = ((i0)+1));
		{
			for(int var_131 = 0; var_131 < n3; var_131 += 1) {
				{
					for(int var_130 = 0; var_130 < n2; var_130 += 1) {
						{
							for(int var_129 = 0; var_129 < n1; var_129 += 1) {
								(((((((z[((unsigned int)((var_131)))]))[((unsigned int)((var_130)))]))[((unsigned int)((var_129)))])) = 0.0);
							};
							((i1) = (0+(((int)(ceil((((double)((n1-0)))/((double)(1))))))*1)));
						};
					};
					((i2) = (0+(((int)(ceil((((double)((n2-0)))/((double)(1))))))*1)));
				};
			};
			((i3) = (0+(((int)(ceil((((double)((n3-0)))/((double)(1))))))*1)));
		};
		{
			for(int var_132 = (((int)(0))-(10-1)); var_132 < ((((int)(0))-(m0))+1); var_132 += 1) {
				(((((((z[((unsigned int)(((j3[((unsigned int)((((int)(0))-(var_132))))][((unsigned int)(0))]))))]))[((unsigned int)(((j2[((unsigned int)((((int)(0))-(var_132))))][((unsigned int)(0))]))))]))[((unsigned int)(((j1[((unsigned int)((((int)(0))-(var_132))))][((unsigned int)(0))]))))])) = (((double)(0))-1.0));
			};
			((i) = ((10-1)+(((int)(ceil((((double)((((((int)(0))-(m0))+1)-(10-1))))/((double)(1))))))*1)));
		};
		{
			for(int var_133 = (((int)(0))-(10-1)); var_133 < ((((int)(0))-(m1))+1); var_133 += 1) {
				(((((((z[((unsigned int)(((j3[((unsigned int)((((int)(0))-(var_133))))][((unsigned int)(1))]))))]))[((unsigned int)(((j2[((unsigned int)((((int)(0))-(var_133))))][((unsigned int)(1))]))))]))[((unsigned int)(((j1[((unsigned int)((((int)(0))-(var_133))))][((unsigned int)(1))]))))])) = 1.0);
			};
			((i) = ((10-1)+(((int)(ceil((((double)((((((int)(0))-(m1))+1)-(10-1))))/((double)(1))))))*1)));
		};
		comm3(z, n1, n2, n3, k);
	}
}


// start code fragment :: Definitions for function type: __insieme_funType_type_11 //
// Abstract prototype for lambdas of type __insieme_funType_type_11
struct __insieme_funType_type_11 { 
    void(*fun)(void*,double***,int,int,int,double*,double*,int,int,int);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_11
void call__insieme_funType_type_11(struct __insieme_funType_type_11* lambda,double*** p1,int p2,int p3,int p4,double* p5,double* p6,int p7,int p8,int p9) { return lambda->fun(lambda,p1,p2,p3,p4,p5,p6,p7,p8,p9); }

// start code fragment :: Definitions for function type: __insieme_funType_type_12 //
// Abstract prototype for lambdas of type __insieme_funType_type_12
struct __insieme_funType_type_12 { 
    void(*fun)(void*,double***,int,int,int,double*,double*,int,int,int);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: Prototype for external function: fabs //
double fabs(double);

// start code fragment :: Prototype for external function: sqrt //
double sqrt(double);

// start code fragment :: Definition of norm2u3 //
void norm2u3(void* _capture, double*** r, int n1, int n2, int n3, double* rnm2, double* rnmu, int nx, int ny, int nz) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_159 = ((struct __insieme_funType_type_12*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		double tmp = 0.0;
		int i3 = 0;
		int i2 = 0;
		int i1 = 0;
		int n = 0;
		double p_s = 0.0;
		double p_a = 0.0;
		((n) = ((nx*ny)*nz));
		{
			for(int var_169 = 1; var_169 < (n3-1); var_169 += 1) {
				{
					for(int var_168 = 1; var_168 < (n2-1); var_168 += 1) {
						{
							for(int var_167 = 1; var_167 < (n1-1); var_167 += 1) {
								((p_s) = ((p_s)+(((((((r[((unsigned int)((var_169)))]))[((unsigned int)((var_168)))]))[((unsigned int)((var_167)))]))*((((((r[((unsigned int)((var_169)))]))[((unsigned int)((var_168)))]))[((unsigned int)((var_167)))])))));
								((tmp) = fabs(((((((r[((unsigned int)((var_169)))]))[((unsigned int)((var_168)))]))[((unsigned int)((var_167)))]))));
								if(((tmp)>(p_a))) {
									((p_a) = (tmp));
								};
							};
							((i1) = (1+(((int)(ceil((((double)(((n1-1)-1)))/((double)(1))))))*1)));
						};
					};
					((i2) = (1+(((int)(ceil((((double)(((n2-1)-1)))/((double)(1))))))*1)));
				};
			};
			((i3) = (1+(((int)(ceil((((double)(((n3-1)-1)))/((double)(1))))))*1)));
		};
		{
			((((*var_159).s)) = ((((*var_159).s))+(p_s)));
			if(((p_a)>((rnmu[0])))) {
				(((rnmu[0])) = (p_a));
			};
		};
		{
			(((rnm2[0])) = sqrt(((((*var_159).s))/((double)((n))))));
			((((*var_159).s)) = 0.0);
		};
	}
}


// start code fragment :: Definitions for function type: __insieme_funType_type_13 //
// Abstract prototype for lambdas of type __insieme_funType_type_13
struct __insieme_funType_type_13 { 
    void(*fun)(void*,double***,double***,double***,int,int,int,double*,int);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_13
void call__insieme_funType_type_13(struct __insieme_funType_type_13* lambda,double*** p1,double*** p2,double*** p3,int p4,int p5,int p6,double* p7,int p8) { return lambda->fun(lambda,p1,p2,p3,p4,p5,p6,p7,p8); }

// start code fragment :: Definitions for function type: __insieme_funType_type_14 //
// Abstract prototype for lambdas of type __insieme_funType_type_14
struct __insieme_funType_type_14 { 
    void(*fun)(void*,double***,double***,double***,int,int,int,double*,int);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: Definitions for function type: __insieme_funType_type_15 //
// Abstract prototype for lambdas of type __insieme_funType_type_15
struct __insieme_funType_type_15 { 
    void(*fun)(void*,double***,int,int,int,char*,int);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_15
void call__insieme_funType_type_15(struct __insieme_funType_type_15* lambda,double*** p1,int p2,int p3,int p4,char* p5,int p6) { return lambda->fun(lambda,p1,p2,p3,p4,p5,p6); }

// start code fragment :: Definitions for function type: __insieme_funType_type_16 //
// Abstract prototype for lambdas of type __insieme_funType_type_16
struct __insieme_funType_type_16 { 
    void(*fun)(void*,double***,int,int,int,char*,int);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: Definition of rep_nrm //
void rep_nrm(void* _capture, double*** u, int n1, int n2, int n3, char* title, int kk) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_195 = ((struct __insieme_funType_type_16*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		double rnm2 = 0.0;
		double rnmu = 0.0;
		call__insieme_funType_type_11(((struct __insieme_funType_type_11*)(&((struct __insieme_funType_type_12){&norm2u3, 0, var_195}))), u, n1, n2, n3, &rnm2, &rnmu, (((*((*var_195).nx))[((unsigned int)(kk))])), (((*((*var_195).ny))[((unsigned int)(kk))])), (((*((*var_195).nz))[((unsigned int)(kk))])));
		printf(" Level%2d in %8s: norms =%21.14e%21.14e\n", kk, title, (rnm2), (rnmu));
	}
}


// start code fragment :: Definition of showall //
void showall(double*** z, int n1, int n2, int n3) {
	{
		int i1 = 0;
		int i2 = 0;
		int i3 = 0;
		int m1 = 0;
		int m2 = 0;
		int m3 = 0;
		((m1) = (((n1<18))?(var_210):(18)));
		((m2) = (((n2<14))?(var_213):(14)));
		((m3) = (((n3<18))?(var_216):(18)));
		printf("\n", 0);{
			for(int var_220 = 0; var_220 < (m3); var_220 += 1) {
				{
					for(int var_219 = 0; var_219 < (m1); var_219 += 1) {
						{
							for(int var_218 = 0; var_218 < (m2); var_218 += 1) {
								printf("%6.3f", ((((((z[((unsigned int)((var_220)))]))[((unsigned int)((var_218)))]))[((unsigned int)((var_219)))])));
							};
							((i2) = (0+(((int)(ceil((((double)(((m2)-0)))/((double)(1))))))*1)));
						};
						printf("\n", 0);
					};
					((i1) = (0+(((int)(ceil((((double)(((m1)-0)))/((double)(1))))))*1)));
				};
				printf(" - - - - - - - \n", 0);
			};
			((i3) = (0+(((int)(ceil((((double)(((m3)-0)))/((double)(1))))))*1)));
		};
		printf("\n", 0);
	}
}


// start code fragment :: Definition of resid //
void resid(void* _capture, double*** u, double*** v, double*** r, int n1, int n2, int n3, double* a, int k) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_179 = ((struct __insieme_funType_type_14*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		int i3 = 0;
		int i2 = 0;
		int i1 = 0;
		double u1[1037];
		double u2[1037];
		{
			for(int var_188 = 1; var_188 < (n3-1); var_188 += 1) {
				{
					for(int var_187 = 1; var_187 < (n2-1); var_187 += 1) {
						{
							for(int var_185 = 0; var_185 < n1; var_185 += 1) {
								(((u1[((unsigned int)((var_185)))])) = (((((((((u[((unsigned int)((var_188)))]))[((unsigned int)(((var_187)-1)))]))[((unsigned int)((var_185)))]))+((((((u[((unsigned int)((var_188)))]))[((unsigned int)(((var_187)+1)))]))[((unsigned int)((var_185)))])))+((((((u[((unsigned int)(((var_188)-1)))]))[((unsigned int)((var_187)))]))[((unsigned int)((var_185)))])))+((((((u[((unsigned int)(((var_188)+1)))]))[((unsigned int)((var_187)))]))[((unsigned int)((var_185)))]))));
								(((u2[((unsigned int)((var_185)))])) = (((((((((u[((unsigned int)(((var_188)-1)))]))[((unsigned int)(((var_187)-1)))]))[((unsigned int)((var_185)))]))+((((((u[((unsigned int)(((var_188)-1)))]))[((unsigned int)(((var_187)+1)))]))[((unsigned int)((var_185)))])))+((((((u[((unsigned int)(((var_188)+1)))]))[((unsigned int)(((var_187)-1)))]))[((unsigned int)((var_185)))])))+((((((u[((unsigned int)(((var_188)+1)))]))[((unsigned int)(((var_187)+1)))]))[((unsigned int)((var_185)))]))));
							};
							((i1) = (0+(((int)(ceil((((double)((n1-0)))/((double)(1))))))*1)));
						};
						{
							for(int var_186 = 1; var_186 < (n1-1); var_186 += 1) {
								(((((((r[((unsigned int)((var_188)))]))[((unsigned int)((var_187)))]))[((unsigned int)((var_186)))])) = (((((((((v[((unsigned int)((var_188)))]))[((unsigned int)((var_187)))]))[((unsigned int)((var_186)))]))-(((a[((unsigned int)(0))]))*((((((u[((unsigned int)((var_188)))]))[((unsigned int)((var_187)))]))[((unsigned int)((var_186)))]))))-(((a[((unsigned int)(2))]))*((((u2[((unsigned int)((var_186)))]))+((u1[((unsigned int)(((var_186)-1)))])))+((u1[((unsigned int)(((var_186)+1)))])))))-(((a[((unsigned int)(3))]))*(((u2[((unsigned int)(((var_186)-1)))]))+((u2[((unsigned int)(((var_186)+1)))]))))));
							};
							((i1) = (1+(((int)(ceil((((double)(((n1-1)-1)))/((double)(1))))))*1)));
						};
					};
					((i2) = (1+(((int)(ceil((((double)(((n2-1)-1)))/((double)(1))))))*1)));
				};
			};
			((i3) = (1+(((int)(ceil((((double)(((n3-1)-1)))/((double)(1))))))*1)));
		};
		comm3(r, n1, n2, n3, k);
		if(((((*((*var_179).debug_vec))[((unsigned int)(0))]))>=1)) {
			call__insieme_funType_type_15(((struct __insieme_funType_type_15*)(&((struct __insieme_funType_type_16){&rep_nrm, 0, var_179}))), r, n1, n2, n3, "   resid", k);
		};
		if(((((*((*var_179).debug_vec))[((unsigned int)(2))]))>=k)) {
			showall(r, n1, n2, n3);
		};
	}
}


// start code fragment :: Definitions for function type: __insieme_funType_type_17 //
// Abstract prototype for lambdas of type __insieme_funType_type_17
struct __insieme_funType_type_17 { 
    void(*fun)(void*,double****,double***,double****,double*,double*,int,int,int,int);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_17
void call__insieme_funType_type_17(struct __insieme_funType_type_17* lambda,double**** p1,double*** p2,double**** p3,double* p4,double* p5,int p6,int p7,int p8,int p9) { return lambda->fun(lambda,p1,p2,p3,p4,p5,p6,p7,p8,p9); }

// start code fragment :: Definitions for function type: __insieme_funType_type_18 //
// Abstract prototype for lambdas of type __insieme_funType_type_18
struct __insieme_funType_type_18 { 
    void(*fun)(void*,double****,double***,double****,double*,double*,int,int,int,int);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: Definitions for function type: __insieme_funType_type_19 //
// Abstract prototype for lambdas of type __insieme_funType_type_19
struct __insieme_funType_type_19 { 
    void(*fun)(void*,double***,int,int,int,double***,int,int,int,int);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_19
void call__insieme_funType_type_19(struct __insieme_funType_type_19* lambda,double*** p1,int p2,int p3,int p4,double*** p5,int p6,int p7,int p8,int p9) { return lambda->fun(lambda,p1,p2,p3,p4,p5,p6,p7,p8,p9); }

// start code fragment :: Definitions for function type: __insieme_funType_type_20 //
// Abstract prototype for lambdas of type __insieme_funType_type_20
struct __insieme_funType_type_20 { 
    void(*fun)(void*,double***,int,int,int,double***,int,int,int,int);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: Definition of rprj3 //
void rprj3(void* _capture, double*** r, int m1k, int m2k, int m3k, double*** s, int m1j, int m2j, int m3j, int k) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_243 = ((struct __insieme_funType_type_20*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		int j3 = 0;
		int j2 = 0;
		int j1 = 0;
		int i3 = 0;
		int i2 = 0;
		int i1 = 0;
		int d1 = 0;
		int d2 = 0;
		int d3 = 0;
		double x1[1037];
		double y1[1037];
		double x2 = 0.0;
		double y2 = 0.0;
		if((m1k==3)) {
			((d1) = 2);
		} else {
			((d1) = 1);
		};
		if((m2k==3)) {
			((d2) = 2);
		} else {
			((d2) = 1);
		};
		if((m3k==3)) {
			((d3) = 2);
		} else {
			((d3) = 1);
		};
		{
			for(int var_260 = 1; var_260 < (m3j-1); var_260 += 1) {
				((i3) = ((2*(var_260))-(d3)));
				{
					for(int var_259 = 1; var_259 < (m2j-1); var_259 += 1) {
						((i2) = ((2*(var_259))-(d2)));
						{
							for(int var_257 = 1; var_257 < m1j; var_257 += 1) {
								((i1) = ((2*(var_257))-(d1)));
								(((x1[((unsigned int)((i1)))])) = (((((((((r[((unsigned int)(((i3)+1)))]))[((unsigned int)((i2)))]))[((unsigned int)((i1)))]))+((((((r[((unsigned int)(((i3)+1)))]))[((unsigned int)(((i2)+2)))]))[((unsigned int)((i1)))])))+((((((r[((unsigned int)((i3)))]))[((unsigned int)(((i2)+1)))]))[((unsigned int)((i1)))])))+((((((r[((unsigned int)(((i3)+2)))]))[((unsigned int)(((i2)+1)))]))[((unsigned int)((i1)))]))));
								(((y1[((unsigned int)((i1)))])) = (((((((((r[((unsigned int)((i3)))]))[((unsigned int)((i2)))]))[((unsigned int)((i1)))]))+((((((r[((unsigned int)(((i3)+2)))]))[((unsigned int)((i2)))]))[((unsigned int)((i1)))])))+((((((r[((unsigned int)((i3)))]))[((unsigned int)(((i2)+2)))]))[((unsigned int)((i1)))])))+((((((r[((unsigned int)(((i3)+2)))]))[((unsigned int)(((i2)+2)))]))[((unsigned int)((i1)))]))));
							};
							((j1) = (1+(((int)(ceil((((double)((m1j-1)))/((double)(1))))))*1)));
						};
						{
							for(int var_258 = 1; var_258 < (m1j-1); var_258 += 1) {
								((i1) = ((2*(var_258))-(d1)));
								((y2) = (((((((((r[((unsigned int)((i3)))]))[((unsigned int)((i2)))]))[((unsigned int)(((i1)+1)))]))+((((((r[((unsigned int)(((i3)+2)))]))[((unsigned int)((i2)))]))[((unsigned int)(((i1)+1)))])))+((((((r[((unsigned int)((i3)))]))[((unsigned int)(((i2)+2)))]))[((unsigned int)(((i1)+1)))])))+((((((r[((unsigned int)(((i3)+2)))]))[((unsigned int)(((i2)+2)))]))[((unsigned int)(((i1)+1)))]))));
								((x2) = (((((((((r[((unsigned int)(((i3)+1)))]))[((unsigned int)((i2)))]))[((unsigned int)(((i1)+1)))]))+((((((r[((unsigned int)(((i3)+1)))]))[((unsigned int)(((i2)+2)))]))[((unsigned int)(((i1)+1)))])))+((((((r[((unsigned int)((i3)))]))[((unsigned int)(((i2)+1)))]))[((unsigned int)(((i1)+1)))])))+((((((r[((unsigned int)(((i3)+2)))]))[((unsigned int)(((i2)+1)))]))[((unsigned int)(((i1)+1)))]))));
								(((((((s[((unsigned int)((var_260)))]))[((unsigned int)((var_259)))]))[((unsigned int)((var_258)))])) = ((((0.5*((((((r[((unsigned int)(((i3)+1)))]))[((unsigned int)(((i2)+1)))]))[((unsigned int)(((i1)+1)))])))+(0.25*((((((((r[((unsigned int)(((i3)+1)))]))[((unsigned int)(((i2)+1)))]))[((unsigned int)((i1)))]))+((((((r[((unsigned int)(((i3)+1)))]))[((unsigned int)(((i2)+1)))]))[((unsigned int)(((i1)+2)))])))+(x2))))+(0.125*((((x1[((unsigned int)((i1)))]))+((x1[((unsigned int)(((i1)+2)))])))+(y2))))+(0.0625*(((y1[((unsigned int)((i1)))]))+((y1[((unsigned int)(((i1)+2)))]))))));
							};
							((j1) = (1+(((int)(ceil((((double)(((m1j-1)-1)))/((double)(1))))))*1)));
						};
					};
					((j2) = (1+(((int)(ceil((((double)(((m2j-1)-1)))/((double)(1))))))*1)));
				};
			};
			((j3) = (1+(((int)(ceil((((double)(((m3j-1)-1)))/((double)(1))))))*1)));
		};
		comm3(s, m1j, m2j, m3j, (k-1));
		if(((((*((*var_243).debug_vec))[((unsigned int)(0))]))>=1)) {
			call__insieme_funType_type_15(((struct __insieme_funType_type_15*)(&((struct __insieme_funType_type_16){&rep_nrm, 0, var_243}))), s, m1j, m2j, m3j, "   rprj3", (k-1));
		};
		if(((((*((*var_243).debug_vec))[((unsigned int)(4))]))>=k)) {
			showall(s, m1j, m2j, m3j);
		};
	}
}


// start code fragment :: Definitions for function type: __insieme_funType_type_21 //
// Abstract prototype for lambdas of type __insieme_funType_type_21
struct __insieme_funType_type_21 { 
    void(*fun)(void*,double***,double***,int,int,int,double*,int);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_21
void call__insieme_funType_type_21(struct __insieme_funType_type_21* lambda,double*** p1,double*** p2,int p3,int p4,int p5,double* p6,int p7) { return lambda->fun(lambda,p1,p2,p3,p4,p5,p6,p7); }

// start code fragment :: Definitions for function type: __insieme_funType_type_22 //
// Abstract prototype for lambdas of type __insieme_funType_type_22
struct __insieme_funType_type_22 { 
    void(*fun)(void*,double***,double***,int,int,int,double*,int);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: Definition of psinv //
void psinv(void* _capture, double*** r, double*** u, int n1, int n2, int n3, double* c, int k) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_271 = ((struct __insieme_funType_type_22*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		int i3 = 0;
		int i2 = 0;
		int i1 = 0;
		double r1[1037];
		double r2[1037];
		{
			for(int var_280 = 1; var_280 < (n3-1); var_280 += 1) {
				{
					for(int var_279 = 1; var_279 < (n2-1); var_279 += 1) {
						{
							for(int var_277 = 0; var_277 < n1; var_277 += 1) {
								(((r1[((unsigned int)((var_277)))])) = (((((((((r[((unsigned int)((var_280)))]))[((unsigned int)(((var_279)-1)))]))[((unsigned int)((var_277)))]))+((((((r[((unsigned int)((var_280)))]))[((unsigned int)(((var_279)+1)))]))[((unsigned int)((var_277)))])))+((((((r[((unsigned int)(((var_280)-1)))]))[((unsigned int)((var_279)))]))[((unsigned int)((var_277)))])))+((((((r[((unsigned int)(((var_280)+1)))]))[((unsigned int)((var_279)))]))[((unsigned int)((var_277)))]))));
								(((r2[((unsigned int)((var_277)))])) = (((((((((r[((unsigned int)(((var_280)-1)))]))[((unsigned int)(((var_279)-1)))]))[((unsigned int)((var_277)))]))+((((((r[((unsigned int)(((var_280)-1)))]))[((unsigned int)(((var_279)+1)))]))[((unsigned int)((var_277)))])))+((((((r[((unsigned int)(((var_280)+1)))]))[((unsigned int)(((var_279)-1)))]))[((unsigned int)((var_277)))])))+((((((r[((unsigned int)(((var_280)+1)))]))[((unsigned int)(((var_279)+1)))]))[((unsigned int)((var_277)))]))));
							};
							((i1) = (0+(((int)(ceil((((double)((n1-0)))/((double)(1))))))*1)));
						};
						{
							for(int var_278 = 1; var_278 < (n1-1); var_278 += 1) {
								(((((((u[((unsigned int)((var_280)))]))[((unsigned int)((var_279)))]))[((unsigned int)((var_278)))])) = (((((((((u[((unsigned int)((var_280)))]))[((unsigned int)((var_279)))]))[((unsigned int)((var_278)))]))+(((c[((unsigned int)(0))]))*((((((r[((unsigned int)((var_280)))]))[((unsigned int)((var_279)))]))[((unsigned int)((var_278)))]))))+(((c[((unsigned int)(1))]))*((((((((r[((unsigned int)((var_280)))]))[((unsigned int)((var_279)))]))[((unsigned int)(((var_278)-1)))]))+((((((r[((unsigned int)((var_280)))]))[((unsigned int)((var_279)))]))[((unsigned int)(((var_278)+1)))])))+((r1[((unsigned int)((var_278)))])))))+(((c[((unsigned int)(2))]))*((((r2[((unsigned int)((var_278)))]))+((r1[((unsigned int)(((var_278)-1)))])))+((r1[((unsigned int)(((var_278)+1)))]))))));
							};
							((i1) = (1+(((int)(ceil((((double)(((n1-1)-1)))/((double)(1))))))*1)));
						};
					};
					((i2) = (1+(((int)(ceil((((double)(((n2-1)-1)))/((double)(1))))))*1)));
				};
			};
			((i3) = (1+(((int)(ceil((((double)(((n3-1)-1)))/((double)(1))))))*1)));
		};
		comm3(u, n1, n2, n3, k);
		if(((((*((*var_271).debug_vec))[((unsigned int)(0))]))>=1)) {
			call__insieme_funType_type_15(((struct __insieme_funType_type_15*)(&((struct __insieme_funType_type_16){&rep_nrm, 0, var_271}))), u, n1, n2, n3, "   psinv", k);
		};
		if(((((*((*var_271).debug_vec))[((unsigned int)(3))]))>=k)) {
			showall(u, n1, n2, n3);
		};
	}
}


// start code fragment :: Definition of interp //
void interp(void* _capture, double*** z, int mm1, int mm2, int mm3, double*** u, int n1, int n2, int n3, int k) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_291 = ((struct __insieme_funType_type_20*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		int i3 = 0;
		int i2 = 0;
		int i1 = 0;
		int d1 = 0;
		int d2 = 0;
		int d3 = 0;
		int t1 = 0;
		int t2 = 0;
		int t3 = 0;
		double z1[1037];
		double z2[1037];
		double z3[1037];
		if((((n1!=3)&&(n2!=3))&&(n3!=3))) {
			{
				for(int var_310 = 0; var_310 < (mm3-1); var_310 += 1) {
					{
						for(int var_309 = 0; var_309 < (mm2-1); var_309 += 1) {
							{
								for(int var_304 = 0; var_304 < mm1; var_304 += 1) {
									(((z1[((unsigned int)((var_304)))])) = (((((((z[((unsigned int)((var_310)))]))[((unsigned int)(((var_309)+1)))]))[((unsigned int)((var_304)))]))+((((((z[((unsigned int)((var_310)))]))[((unsigned int)((var_309)))]))[((unsigned int)((var_304)))]))));
									(((z2[((unsigned int)((var_304)))])) = (((((((z[((unsigned int)(((var_310)+1)))]))[((unsigned int)((var_309)))]))[((unsigned int)((var_304)))]))+((((((z[((unsigned int)((var_310)))]))[((unsigned int)((var_309)))]))[((unsigned int)((var_304)))]))));
									(((z3[((unsigned int)((var_304)))])) = ((((((((z[((unsigned int)(((var_310)+1)))]))[((unsigned int)(((var_309)+1)))]))[((unsigned int)((var_304)))]))+((((((z[((unsigned int)(((var_310)+1)))]))[((unsigned int)((var_309)))]))[((unsigned int)((var_304)))])))+((z1[((unsigned int)((var_304)))]))));
								};
								((i1) = (0+(((int)(ceil((((double)((mm1-0)))/((double)(1))))))*1)));
							};
							{
								for(int var_305 = 0; var_305 < (mm1-1); var_305 += 1) {
									(((((((u[((unsigned int)((2*(var_310))))]))[((unsigned int)((2*(var_309))))]))[((unsigned int)((2*(var_305))))])) = (((((((u[((unsigned int)((2*(var_310))))]))[((unsigned int)((2*(var_309))))]))[((unsigned int)((2*(var_305))))]))+((((((z[((unsigned int)((var_310)))]))[((unsigned int)((var_309)))]))[((unsigned int)((var_305)))]))));
									(((((((u[((unsigned int)((2*(var_310))))]))[((unsigned int)((2*(var_309))))]))[((unsigned int)(((2*(var_305))+1)))])) = (((((((u[((unsigned int)((2*(var_310))))]))[((unsigned int)((2*(var_309))))]))[((unsigned int)(((2*(var_305))+1)))]))+(0.5*(((((((z[((unsigned int)((var_310)))]))[((unsigned int)((var_309)))]))[((unsigned int)(((var_305)+1)))]))+((((((z[((unsigned int)((var_310)))]))[((unsigned int)((var_309)))]))[((unsigned int)((var_305)))]))))));
								};
								((i1) = (0+(((int)(ceil((((double)(((mm1-1)-0)))/((double)(1))))))*1)));
							};
							{
								for(int var_306 = 0; var_306 < (mm1-1); var_306 += 1) {
									(((((((u[((unsigned int)((2*(var_310))))]))[((unsigned int)(((2*(var_309))+1)))]))[((unsigned int)((2*(var_306))))])) = (((((((u[((unsigned int)((2*(var_310))))]))[((unsigned int)(((2*(var_309))+1)))]))[((unsigned int)((2*(var_306))))]))+(0.5*((z1[((unsigned int)((var_306)))])))));
									(((((((u[((unsigned int)((2*(var_310))))]))[((unsigned int)(((2*(var_309))+1)))]))[((unsigned int)(((2*(var_306))+1)))])) = (((((((u[((unsigned int)((2*(var_310))))]))[((unsigned int)(((2*(var_309))+1)))]))[((unsigned int)(((2*(var_306))+1)))]))+(0.25*(((z1[((unsigned int)((var_306)))]))+((z1[((unsigned int)(((var_306)+1)))]))))));
								};
								((i1) = (0+(((int)(ceil((((double)(((mm1-1)-0)))/((double)(1))))))*1)));
							};
							{
								for(int var_307 = 0; var_307 < (mm1-1); var_307 += 1) {
									(((((((u[((unsigned int)(((2*(var_310))+1)))]))[((unsigned int)((2*(var_309))))]))[((unsigned int)((2*(var_307))))])) = (((((((u[((unsigned int)(((2*(var_310))+1)))]))[((unsigned int)((2*(var_309))))]))[((unsigned int)((2*(var_307))))]))+(0.5*((z2[((unsigned int)((var_307)))])))));
									(((((((u[((unsigned int)(((2*(var_310))+1)))]))[((unsigned int)((2*(var_309))))]))[((unsigned int)(((2*(var_307))+1)))])) = (((((((u[((unsigned int)(((2*(var_310))+1)))]))[((unsigned int)((2*(var_309))))]))[((unsigned int)(((2*(var_307))+1)))]))+(0.25*(((z2[((unsigned int)((var_307)))]))+((z2[((unsigned int)(((var_307)+1)))]))))));
								};
								((i1) = (0+(((int)(ceil((((double)(((mm1-1)-0)))/((double)(1))))))*1)));
							};
							{
								for(int var_308 = 0; var_308 < (mm1-1); var_308 += 1) {
									(((((((u[((unsigned int)(((2*(var_310))+1)))]))[((unsigned int)(((2*(var_309))+1)))]))[((unsigned int)((2*(var_308))))])) = (((((((u[((unsigned int)(((2*(var_310))+1)))]))[((unsigned int)(((2*(var_309))+1)))]))[((unsigned int)((2*(var_308))))]))+(0.25*((z3[((unsigned int)((var_308)))])))));
									(((((((u[((unsigned int)(((2*(var_310))+1)))]))[((unsigned int)(((2*(var_309))+1)))]))[((unsigned int)(((2*(var_308))+1)))])) = (((((((u[((unsigned int)(((2*(var_310))+1)))]))[((unsigned int)(((2*(var_309))+1)))]))[((unsigned int)(((2*(var_308))+1)))]))+(0.125*(((z3[((unsigned int)((var_308)))]))+((z3[((unsigned int)(((var_308)+1)))]))))));
								};
								((i1) = (0+(((int)(ceil((((double)(((mm1-1)-0)))/((double)(1))))))*1)));
							};
						};
						((i2) = (0+(((int)(ceil((((double)(((mm2-1)-0)))/((double)(1))))))*1)));
					};
				};
				((i3) = (0+(((int)(ceil((((double)(((mm3-1)-0)))/((double)(1))))))*1)));
			};
		} else {
			if((n1==3)) {
				((d1) = 2);
				((t1) = 1);
			} else {
				((d1) = 1);
				((t1) = 0);
			};
			if((n2==3)) {
				((d2) = 2);
				((t2) = 1);
			} else {
				((d2) = 1);
				((t2) = 0);
			};
			if((n3==3)) {
				((d3) = 2);
				((t3) = 1);
			} else {
				((d3) = 1);
				((t3) = 0);
			};
			{
				for(int var_317 = (d3); var_317 < ((mm3-1)+1); var_317 += 1) {
					{
						for(int var_313 = (d2); var_313 < ((mm2-1)+1); var_313 += 1) {
							{
								for(int var_311 = (d1); var_311 < ((mm1-1)+1); var_311 += 1) {
									(((((((u[((unsigned int)((((2*(var_317))-(d3))-1)))]))[((unsigned int)((((2*(var_313))-(d2))-1)))]))[((unsigned int)((((2*(var_311))-(d1))-1)))])) = (((((((u[((unsigned int)((((2*(var_317))-(d3))-1)))]))[((unsigned int)((((2*(var_313))-(d2))-1)))]))[((unsigned int)((((2*(var_311))-(d1))-1)))]))+((((((z[((unsigned int)(((var_317)-1)))]))[((unsigned int)(((var_313)-1)))]))[((unsigned int)(((var_311)-1)))]))));
								};
								((i1) = ((d1)+(((int)(ceil((((double)((((mm1-1)+1)-(d1))))/((double)(1))))))*1)));
							};
							{
								for(int var_312 = 1; var_312 < ((mm1-1)+1); var_312 += 1) {
									(((((((u[((unsigned int)((((2*(var_317))-(d3))-1)))]))[((unsigned int)((((2*(var_313))-(d2))-1)))]))[((unsigned int)((((2*(var_312))-(t1))-1)))])) = (((((((u[((unsigned int)((((2*(var_317))-(d3))-1)))]))[((unsigned int)((((2*(var_313))-(d2))-1)))]))[((unsigned int)((((2*(var_312))-(t1))-1)))]))+(0.5*(((((((z[((unsigned int)(((var_317)-1)))]))[((unsigned int)(((var_313)-1)))]))[((unsigned int)((var_312)))]))+((((((z[((unsigned int)(((var_317)-1)))]))[((unsigned int)(((var_313)-1)))]))[((unsigned int)(((var_312)-1)))]))))));
								};
								((i1) = (1+(((int)(ceil((((double)((((mm1-1)+1)-1)))/((double)(1))))))*1)));
							};
						};
						((i2) = ((d2)+(((int)(ceil((((double)((((mm2-1)+1)-(d2))))/((double)(1))))))*1)));
					};
					{
						for(int var_316 = 1; var_316 < ((mm2-1)+1); var_316 += 1) {
							{
								for(int var_314 = (d1); var_314 < ((mm1-1)+1); var_314 += 1) {
									(((((((u[((unsigned int)((((2*(var_317))-(d3))-1)))]))[((unsigned int)((((2*(var_316))-(t2))-1)))]))[((unsigned int)((((2*(var_314))-(d1))-1)))])) = (((((((u[((unsigned int)((((2*(var_317))-(d3))-1)))]))[((unsigned int)((((2*(var_316))-(t2))-1)))]))[((unsigned int)((((2*(var_314))-(d1))-1)))]))+(0.5*(((((((z[((unsigned int)(((var_317)-1)))]))[((unsigned int)((var_316)))]))[((unsigned int)(((var_314)-1)))]))+((((((z[((unsigned int)(((var_317)-1)))]))[((unsigned int)(((var_316)-1)))]))[((unsigned int)(((var_314)-1)))]))))));
								};
								((i1) = ((d1)+(((int)(ceil((((double)((((mm1-1)+1)-(d1))))/((double)(1))))))*1)));
							};
							{
								for(int var_315 = 1; var_315 < ((mm1-1)+1); var_315 += 1) {
									(((((((u[((unsigned int)((((2*(var_317))-(d3))-1)))]))[((unsigned int)((((2*(var_316))-(t2))-1)))]))[((unsigned int)((((2*(var_315))-(t1))-1)))])) = (((((((u[((unsigned int)((((2*(var_317))-(d3))-1)))]))[((unsigned int)((((2*(var_316))-(t2))-1)))]))[((unsigned int)((((2*(var_315))-(t1))-1)))]))+(0.25*(((((((((z[((unsigned int)(((var_317)-1)))]))[((unsigned int)((var_316)))]))[((unsigned int)((var_315)))]))+((((((z[((unsigned int)(((var_317)-1)))]))[((unsigned int)(((var_316)-1)))]))[((unsigned int)((var_315)))])))+((((((z[((unsigned int)(((var_317)-1)))]))[((unsigned int)((var_316)))]))[((unsigned int)(((var_315)-1)))])))+((((((z[((unsigned int)(((var_317)-1)))]))[((unsigned int)(((var_316)-1)))]))[((unsigned int)(((var_315)-1)))]))))));
								};
								((i1) = (1+(((int)(ceil((((double)((((mm1-1)+1)-1)))/((double)(1))))))*1)));
							};
						};
						((i2) = (1+(((int)(ceil((((double)((((mm2-1)+1)-1)))/((double)(1))))))*1)));
					};
				};
				((i3) = ((d3)+(((int)(ceil((((double)((((mm3-1)+1)-(d3))))/((double)(1))))))*1)));
			};
			{
				for(int var_324 = 1; var_324 < ((mm3-1)+1); var_324 += 1) {
					{
						for(int var_320 = (d2); var_320 < ((mm2-1)+1); var_320 += 1) {
							{
								for(int var_318 = (d1); var_318 < ((mm1-1)+1); var_318 += 1) {
									(((((((u[((unsigned int)((((2*(var_324))-(t3))-1)))]))[((unsigned int)((((2*(var_320))-(d2))-1)))]))[((unsigned int)((((2*(var_318))-(d1))-1)))])) = (((((((u[((unsigned int)((((2*(var_324))-(t3))-1)))]))[((unsigned int)((((2*(var_320))-(d2))-1)))]))[((unsigned int)((((2*(var_318))-(d1))-1)))]))+(0.5*(((((((z[((unsigned int)((var_324)))]))[((unsigned int)(((var_320)-1)))]))[((unsigned int)(((var_318)-1)))]))+((((((z[((unsigned int)(((var_324)-1)))]))[((unsigned int)(((var_320)-1)))]))[((unsigned int)(((var_318)-1)))]))))));
								};
								((i1) = ((d1)+(((int)(ceil((((double)((((mm1-1)+1)-(d1))))/((double)(1))))))*1)));
							};
							{
								for(int var_319 = 1; var_319 < ((mm1-1)+1); var_319 += 1) {
									(((((((u[((unsigned int)((((2*(var_324))-(t3))-1)))]))[((unsigned int)((((2*(var_320))-(d2))-1)))]))[((unsigned int)((((2*(var_319))-(t1))-1)))])) = (((((((u[((unsigned int)((((2*(var_324))-(t3))-1)))]))[((unsigned int)((((2*(var_320))-(d2))-1)))]))[((unsigned int)((((2*(var_319))-(t1))-1)))]))+(0.25*(((((((((z[((unsigned int)((var_324)))]))[((unsigned int)(((var_320)-1)))]))[((unsigned int)((var_319)))]))+((((((z[((unsigned int)((var_324)))]))[((unsigned int)(((var_320)-1)))]))[((unsigned int)(((var_319)-1)))])))+((((((z[((unsigned int)(((var_324)-1)))]))[((unsigned int)(((var_320)-1)))]))[((unsigned int)((var_319)))])))+((((((z[((unsigned int)(((var_324)-1)))]))[((unsigned int)(((var_320)-1)))]))[((unsigned int)(((var_319)-1)))]))))));
								};
								((i1) = (1+(((int)(ceil((((double)((((mm1-1)+1)-1)))/((double)(1))))))*1)));
							};
						};
						((i2) = ((d2)+(((int)(ceil((((double)((((mm2-1)+1)-(d2))))/((double)(1))))))*1)));
					};
					{
						for(int var_323 = 1; var_323 < ((mm2-1)+1); var_323 += 1) {
							{
								for(int var_321 = (d1); var_321 < ((mm1-1)+1); var_321 += 1) {
									(((((((u[((unsigned int)((((2*(var_324))-(t3))-1)))]))[((unsigned int)((((2*(var_323))-(t2))-1)))]))[((unsigned int)((((2*(var_321))-(d1))-1)))])) = (((((((u[((unsigned int)((((2*(var_324))-(t3))-1)))]))[((unsigned int)((((2*(var_323))-(t2))-1)))]))[((unsigned int)((((2*(var_321))-(d1))-1)))]))+(0.25*(((((((((z[((unsigned int)((var_324)))]))[((unsigned int)((var_323)))]))[((unsigned int)(((var_321)-1)))]))+((((((z[((unsigned int)((var_324)))]))[((unsigned int)(((var_323)-1)))]))[((unsigned int)(((var_321)-1)))])))+((((((z[((unsigned int)(((var_324)-1)))]))[((unsigned int)((var_323)))]))[((unsigned int)(((var_321)-1)))])))+((((((z[((unsigned int)(((var_324)-1)))]))[((unsigned int)(((var_323)-1)))]))[((unsigned int)(((var_321)-1)))]))))));
								};
								((i1) = ((d1)+(((int)(ceil((((double)((((mm1-1)+1)-(d1))))/((double)(1))))))*1)));
							};
							{
								for(int var_322 = 1; var_322 < ((mm1-1)+1); var_322 += 1) {
									(((((((u[((unsigned int)((((2*(var_324))-(t3))-1)))]))[((unsigned int)((((2*(var_323))-(t2))-1)))]))[((unsigned int)((((2*(var_322))-(t1))-1)))])) = (((((((u[((unsigned int)((((2*(var_324))-(t3))-1)))]))[((unsigned int)((((2*(var_323))-(t2))-1)))]))[((unsigned int)((((2*(var_322))-(t1))-1)))]))+(0.125*(((((((((((((z[((unsigned int)((var_324)))]))[((unsigned int)((var_323)))]))[((unsigned int)((var_322)))]))+((((((z[((unsigned int)((var_324)))]))[((unsigned int)(((var_323)-1)))]))[((unsigned int)((var_322)))])))+((((((z[((unsigned int)((var_324)))]))[((unsigned int)((var_323)))]))[((unsigned int)(((var_322)-1)))])))+((((((z[((unsigned int)((var_324)))]))[((unsigned int)(((var_323)-1)))]))[((unsigned int)(((var_322)-1)))])))+((((((z[((unsigned int)(((var_324)-1)))]))[((unsigned int)((var_323)))]))[((unsigned int)((var_322)))])))+((((((z[((unsigned int)(((var_324)-1)))]))[((unsigned int)(((var_323)-1)))]))[((unsigned int)((var_322)))])))+((((((z[((unsigned int)(((var_324)-1)))]))[((unsigned int)((var_323)))]))[((unsigned int)(((var_322)-1)))])))+((((((z[((unsigned int)(((var_324)-1)))]))[((unsigned int)(((var_323)-1)))]))[((unsigned int)(((var_322)-1)))]))))));
								};
								((i1) = (1+(((int)(ceil((((double)((((mm1-1)+1)-1)))/((double)(1))))))*1)));
							};
						};
						((i2) = (1+(((int)(ceil((((double)((((mm2-1)+1)-1)))/((double)(1))))))*1)));
					};
				};
				((i3) = (1+(((int)(ceil((((double)((((mm3-1)+1)-1)))/((double)(1))))))*1)));
			};
		};
		{
			if(((((*((*var_291).debug_vec))[((unsigned int)(0))]))>=1)) {
				call__insieme_funType_type_15(((struct __insieme_funType_type_15*)(&((struct __insieme_funType_type_16){&rep_nrm, 0, var_291}))), z, mm1, mm2, mm3, "z: inter", (k-1));
				call__insieme_funType_type_15(((struct __insieme_funType_type_15*)(&((struct __insieme_funType_type_16){&rep_nrm, 0, var_291}))), u, n1, n2, n3, "u: inter", k);
			};
			if(((((*((*var_291).debug_vec))[((unsigned int)(5))]))>=k)) {
				showall(z, mm1, mm2, mm3);
				showall(u, n1, n2, n3);
			};
		};
	}
}


// start code fragment :: Definition of mg3P //
void mg3P(void* _capture, double**** u, double*** v, double**** r, double* a, double* c, int n1, int n2, int n3, int k) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_232 = ((struct __insieme_funType_type_18*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		int var_262 = k;
		{
			int j = 0;
			{
				for(int var_263 = (((int)(0))-(((*var_232).lt))); var_263 < ((((int)(0))-((((*var_232).lb))+1))+1); var_263 += 1) {
					((j) = ((((int)(0))-(var_263))-1));
					call__insieme_funType_type_19(((struct __insieme_funType_type_19*)(&((struct __insieme_funType_type_20){&rprj3, 0, var_232}))), ((r[((unsigned int)((((int)(0))-(var_263))))])), (((*((*var_232).m1))[((unsigned int)((((int)(0))-(var_263))))])), (((*((*var_232).m2))[((unsigned int)((((int)(0))-(var_263))))])), (((*((*var_232).m3))[((unsigned int)((((int)(0))-(var_263))))])), ((r[((unsigned int)((j)))])), (((*((*var_232).m1))[((unsigned int)((j)))])), (((*((*var_232).m2))[((unsigned int)((j)))])), (((*((*var_232).m3))[((unsigned int)((j)))])), (((int)(0))-(var_263)));
				};
				((var_262) = ((((*var_232).lt))+(((int)(ceil((((double)((((((int)(0))-((((*var_232).lb))+1))+1)-(((*var_232).lt)))))/((double)(1))))))*1)));
			};
			((var_262) = (((*var_232).lb)));
			zero3(((u[((unsigned int)((var_262)))])), (((*((*var_232).m1))[((unsigned int)((var_262)))])), (((*((*var_232).m2))[((unsigned int)((var_262)))])), (((*((*var_232).m3))[((unsigned int)((var_262)))])));
			call__insieme_funType_type_21(((struct __insieme_funType_type_21*)(&((struct __insieme_funType_type_22){&psinv, 0, var_232}))), ((r[((unsigned int)((var_262)))])), ((u[((unsigned int)((var_262)))])), (((*((*var_232).m1))[((unsigned int)((var_262)))])), (((*((*var_232).m2))[((unsigned int)((var_262)))])), (((*((*var_232).m3))[((unsigned int)((var_262)))])), c, (var_262));
			{
				for(int var_326 = ((((*var_232).lb))+1); var_326 < (((((*var_232).lt))-1)+1); var_326 += 1) {
					((j) = ((var_326)-1));
					zero3(((u[((unsigned int)((var_326)))])), (((*((*var_232).m1))[((unsigned int)((var_326)))])), (((*((*var_232).m2))[((unsigned int)((var_326)))])), (((*((*var_232).m3))[((unsigned int)((var_326)))])));
					call__insieme_funType_type_19(((struct __insieme_funType_type_19*)(&((struct __insieme_funType_type_20){&interp, 0, var_232}))), ((u[((unsigned int)((j)))])), (((*((*var_232).m1))[((unsigned int)((j)))])), (((*((*var_232).m2))[((unsigned int)((j)))])), (((*((*var_232).m3))[((unsigned int)((j)))])), ((u[((unsigned int)((var_326)))])), (((*((*var_232).m1))[((unsigned int)((var_326)))])), (((*((*var_232).m2))[((unsigned int)((var_326)))])), (((*((*var_232).m3))[((unsigned int)((var_326)))])), (var_326));
					call__insieme_funType_type_13(((struct __insieme_funType_type_13*)(&((struct __insieme_funType_type_14){&resid, 0, var_232}))), ((u[((unsigned int)((var_326)))])), ((r[((unsigned int)((var_326)))])), ((r[((unsigned int)((var_326)))])), (((*((*var_232).m1))[((unsigned int)((var_326)))])), (((*((*var_232).m2))[((unsigned int)((var_326)))])), (((*((*var_232).m3))[((unsigned int)((var_326)))])), a, (var_326));
					call__insieme_funType_type_21(((struct __insieme_funType_type_21*)(&((struct __insieme_funType_type_22){&psinv, 0, var_232}))), ((r[((unsigned int)((var_326)))])), ((u[((unsigned int)((var_326)))])), (((*((*var_232).m1))[((unsigned int)((var_326)))])), (((*((*var_232).m2))[((unsigned int)((var_326)))])), (((*((*var_232).m3))[((unsigned int)((var_326)))])), c, (var_326));
				};
				((var_262) = (((((*var_232).lb))+1)+(((int)(ceil((((double)(((((((*var_232).lt))-1)+1)-((((*var_232).lb))+1))))/((double)(1))))))*1)));
			};
			((j) = ((((*var_232).lt))-1));
			((var_262) = (((*var_232).lt)));
			call__insieme_funType_type_19(((struct __insieme_funType_type_19*)(&((struct __insieme_funType_type_20){&interp, 0, var_232}))), ((u[((unsigned int)((j)))])), (((*((*var_232).m1))[((unsigned int)((j)))])), (((*((*var_232).m2))[((unsigned int)((j)))])), (((*((*var_232).m3))[((unsigned int)((j)))])), ((u[((unsigned int)((((*var_232).lt))))])), n1, n2, n3, (var_262));
			call__insieme_funType_type_13(((struct __insieme_funType_type_13*)(&((struct __insieme_funType_type_14){&resid, 0, var_232}))), ((u[((unsigned int)((((*var_232).lt))))])), v, ((r[((unsigned int)((((*var_232).lt))))])), n1, n2, n3, a, (var_262));
			call__insieme_funType_type_21(((struct __insieme_funType_type_21*)(&((struct __insieme_funType_type_22){&psinv, 0, var_232}))), ((r[((unsigned int)((((*var_232).lt))))])), ((u[((unsigned int)((((*var_232).lt))))])), n1, n2, n3, c, (var_262));
		};
	}
}


// start code fragment :: Definition of timer_stop //
void timer_stop(void* _capture, int n) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_329 = ((struct __insieme_funType_type_2*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		double t = 0.0;
		double now = 0.0;
		((now) = call__insieme_funType_type_3(((struct __insieme_funType_type_3*)(&((struct __insieme_funType_type_4){&elapsed_time, 0, var_329})))));
		((t) = ((now)-(((*((*var_329).start))[((unsigned int)(n))]))));
		((((*((*var_329).elapsed))[((unsigned int)(n))])) = ((((*((*var_329).elapsed))[((unsigned int)(n))]))+(t)));
	}
}


// start code fragment :: Definitions for function type: __insieme_funType_type_23 //
// Abstract prototype for lambdas of type __insieme_funType_type_23
struct __insieme_funType_type_23 { 
    double(*fun)(void*,int);
    const size_t size;
};

// Type safe function for invoking lambdas of type __insieme_funType_type_23
double call__insieme_funType_type_23(struct __insieme_funType_type_23* lambda,int p1) { return lambda->fun(lambda,p1); }

// start code fragment :: Definitions for function type: __insieme_funType_type_24 //
// Abstract prototype for lambdas of type __insieme_funType_type_24
struct __insieme_funType_type_24 { 
    double(*fun)(void*,int);
    const size_t size;
    struct __insieme_globals* p0;
};

// start code fragment :: Definition of timer_read //
double timer_read(void* _capture, int n) {
	// --------- Captured Stuff - Begin -------------
	struct __insieme_globals* var_335 = ((struct __insieme_funType_type_24*)_capture)->p0;
	// --------- Captured Stuff -  End  -------------
	{
		return (((*((*var_335).elapsed))[((unsigned int)(n))]));;
	}
}


// start code fragment :: Definition of c_print_results //
void c_print_results(char* name, char class, int n1, int n2, int n3, int niter, int nthreads, double t, double mops, char* optype, int passed_verification, char* npbversion, char* compiletime, char* cc, char* clink, char* c_lib, char* c_inc, char* cflags, char* clinkflags, char* rand) {
	{
		char* evalue = "1000";
		printf("\n\n %s Benchmark Completed\n", name);
		printf(" Class           =                        %c\n", ((int)(class)));
		if(((n2==0)&&(n3==0))) {
			printf(" Size            =             %12d\n", n1);
		} else {
			printf(" Size            =              %3dx%3dx%3d\n", n1, n2, n3);
		};
		printf(" Iterations      =             %12d\n", niter);
		printf(" Threads         =             %12d\n", nthreads);
		printf(" Time in seconds =             %12.2f\n", 0.0);
		printf(" Mop/s total     =             %12.2f\n", 0.0);
		printf(" Operation type  = %24s\n", optype);
		if(((bool)(passed_verification))) {
			printf(" Verification    =               SUCCESSFUL\n", 0);
		} else {
			printf(" Verification    =             UNSUCCESSFUL\n", 0);
		};
		printf(" Version         =             %12s\n", npbversion);
		printf(" Compile date    =             %12s\n", compiletime);
		printf("\n Compile options:\n", 0);
		printf("    CC           = %s\n", cc);
		printf("    CLINK        = %s\n", clink);
		printf("    C_LIB        = %s\n", c_lib);
		printf("    C_INC        = %s\n", c_inc);
		printf("    CFLAGS       = %s\n", cflags);
		printf("    CLINKFLAGS   = %s\n", clinkflags);
		printf("    RAND         = %s\n", rand);
	}
}


// start code fragment :: Definition of main //
int main(int argc, char** argv) {
	{
		struct __insieme_globals var_1 = ((struct __insieme_globals){calloc(sizeof(int[12]), 1),
			calloc(sizeof(int[12]), 1),
			calloc(sizeof(int[12]), 1),
			'\0',
			calloc(sizeof(int[8]), 1),
			calloc(sizeof(int[12]), 1),
			calloc(sizeof(int[12]), 1),
			calloc(sizeof(int[12]), 1),
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0.0,
			calloc(sizeof(double[64]), 1),
			calloc(sizeof(double[64]), 1),
			(((int)(0))-1)
		});
		int k = 0;
		int it = 0;
		double t = 0.0;
		double tinit = 0.0;
		double mflops = 0.0;
		int nthreads = 1;
		double**** u;
		double*** v;
		double**** r;
		double a[4];
		double c[4];
		double rnm2 = 0.0;
		double rnmu = 0.0;
		double epsilon = 1.0e-8;
		int n1 = 0;
		int n2 = 0;
		int n3 = 0;
		int nit = 0;
		double verify_value = 0.0;
		int verified = 0;
		int i = 0;
		int j = 0;
		int l = 0;
		struct FILE* fp;
		call__insieme_funType_type_1(((struct __insieme_funType_type_1*)(&((struct __insieme_funType_type_2){&timer_clear, 0, &var_1}))), 1);
		call__insieme_funType_type_1(((struct __insieme_funType_type_1*)(&((struct __insieme_funType_type_2){&timer_clear, 0, &var_1}))), 2);
		call__insieme_funType_type_1(((struct __insieme_funType_type_1*)(&((struct __insieme_funType_type_2){&timer_start, 0, &var_1}))), 2);
		printf("\n\n NAS Parallel Benchmarks 2.3 OpenMP C version - MG Benchmark\n\n", 0);
		((fp) = fopen("mg.input", "r"));
		if(((bool)((fp)))) {
			printf(" Reading from input file mg.input\n", 0);
			fscanf((fp), "%d", &((var_1).lt));
			while((fgetc((fp))!='\n')) {};
			fscanf((fp), "%d%d%d", &((*((var_1).nx))[((unsigned int)((((var_1).lt))))]), &((*((var_1).ny))[((unsigned int)((((var_1).lt))))]), &((*((var_1).nz))[((unsigned int)((((var_1).lt))))]));
			while((fgetc((fp))!='\n')) {};
			fscanf((fp), "%d", &nit);
			while((fgetc((fp))!='\n')) {};
			{
				for(int var_41 = 0; var_41 < (7+1); var_41 += 1) {
					fscanf((fp), "%d", &((*((var_1).debug_vec))[((unsigned int)((var_41)))]));
				};
				((i) = (0+(((int)(ceil((((double)(((7+1)-0)))/((double)(1))))))*1)));
			};
			fclose((fp));
		} else {
			printf(" No input file. Using compiled defaults\n", 0);
			((((var_1).lt)) = 6);
			((nit) = 40);
			((((*((var_1).nx))[((unsigned int)((((var_1).lt))))])) = 64);
			((((*((var_1).ny))[((unsigned int)((((var_1).lt))))])) = 64);
			((((*((var_1).nz))[((unsigned int)((((var_1).lt))))])) = 64);
			{
				for(int var_42 = 0; var_42 < (7+1); var_42 += 1) {
					((((*((var_1).debug_vec))[((unsigned int)((var_42)))])) = 0);
				};
				((i) = (0+(((int)(ceil((((double)(((7+1)-0)))/((double)(1))))))*1)));
			};
		};
		if((((((*((var_1).nx))[((unsigned int)((((var_1).lt))))]))!=(((*((var_1).ny))[((unsigned int)((((var_1).lt))))])))||((((*((var_1).nx))[((unsigned int)((((var_1).lt))))]))!=(((*((var_1).nz))[((unsigned int)((((var_1).lt))))]))))) {
			((((var_1).Class)) = ((char)('U')));
		} else if((((((*((var_1).nx))[((unsigned int)((((var_1).lt))))]))==32)&&((nit)==4))) {
			((((var_1).Class)) = ((char)('S')));
		} else if((((((*((var_1).nx))[((unsigned int)((((var_1).lt))))]))==64)&&((nit)==40))) {
			((((var_1).Class)) = ((char)('W')));
		} else if((((((*((var_1).nx))[((unsigned int)((((var_1).lt))))]))==256)&&((nit)==20))) {
			((((var_1).Class)) = ((char)('B')));
		} else if((((((*((var_1).nx))[((unsigned int)((((var_1).lt))))]))==512)&&((nit)==20))) {
			((((var_1).Class)) = ((char)('C')));
		} else if((((((*((var_1).nx))[((unsigned int)((((var_1).lt))))]))==256)&&((nit)==4))) {
			((((var_1).Class)) = ((char)('A')));
		} else {
			((((var_1).Class)) = ((char)('U')));
		};
		(((a[((unsigned int)(0))])) = ((((double)(0))-8.0)/3.0));
		(((a[((unsigned int)(1))])) = 0.0);
		(((a[((unsigned int)(2))])) = (1.0/6.0));
		(((a[((unsigned int)(3))])) = (1.0/12.0));
		if((((((int)((((var_1).Class))))=='A')||(((int)((((var_1).Class))))=='S'))||(((int)((((var_1).Class))))=='W'))) {
			(((c[((unsigned int)(0))])) = ((((double)(0))-3.0)/8.0));
			(((c[((unsigned int)(1))])) = (1.0/32.0));
			(((c[((unsigned int)(2))])) = ((((double)(0))-1.0)/64.0));
			(((c[((unsigned int)(3))])) = 0.0);
		} else {
			(((c[((unsigned int)(0))])) = ((((double)(0))-3.0)/17.0));
			(((c[((unsigned int)(1))])) = (1.0/33.0));
			(((c[((unsigned int)(2))])) = ((((double)(0))-1.0)/61.0));
			(((c[((unsigned int)(3))])) = 0.0);
		};
		((((var_1).lb)) = 1);
		call__insieme_funType_type_7(((struct __insieme_funType_type_7*)(&((struct __insieme_funType_type_8){&setup, 0, &var_1}))), &n1, &n2, &n3, (((var_1).lt)));
		((u) = (*(malloc(sizeof(double***)*((((unsigned long)(((((var_1).lt))+1)))*sizeof(double***))/sizeof(double***))))));
		{
			for(int var_54 = (((int)(0))-(((var_1).lt))); var_54 < ((((int)(0))-1)+1); var_54 += 1) {
				((((u)[((unsigned int)((((int)(0))-(var_54))))])) = (*(malloc(sizeof(double**)*((((unsigned long)((((*((var_1).m3))[((unsigned int)((((int)(0))-(var_54))))]))))*sizeof(double**))/sizeof(double**))))));
				{
					for(int var_53 = 0; var_53 < (((*((var_1).m3))[((unsigned int)((((int)(0))-(var_54))))])); var_53 += 1) {
						((((((u)[((unsigned int)((((int)(0))-(var_54))))]))[((unsigned int)((var_53)))])) = (*(malloc(sizeof(double*)*((((unsigned long)((((*((var_1).m2))[((unsigned int)((((int)(0))-(var_54))))]))))*sizeof(double*))/sizeof(double*))))));
						{
							for(int var_52 = 0; var_52 < (((*((var_1).m2))[((unsigned int)((((int)(0))-(var_54))))])); var_52 += 1) {
								((((((((u)[((unsigned int)((((int)(0))-(var_54))))]))[((unsigned int)((var_53)))]))[((unsigned int)((var_52)))])) = (*(malloc(sizeof(double)*((((unsigned long)((((*((var_1).m1))[((unsigned int)((((int)(0))-(var_54))))]))))*sizeof(double))/sizeof(double))))));
							};
							((j) = (0+(((int)(ceil((((double)(((((*((var_1).m2))[((unsigned int)((((int)(0))-(var_54))))]))-0)))/((double)(1))))))*1)));
						};
					};
					((k) = (0+(((int)(ceil((((double)(((((*((var_1).m3))[((unsigned int)((((int)(0))-(var_54))))]))-0)))/((double)(1))))))*1)));
				};
			};
			((l) = ((((var_1).lt))+(((int)(ceil((((double)((((((int)(0))-1)+1)-(((var_1).lt)))))/((double)(1))))))*1)));
		};
		((v) = (*(malloc(sizeof(double**)*((((unsigned long)((((*((var_1).m3))[((unsigned int)((((var_1).lt))))]))))*sizeof(double**))/sizeof(double**))))));
		{
			for(int var_56 = 0; var_56 < (((*((var_1).m3))[((unsigned int)((((var_1).lt))))])); var_56 += 1) {
				((((v)[((unsigned int)((var_56)))])) = (*(malloc(sizeof(double*)*((((unsigned long)((((*((var_1).m2))[((unsigned int)((((var_1).lt))))]))))*sizeof(double*))/sizeof(double*))))));
				{
					for(int var_55 = 0; var_55 < (((*((var_1).m2))[((unsigned int)((((var_1).lt))))])); var_55 += 1) {
						((((((v)[((unsigned int)((var_56)))]))[((unsigned int)((var_55)))])) = (*(malloc(sizeof(double)*((((unsigned long)((((*((var_1).m1))[((unsigned int)((((var_1).lt))))]))))*sizeof(double))/sizeof(double))))));
					};
					((j) = (0+(((int)(ceil((((double)(((((*((var_1).m2))[((unsigned int)((((var_1).lt))))]))-0)))/((double)(1))))))*1)));
				};
			};
			((k) = (0+(((int)(ceil((((double)(((((*((var_1).m3))[((unsigned int)((((var_1).lt))))]))-0)))/((double)(1))))))*1)));
		};
		((r) = (*(malloc(sizeof(double***)*((((unsigned long)(((((var_1).lt))+1)))*sizeof(double***))/sizeof(double***))))));
		{
			for(int var_59 = (((int)(0))-(((var_1).lt))); var_59 < ((((int)(0))-1)+1); var_59 += 1) {
				((((r)[((unsigned int)((((int)(0))-(var_59))))])) = (*(malloc(sizeof(double**)*((((unsigned long)((((*((var_1).m3))[((unsigned int)((((int)(0))-(var_59))))]))))*sizeof(double**))/sizeof(double**))))));
				{
					for(int var_58 = 0; var_58 < (((*((var_1).m3))[((unsigned int)((((int)(0))-(var_59))))])); var_58 += 1) {
						((((((r)[((unsigned int)((((int)(0))-(var_59))))]))[((unsigned int)((var_58)))])) = (*(malloc(sizeof(double*)*((((unsigned long)((((*((var_1).m2))[((unsigned int)((((int)(0))-(var_59))))]))))*sizeof(double*))/sizeof(double*))))));
						{
							for(int var_57 = 0; var_57 < (((*((var_1).m2))[((unsigned int)((((int)(0))-(var_59))))])); var_57 += 1) {
								((((((((r)[((unsigned int)((((int)(0))-(var_59))))]))[((unsigned int)((var_58)))]))[((unsigned int)((var_57)))])) = (*(malloc(sizeof(double)*((((unsigned long)((((*((var_1).m1))[((unsigned int)((((int)(0))-(var_59))))]))))*sizeof(double))/sizeof(double))))));
							};
							((j) = (0+(((int)(ceil((((double)(((((*((var_1).m2))[((unsigned int)((((int)(0))-(var_59))))]))-0)))/((double)(1))))))*1)));
						};
					};
					((k) = (0+(((int)(ceil((((double)(((((*((var_1).m3))[((unsigned int)((((int)(0))-(var_59))))]))-0)))/((double)(1))))))*1)));
				};
			};
			((l) = ((((var_1).lt))+(((int)(ceil((((double)((((((int)(0))-1)+1)-(((var_1).lt)))))/((double)(1))))))*1)));
		};
		{
			zero3((((u)[((unsigned int)((((var_1).lt))))])), (n1), (n2), (n3));
		};
		call__insieme_funType_type_9(((struct __insieme_funType_type_9*)(&((struct __insieme_funType_type_10){&zran3, 0, &var_1}))), (v), (n1), (n2), (n3), (((*((var_1).nx))[((unsigned int)((((var_1).lt))))])), (((*((var_1).ny))[((unsigned int)((((var_1).lt))))])), (((var_1).lt)));
		{
			call__insieme_funType_type_11(((struct __insieme_funType_type_11*)(&((struct __insieme_funType_type_12){&norm2u3, 0, &var_1}))), (v), (n1), (n2), (n3), &rnm2, &rnmu, (((*((var_1).nx))[((unsigned int)((((var_1).lt))))])), (((*((var_1).ny))[((unsigned int)((((var_1).lt))))])), (((*((var_1).nz))[((unsigned int)((((var_1).lt))))])));
			{
				printf(" Size: %3dx%3dx%3d (class %1c)\n", (((*((var_1).nx))[((unsigned int)((((var_1).lt))))])), (((*((var_1).ny))[((unsigned int)((((var_1).lt))))])), (((*((var_1).nz))[((unsigned int)((((var_1).lt))))])), ((int)((((var_1).Class)))));
				printf(" Iterations: %3d\n", (nit));
			};
			call__insieme_funType_type_13(((struct __insieme_funType_type_13*)(&((struct __insieme_funType_type_14){&resid, 0, &var_1}))), (((u)[((unsigned int)((((var_1).lt))))])), (v), (((r)[((unsigned int)((((var_1).lt))))])), (n1), (n2), (n3), a, (((var_1).lt)));
			call__insieme_funType_type_11(((struct __insieme_funType_type_11*)(&((struct __insieme_funType_type_12){&norm2u3, 0, &var_1}))), (((r)[((unsigned int)((((var_1).lt))))])), (n1), (n2), (n3), &rnm2, &rnmu, (((*((var_1).nx))[((unsigned int)((((var_1).lt))))])), (((*((var_1).ny))[((unsigned int)((((var_1).lt))))])), (((*((var_1).nz))[((unsigned int)((((var_1).lt))))])));
			call__insieme_funType_type_17(((struct __insieme_funType_type_17*)(&((struct __insieme_funType_type_18){&mg3P, 0, &var_1}))), (u), (v), (r), a, c, (n1), (n2), (n3), (((var_1).lt)));
			call__insieme_funType_type_13(((struct __insieme_funType_type_13*)(&((struct __insieme_funType_type_14){&resid, 0, &var_1}))), (((u)[((unsigned int)((((var_1).lt))))])), (v), (((r)[((unsigned int)((((var_1).lt))))])), (n1), (n2), (n3), a, (((var_1).lt)));
			call__insieme_funType_type_7(((struct __insieme_funType_type_7*)(&((struct __insieme_funType_type_8){&setup, 0, &var_1}))), &n1, &n2, &n3, (((var_1).lt)));
			zero3((((u)[((unsigned int)((((var_1).lt))))])), (n1), (n2), (n3));
		};
		call__insieme_funType_type_9(((struct __insieme_funType_type_9*)(&((struct __insieme_funType_type_10){&zran3, 0, &var_1}))), (v), (n1), (n2), (n3), (((*((var_1).nx))[((unsigned int)((((var_1).lt))))])), (((*((var_1).ny))[((unsigned int)((((var_1).lt))))])), (((var_1).lt)));
		call__insieme_funType_type_1(((struct __insieme_funType_type_1*)(&((struct __insieme_funType_type_2){&timer_stop, 0, &var_1}))), 2);
		call__insieme_funType_type_1(((struct __insieme_funType_type_1*)(&((struct __insieme_funType_type_2){&timer_start, 0, &var_1}))), 1);
		{
			call__insieme_funType_type_13(((struct __insieme_funType_type_13*)(&((struct __insieme_funType_type_14){&resid, 0, &var_1}))), (((u)[((unsigned int)((((var_1).lt))))])), (v), (((r)[((unsigned int)((((var_1).lt))))])), (n1), (n2), (n3), a, (((var_1).lt)));
			call__insieme_funType_type_11(((struct __insieme_funType_type_11*)(&((struct __insieme_funType_type_12){&norm2u3, 0, &var_1}))), (((r)[((unsigned int)((((var_1).lt))))])), (n1), (n2), (n3), &rnm2, &rnmu, (((*((var_1).nx))[((unsigned int)((((var_1).lt))))])), (((*((var_1).ny))[((unsigned int)((((var_1).lt))))])), (((*((var_1).nz))[((unsigned int)((((var_1).lt))))])));{
				for(int var_333 = 1; var_333 < ((nit)+1); var_333 += 1) {
					call__insieme_funType_type_17(((struct __insieme_funType_type_17*)(&((struct __insieme_funType_type_18){&mg3P, 0, &var_1}))), (u), (v), (r), a, c, (n1), (n2), (n3), (((var_1).lt)));
					call__insieme_funType_type_13(((struct __insieme_funType_type_13*)(&((struct __insieme_funType_type_14){&resid, 0, &var_1}))), (((u)[((unsigned int)((((var_1).lt))))])), (v), (((r)[((unsigned int)((((var_1).lt))))])), (n1), (n2), (n3), a, (((var_1).lt)));
				};
				((it) = (1+(((int)(ceil((((double)((((nit)+1)-1)))/((double)(1))))))*1)));
			};
			call__insieme_funType_type_11(((struct __insieme_funType_type_11*)(&((struct __insieme_funType_type_12){&norm2u3, 0, &var_1}))), (((r)[((unsigned int)((((var_1).lt))))])), (n1), (n2), (n3), &rnm2, &rnmu, (((*((var_1).nx))[((unsigned int)((((var_1).lt))))])), (((*((var_1).ny))[((unsigned int)((((var_1).lt))))])), (((*((var_1).nz))[((unsigned int)((((var_1).lt))))])));
		};
		call__insieme_funType_type_1(((struct __insieme_funType_type_1*)(&((struct __insieme_funType_type_2){&timer_stop, 0, &var_1}))), 1);
		((t) = call__insieme_funType_type_23(((struct __insieme_funType_type_23*)(&((struct __insieme_funType_type_24){&timer_read, 0, &var_1}))), 1));
		((tinit) = call__insieme_funType_type_23(((struct __insieme_funType_type_23*)(&((struct __insieme_funType_type_24){&timer_read, 0, &var_1}))), 2));
		((verified) = 0);
		((verify_value) = 0.0);
		printf(" Initialization time: %15.3f seconds\n", (tinit));
		printf(" Benchmark completed\n", 0);
		if((((int)((((var_1).Class))))!='U')) {
			if((((int)((((var_1).Class))))=='S')) {
				((verify_value) = 0.530770700573e-04);
			} else if((((int)((((var_1).Class))))=='W')) {
				((verify_value) = 0.250391406439e-17);
			} else if((((int)((((var_1).Class))))=='A')) {
				((verify_value) = 0.2433365309e-5);
			} else if((((int)((((var_1).Class))))=='B')) {
				((verify_value) = 0.180056440132e-5);
			} else if((((int)((((var_1).Class))))=='C')) {
				((verify_value) = 0.570674826298e-06);
			};
			if((fabs(((rnm2)-(verify_value)))<=(epsilon))) {
				((verified) = 1);
				printf(" VERIFICATION SUCCESSFUL\n", 0);
				printf(" L2 Norm is %20.12e\n", (rnm2));
				printf(" Error is   %20.12e\n", ((rnm2)-(verify_value)));
			} else {
				((verified) = 0);
				printf(" VERIFICATION FAILED\n", 0);
				printf(" L2 Norm is             %20.12e\n", (rnm2));
				printf(" The correct L2 Norm is %20.12e\n", (verify_value));
			};
		} else {
			((verified) = 0);
			printf(" Problem size unknown\n", 0);
			printf(" NO VERIFICATION PERFORMED\n", 0);
		};
		if(((t)!=0.0)) {
			int nn = (((((*((var_1).nx))[((unsigned int)((((var_1).lt))))]))*(((*((var_1).ny))[((unsigned int)((((var_1).lt))))])))*(((*((var_1).nz))[((unsigned int)((((var_1).lt))))])));
			((mflops) = ((((58.*((double)((nit))))*((double)((nn))))*1.0e-6)/(t)));
		} else {
			((mflops) = 0.0);
		};
		c_print_results("MG", (((var_1).Class)), (((*((var_1).nx))[((unsigned int)((((var_1).lt))))])), (((*((var_1).ny))[((unsigned int)((((var_1).lt))))])), (((*((var_1).nz))[((unsigned int)((((var_1).lt))))])), (nit), (nthreads), (t), (mflops), "          floating point", (verified), "2.3", "02 Dec 2010", "cc", "cc", "-lm", "-I../common", "-O3 ", "-lm", "randdp");
	}
}

