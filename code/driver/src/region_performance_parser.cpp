/**
 * Copyright (c) 2002-2013 Distributed and Parallel Systems Group,
 *                Institute of Computer Science,
 *               University of Innsbruck, Austria
 *
 * This file is part of the INSIEME Compiler and Runtime System.
 *
 * We provide the software of this file (below described as "INSIEME")
 * under GPL Version 3.0 on an AS IS basis, and do not warrant its
 * validity or performance.  We reserve the right to update, modify,
 * or discontinue this software at any time.  We shall have no
 * obligation to supply such updates or modifications or any other
 * form of support to you.
 *
 * If you require different license terms for your intended use of the
 * software, e.g. for proprietary commercial or industrial use, please
 * contact us at:
 *                   insieme@dps.uibk.ac.at
 *
 * We kindly ask you to acknowledge the use of this software in any
 * publication or other disclosure of results by referring to the
 * following citation:
 *
 * H. Jordan, P. Thoman, J. Durillo, S. Pellegrini, P. Gschwandtner,
 * T. Fahringer, H. Moritsch. A Multi-Objective Auto-Tuning Framework
 * for Parallel Codes, in Proc. of the Intl. Conference for High
 * Performance Computing, Networking, Storage and Analysis (SC 2012),
 * IEEE Computer Society Press, Nov. 2012, Salt Lake City, USA.
 *
 * All copyright notices must be kept intact.
 *
 * INSIEME depends on several third party software packages. Please 
 * refer to http://www.dps.uibk.ac.at/insieme/license.html for details 
 * regarding third party software licenses.
 */

//#include <iostream> // cout, endl
#include <fstream>  // fstream
#include <sstream>
#include <iomanip>
#include <vector>
#include <string>
#include <iterator> // ostream_operator
#include <map>

#include <boost/tokenizer.hpp>

#include "insieme/driver/predictor/dynamic_predictor/region_performance_parser.h"

#define NO_MATCHING_END_EVENT_FOUND 2

/*
 * Parses logfiles generated by iterating through all files with the given filenamePrefix and adds entries to map
 */

int RegionPerformanceParser::parseAll(string filenamePrefix, PerformanceMap* map) {

	using namespace std;

	unsigned i = 0;
	int retval = 0;
	PerformanceMap::iterator update_it;

	// iterate through all files that match <prefix>.####
	while(true) {
		stringstream stream;
		stream << filenamePrefix << "." << setw(4) << setfill('0') << i;
		string file = stream.str();
		PerformanceMap temp_map = PerformanceMap();
	
		// actual parsing	
		retval = parseSingle(file, &temp_map);
		
		if(retval == 1)
			break; // no more files, break loop
		else if(retval == NO_MATCHING_END_EVENT_FOUND) 
			return NO_MATCHING_END_EVENT_FOUND; // error with file content, exit loop
		
		// iterate through temp map, insert new / update old entries in map
		for(PerformanceMap::iterator it = temp_map.begin(); it != temp_map.end(); ++it) {
			update_it = map->find(it->first);
			if(update_it == map->end())
				map->insert(pair<unsigned long, RegionPerformanceData>(it->first, it->second));
			else
				update_it->second.addTimespan(it->second.getTimespan(), it->second.getNumberOfAggregations());
		}
		++i;
	}
	return 0;
}

/*
 * Parses logfiles generated by the runtime to extract region performance information
 * TODO: only parses single files, needs to parse all files matching a pattern
 */

int RegionPerformanceParser::parseSingle(std::string filename, PerformanceMap* performance_map_final) {

	using std::ifstream;
	using std::multimap;
	using std::vector;
	using std::pair;

	ifstream in(filename.c_str());
	if(!in.is_open())
		return 1;

	typedef boost::tokenizer< boost::escaped_list_separator<char> > Tokenizer;
	typedef multimap<unsigned long, RegionPerformanceData> PerformanceMapRaw;

	vector<string> vec;
	string line;
	PerformanceMapRaw performance_data_raw;

	while (getline(in,line)) {
		Tokenizer tok(line);
		vec.assign(tok.begin(),tok.end());

		// only consider "RG" entries, put them into a multimap that contains start and end values for every key (=region id)
		if(vec.size() > 1 && (vec.at(0).compare("RG") == 0)) {
			performance_data_raw.insert(pair<unsigned long, RegionPerformanceData>(atol(vec.at(1).c_str()),RegionPerformanceData(atol(vec.at(3).c_str()))));
		}
	}

	unsigned long long start_key = 0, start_value = 0, end_value = 0;

	// iterate through multimap, merge every pair of values per key into a map containing a sum of all time values for each region
	for(PerformanceMapRaw::iterator it = performance_data_raw.begin(); it != performance_data_raw.end(); ++it) {
		start_key = it->first;
		start_value = it->second.getTimespan();
		++it;
		
		// no matching END event for a START event => error, incomplete tracefile
		if(it == performance_data_raw.end())
			return NO_MATCHING_END_EVENT_FOUND;

		end_value = it->second.getTimespan();

		PerformanceMap::iterator found_it = performance_map_final->find(start_key);

		// if entry is not found, insert as a new one, if entry is found, add time values
		if(found_it == performance_map_final->end()) 
			performance_map_final->insert(pair<unsigned long, RegionPerformanceData>(start_key, RegionPerformanceData(end_value - start_value)));
		else
			found_it->second.addTimespan((end_value - start_value));
	}

	//cout << "FINISHED: " << performance_map_final->size() << endl;
	//for(PerformanceMap::iterator it = performance_map_final->begin(); it != performance_map_final->end(); ++it)
	//	cout << "first: " << it->first << ", second: " << it->second.getTimespan() << ", avg: " << it->second.getAvgTimespan()<< endl;

	return 0;
}

