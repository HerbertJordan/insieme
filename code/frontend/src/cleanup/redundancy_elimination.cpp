/**
 * Copyright (c) 2002-2013 Distributed and Parallel Systems Group,
 *                Institute of Computer Science,
 *               University of Innsbruck, Austria
 *
 * This file is part of the INSIEME Compiler and Runtime System.
 *
 * We provide the software of this file (below described as "INSIEME")
 * under GPL Version 3.0 on an AS IS basis, and do not warrant its
 * validity or performance.  We reserve the right to update, modify,
 * or discontinue this software at any time.  We shall have no
 * obligation to supply such updates or modifications or any other
 * form of support to you.
 *
 * If you require different license terms for your intended use of the
 * software, e.g. for proprietary commercial or industrial use, please
 * contact us at:
 *                   insieme@dps.uibk.ac.at
 *
 * We kindly ask you to acknowledge the use of this software in any
 * publication or other disclosure of results by referring to the
 * following citation:
 *
 * H. Jordan, P. Thoman, J. Durillo, S. Pellegrini, P. Gschwandtner,
 * T. Fahringer, H. Moritsch. A Multi-Objective Auto-Tuning Framework
 * for Parallel Codes, in Proc. of the Intl. Conference for High
 * Performance Computing, Networking, Storage and Analysis (SC 2012),
 * IEEE Computer Society Press, Nov. 2012, Salt Lake City, USA.
 *
 * All copyright notices must be kept intact.
 *
 * INSIEME depends on several third party software packages. Please 
 * refer to http://www.dps.uibk.ac.at/insieme/license.html for details 
 * regarding third party software licenses.
 */

#include "insieme/frontend/cleanup/redundancy_elimination.h"

#include "insieme/analysis/defuse_collect.h"
#include "insieme/core/ir_address.h"
#include "insieme/core/ir_visitor.h"
#include "insieme/core/transform/manipulation.h"
#include "insieme/core/printer/pretty_printer.h"
#include "insieme/utils/logging.h"
#include <map>

using namespace insieme;
using namespace insieme::core;

namespace {

class SideEffectCheckVisitor : public core::IRVisitor<void, Pointer> {
	bool sideEffectFree;

	const static char* SIDE_EFFECT_FREE_C_FUNCTIONS[];

public:
	SideEffectCheckVisitor() : core::IRVisitor<void, Pointer>(false), sideEffectFree(true) {}

	bool hasSideEffects() { return !sideEffectFree; }

	void visitNode(const NodePtr& node) {
		if(sideEffectFree) {
			for_each(node.getChildList(), [&](const NodePtr arg) { this->visit(arg); });
		}
	}

	void visitCallExpr(const CallExprPtr& call);
};
const char* SideEffectCheckVisitor::SIDE_EFFECT_FREE_C_FUNCTIONS[] = {
	"cos", "sin", "tan", "acos", "asin", "atan", "atan2", "cosh", "sinh", "tanh", 
	"exp", "frexp", "ldexp", "log", "log10", "modf", "pow", "sqrt", "ceil", "fabs", "floor", "fmod" };
void SideEffectCheckVisitor::visitCallExpr(const CallExprPtr& call) {
	sideEffectFree = false;
	const core::lang::BasicGenerator& basic = call->getNodeManager().getLangBasic();
	ExpressionPtr fun = call->getFunctionExpr();
	if(basic.isPure(fun)) 
		sideEffectFree = true;
	LiteralPtr litFun = dynamic_pointer_cast<const Literal>(fun);
	if(litFun) {
		const string& name = litFun->getStringValue();
		for(unsigned i=0; i<sizeof(SIDE_EFFECT_FREE_C_FUNCTIONS)/sizeof(const char*); ++i) {
			if(name == SIDE_EFFECT_FREE_C_FUNCTIONS[i]) {
				sideEffectFree = true;
				break;
			}
		}
	}
	if(sideEffectFree) {
		// visit arguments
		for_each(call->getArguments(), [&](const ExpressionPtr arg) { this->visit(arg); });
	}
}

}

namespace insieme {
namespace frontend {
namespace cleanup {

// TODO: extend to non-scalar assignments
core::NodePtr eliminateRedundantAssignments(core::NodePtr root, core::NodeManager& mgr) {
	// remove unnecessary assignments generated by for loop translation
	vector<StatementAddress> stmtsToRemove;
	std::map<NodePtr, analysis::RefList> analysisCache;
	visitDepthFirst(NodeAddress(root), [&](const CallExprAddress& call){
		if(mgr.getLangBasic().isRefAssign(call->getFunctionExpr().getAddressedNode())) {
			//LOG(INFO) << "\n\n** Checking " << call.getAddressedNode();
			ExpressionPtr target = call->getArgument(0);
			VariablePtr targetVar = dynamic_pointer_cast<const Variable>(target);
			if(!targetVar) return;
			//LOG(INFO) << "**** Target is var";
			ExpressionPtr valueExp = call->getArgument(1);
			// check if expression is side-effect free
			SideEffectCheckVisitor secv;
			secv.visit(valueExp);
			if(secv.hasSideEffects()) return;
			//LOG(INFO) << "**** Target has no side effects";
			// check if variable is used later
			// find containing function root
			LambdaAddress fRoot;
			auto lambda = makeLambdaVisitor([&](const LambdaAddress& lambdaDef) -> bool {
				fRoot = lambdaDef;
				//LOG(INFO) << lambdaDef->getNodeType();
				return true;
			});
			visitPathBottomUpInterruptible(call, lambda);
			assert(fRoot && "Could not find enclosing lambda.");
			//LOG(INFO) << core::printer::PrettyPrinter(fRoot);
			NodePtr fRootNode = fRoot.getAddressedNode();
			analysis::RefList refs;
			if(!utils::set::contains(analysisCache, fRootNode)) 
				analysisCache.insert(std::make_pair(fRootNode, analysis::collectDefUse(fRootNode)));
			refs = analysisCache[fRootNode];
			//analysis::RefList refs = analysis::collectDefUse(fRootNode);
			bool startCheck = false;
			NodeAddress croppedCallAddress = core::cropRootNode(call, fRoot);
			for(analysis::RefList::ref_iterator<analysis::ScalarRef> it = refs.scalars_begin(); it != refs.scalars_end(); ++it) {
				analysis::RefPtr ref = *it;
				if(*ref->getBaseExpression().getAddressedNode() != *targetVar) continue;
				if(!startCheck) {
					// find def corresponding to assignment
					//LOG(INFO) << "****** pre " << ref->getBaseExpression().getAddressedNode();
					if(ref->getBaseExpression().getFirstParentOfType(NT_CallExpr) == croppedCallAddress) startCheck = true;
				} else {
					//LOG(INFO) << "****** started " << ref->getBaseExpression().getAddressedNode();
					// check if use before def after assignment
					//if(ref->getUsage() == analysis::Ref::USE || analysis::Ref::UNKNOWN) safe = false;
					//break;
					// instead, check if any use after assignment (to do the above we need control flow analysis)
					if((ref->getUsage() == analysis::Ref::USE) || (ref->getUsage() == analysis::Ref::UNKNOWN)) return;
				}
			}
			//LOG(INFO) << "**** Target is not used after assignment";
			//LOG(INFO) << "============================================\nRemovable: " << printer::PrettyPrinter(call.getAddressedNode());
			//LOG(INFO) << " in context:\n" << printer::PrettyPrinter(fRootNode);
			stmtsToRemove.push_back(call);
			
			bool hasCeil = false;
			visitDepthFirstOnce(valueExp, [&](const CallExprPtr& call) { 
				LiteralPtr litFun = dynamic_pointer_cast<const Literal>(call->getFunctionExpr());
				if(litFun && litFun->getStringValue() == "ceil") hasCeil = true;
			});
			if(!hasCeil) {
				LOG(INFO) << "** Cleanup: removable assignment *not* generated from loop: " << printer::PrettyPrinter(call.getAddressedNode());
			}
		}
	});
	if(!stmtsToRemove.empty()) root = transform::remove(mgr, stmtsToRemove);
	LOG(INFO) << "**** Cleanup: removed " << stmtsToRemove.size() << " addresses.";

	return root;
}

} // namespace cleanup
} // namespace frontend
} // namespace insieme