/**
 * Copyright (c) 2002-2013 Distributed and Parallel Systems Group,
 *                Institute of Computer Science,
 *               University of Innsbruck, Austria
 *
 * This file is part of the INSIEME Compiler and Runtime System.
 *
 * We provide the software of this file (below described as "INSIEME")
 * under GPL Version 3.0 on an AS IS basis, and do not warrant its
 * validity or performance.  We reserve the right to update, modify,
 * or discontinue this software at any time.  We shall have no
 * obligation to supply such updates or modifications or any other
 * form of support to you.
 *
 * If you require different license terms for your intended use of the
 * software, e.g. for proprietary commercial or industrial use, please
 * contact us at:
 *                   insieme@dps.uibk.ac.at
 *
 * We kindly ask you to acknowledge the use of this software in any
 * publication or other disclosure of results by referring to the
 * following citation:
 *
 * H. Jordan, P. Thoman, J. Durillo, S. Pellegrini, P. Gschwandtner,
 * T. Fahringer, H. Moritsch. A Multi-Objective Auto-Tuning Framework
 * for Parallel Codes, in Proc. of the Intl. Conference for High
 * Performance Computing, Networking, Storage and Analysis (SC 2012),
 * IEEE Computer Society Press, Nov. 2012, Salt Lake City, USA.
 *
 * All copyright notices must be kept intact.
 *
 * INSIEME depends on several third party software packages. Please 
 * refer to http://www.dps.uibk.ac.at/insieme/license.html for details 
 * regarding third party software licenses.
 */

#pragma once 

#include <cmath>
#include <algorithm>
#include <utility>
#include <type_traits>

namespace insieme {
namespace analysis {
namespace dfa {

template <class T>
struct impl_trait {
	typedef T type;
};


/**
 * Because Dataflow Analysis works on symbolic domains we define a set of classes used to store
 * symbolically some of the mathematical domains often used in dataflow analysis: powerset,
 * crossproduct 
 *
 * The main goal of these representation is to be able to test whether a value generated by a
 * transfer function of the dataflow analysis (defined by the user)still belongs to the domain on
 * which the dataflow analysis was defined for. 
 */

template <class T>
struct SymbolicSet { 

	virtual bool contains(const T& elem) const = 0;

};


template <class T, class Cont>
typename std::enable_if<std::is_base_of<SymbolicSet<T>, Cont>::value, bool>::type
contains(const Cont& cont, const T& elem) {
	return cont.contains(elem);
}

template <class T, class Cont>
typename std::enable_if<!std::is_base_of<SymbolicSet<T>, Cont>::value, bool>::type
contains(const Cont& cont, const T& elem) {
	return cont.find(elem) != cont.end();
}


/**
 * Implementation of a generic set based on existing implementations
 */
template <class T, template <typename... R> class Impl=std::set>
struct Set : public SymbolicSet<T>, public Impl<T> {

	typedef T 		value_type;
	typedef Impl<T>	impl_type;

	/** 
	 * Creates an empty set
	 */
	Set() { }

	Set(const std::initializer_list<T>& elem) : Impl<T>(elem) { }
	
	template <class IterT>
	Set(const IterT& begin, const IterT& end) : Impl<T>(begin, end) { }

	bool contains(const T& elem) const { 
		return std::find(Impl<T>::begin(), Impl<T>::end(), elem) != Impl<T>::end(); 
	}

};

template <class T>
struct impl_trait<Set<T>> {
	typedef typename Set<T>::impl_type type;
};

/**
 * Implementation of a symbolic power-set.
 *
 * In mathematics, the power set (or powerset) of any set S, written , P(S) or 2^S, is the set of
 * all subsets of S, including the empty set and S itself. In axiomatic set theory, the existence of
 * the power set of any set is postulated by the axiom of power set.
 */
template <class T, class Base=Set<T>>
class PowerSet: public SymbolicSet<typename impl_trait<Base>::type> {

	Base base;
public:

	typedef typename impl_trait<Base>::type value_type;
	
	/** 
	 * Creates an empty power-set
	 */
	PowerSet() { }

	PowerSet(const Base& base_set) : base(base_set) { }

	PowerSet(const std::initializer_list<T>& elem) : base(elem) { }

	size_t size() const { return pow(2,base.size()); }
	
	bool contains(const value_type& elem) const { 
		return all(elem.begin(), elem.end(), [&](const T& elem) { return dfa::contains(base,elem); });
	}

};

template <class T, class Base>
struct impl_trait<PowerSet<T,Base>> {
	typedef typename PowerSet<T, Base>::impl_type type;
};

template <class Base> 
PowerSet<typename Base::value_type, Base>  makePowerSet(const Base& set) { 
	return PowerSet<typename Base::value_type, Base>(set); 
}

/**
 * Cartesian-Product of 2 sets 
 */
template <class T1, class T2, class Base1=Set<T1>, class Base2=Set<T2>>
class ProdSet : public SymbolicSet< std::tuple<typename Base1::value_type, typename Base2::value_type> > {

	Base1 base1;
	Base2 base2;

public:

	typedef std::tuple<typename Base1::value_type, typename Base2::value_type> 		value_type;
	typedef std::set<value_type> impl_type;

	/** 
	 * Creates an empty cartesian-product
	 */
	ProdSet() { }

	ProdSet(const Base1& b1, const Base2& b2) : base1(b1), base2(b2) { }

	ProdSet(const std::initializer_list<T1>& b1, 
			const std::initializer_list<T2>& b2) : base1(b1), base2(b2) { }

	bool contains(const value_type& elem) const {
		return dfa::contains(base1, std::get<0>(elem)) && 
			   dfa::contains(base2, std::get<1>(elem));
	}

	size_t size() const {
		return base1.size() * base2.size();
	}

};

template <class T1, class T2, class Base1, class Base2>
struct impl_trait<ProdSet<T1,T2,Base1,Base2>> {
	typedef typename ProdSet<T1,T2,Base1,Base2>::impl_type type;
};

namespace {

// Function utilized to split a tuple into 2 tuples 

template <size_t B, class SRC, class DEST> 
class CopyHead ;

template <size_t E, class... T1, class... T2> 
struct CopyHead<E,std::tuple<T1...>,std::tuple<T2...>> {
	
	static void copy(const std::tuple<T1...,T2...>& src, std::tuple<T1...>& res) {
		std::get<E>(res) = std::get<E>(src);
		CopyHead<E-1,std::tuple<T1...>, std::tuple<T2...>>::copy(src, res);
	}

};

template <class... T1, class... T2> 
struct CopyHead<0,std::tuple<T1...>,std::tuple<T2...>> {
	
	static void copy(const std::tuple<T1...,T2...>& src, std::tuple<T1...>& res) {
		std::get<0>(res) = std::get<0>(src);
	}
	
};

template <size_t B, class SRC, class DEST> 
class CopyTail ;

template <size_t E, class... T1, class... T2> 
struct CopyTail<E,std::tuple<T1...>,std::tuple<T2...>> {
	
	static void copy(const std::tuple<T1...,T2...>& src, std::tuple<T2...>& res) {
		std::get<E>(res) = std::get<E+sizeof...(T1)>(src);
		CopyTail<E-1,std::tuple<T1...>, std::tuple<T2...>>::copy(src, res);
	}


};

template <class... T1, class... T2> 
struct CopyTail<0,std::tuple<T1...>,std::tuple<T2...>> {
	
	static void copy(const std::tuple<T1...,T2...>& src, std::tuple<T2...>& res) {
		std::get<0>(res) = std::get<sizeof...(T1)>(src);
	}

};

template <class T1, class T2, class T3>
std::pair<T1,T2> split(const T3& t) {

	T1 t1;
	T2 t2;

	CopyHead<std::tuple_size<T1>::value-1, T1, T2>::copy(t, t1);
	CopyTail<std::tuple_size<T2>::value-1, T1, T2>::copy(t, t2);

	return std::make_pair(t1, t2);
}

} // end anonymous namespace 


template <class... T1, class... T2, class Base1, class Base2>
class ProdSet<std::tuple<T1...>, std::tuple<T2...>, Base1, Base2> :
	public SymbolicSet< std::tuple<T1...,T2...> > 
{

	Base1 base1;
	Base2 base2;

public:

	typedef std::tuple<T1...,T2...> 	value_type;

	/** 
	 * Creates an empty cartesian-product
	 */
	ProdSet() { }

	ProdSet(const Base1& b1, const Base2& b2) : base1(b1), base2(b2) { }

	bool contains(const value_type& elem) const {
		std::tuple<T1...> t1;
		std::tuple<T2...> t2;
		std::tie(t1, t2) = split<std::tuple<T1...>,std::tuple<T2...>>(elem);

		return dfa::contains(base1, t1) && dfa::contains(base2, t2);
	}

	size_t size() const {
		return base1.size() * base2.size();
	}

};

template <class Base1, class Base2> 
ProdSet<typename Base1::value_type, typename Base2::value_type, Base1, Base2> 
makeProdSet(const Base1& set1, const Base2& set2) { 
	return ProdSet<typename Base1::value_type, typename Base2::value_type, Base1, Base2>(set1, set2); 
}


} // end dfa namespace 
} // end analysis namespace 
} // end insieme namespace 
