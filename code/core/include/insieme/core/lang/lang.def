/**
 * Copyright (c) 2002-2013 Distributed and Parallel Systems Group,
 *                Institute of Computer Science,
 *               University of Innsbruck, Austria
 *
 * This file is part of the INSIEME Compiler and Runtime System.
 *
 * We provide the software of this file (below described as "INSIEME")
 * under GPL Version 3.0 on an AS IS basis, and do not warrant its
 * validity or performance.  We reserve the right to update, modify,
 * or discontinue this software at any time.  We shall have no
 * obligation to supply such updates or modifications or any other
 * form of support to you.
 *
 * If you require different license terms for your intended use of the
 * software, e.g. for proprietary commercial or industrial use, please
 * contact us at:
 *                   insieme@dps.uibk.ac.at
 *
 * We kindly ask you to acknowledge the use of this software in any
 * publication or other disclosure of results by referring to the
 * following citation:
 *
 * H. Jordan, P. Thoman, J. Durillo, S. Pellegrini, P. Gschwandtner,
 * T. Fahringer, H. Moritsch. A Multi-Objective Auto-Tuning Framework
 * for Parallel Codes, in Proc. of the Intl. Conference for High
 * Performance Computing, Networking, Storage and Analysis (SC 2012),
 * IEEE Computer Society Press, Nov. 2012, Salt Lake City, USA.
 *
 * All copyright notices must be kept intact.
 *
 * INSIEME depends on several third party software packages. Please 
 * refer to http://www.dps.uibk.ac.at/insieme/license.html for details 
 * regarding third party software licenses.
 */

#ifndef TYPE
#define TYPE(_id, _spec)
#endif
#ifndef LITERAL
#define LITERAL(_id, _name, _spec)
#endif
#ifndef GROUP
#define GROUP(_id, ...)
#endif
#ifndef OPERATOR
#define OPERATOR(_id, _str)
#endif
#ifndef OPERATION
#define OPERATION(_type, _op, _name, _spec)
#endif
#ifndef SUB_TYPE
#define SUB_TYPE(_subtype, _supertype)
#endif


// Types --------------------------------------------------------------------------------------------------------------
TYPE(Unit,   "unit")

TYPE(Char,   "char")
TYPE(WChar,  "wchar")
TYPE(String, "string")
TYPE(Identifier, "identifier")

GROUP(UnsignedInt, UInt1, UInt2, UInt4, UInt8, UInt16, UIntInf, UIntGen)
GROUP(SignedInt, Int1, Int2, Int4, Int8, Int16, IntInf, IntGen)
GROUP(Int, UnsignedInt, SignedInt)

TYPE(IntGen, "int<#a>")
TYPE(UIntGen,"uint<#a>")

TYPE(Int1,    "int<1>")
TYPE(UInt1,   "uint<1>")
TYPE(Int2,    "int<2>")
TYPE(UInt2,   "uint<2>")
TYPE(Int4,    "int<4>")
TYPE(UInt4,   "uint<4>")
TYPE(Int8,    "int<8>")
TYPE(UInt8,   "uint<8>")
TYPE(Int16,   "int<16>")
TYPE(UInt16,  "uint<16>")
TYPE(IntInf,  "int<#inf>")
TYPE(UIntInf, "uint<#inf>")

SUB_TYPE(Int1, Int2)
SUB_TYPE(Int2, Int4)
SUB_TYPE(Int4, Int8)
SUB_TYPE(Int8, IntInf)

SUB_TYPE(UInt1, UInt2)
SUB_TYPE(UInt2, UInt4)
SUB_TYPE(UInt4, UInt8)
SUB_TYPE(UInt8, UIntInf)

SUB_TYPE(UInt1, Int2)
SUB_TYPE(UInt2, Int4)
SUB_TYPE(UInt4, Int8)

SUB_TYPE(UIntInf, IntInf)

GROUP(Real, RealGen, RealInf, Float, Double)

TYPE(RealGen, "real<#a>")
TYPE(RealInf, "real<#inf>")
TYPE(Float,   "real<4>")
TYPE(Double,  "real<8>")

SUB_TYPE(Float, Double)
SUB_TYPE(Double, RealInf)

GROUP(ScalarType, Int, Real)

GROUP(BoolLiteral, True, False)

TYPE(Bool, "bool")
LITERAL(True,  "true",  "bool")
LITERAL(False, "false", "bool")

TYPE(Alpha, "'a")
TYPE(RefAlpha, "ref<'a>")
TYPE(NullPtr, "ref<array<'a,1>>")

LITERAL(Null, "null", "ref<array<'a,1>>")
TYPE(VarList, "var_list")

// Parallel Types -----------------------------------------------------------------------------------------------------

TYPE(Job, "job")
TYPE(ThreadGroup, "threadgroup")

// The Unit Type Constant ---------------------------------------------------------------------------------------------

LITERAL(UnitConstant, "unit", "unit")

// No Argument -> Unit Type -------------------------------------------------------------------------------------------

TYPE(NoArgsOpType, "() -> unit")

// Operators ----------------------------------------------------------------------------------------------------------

// binary
OPERATOR(Add, 	 "+")
OPERATOR(Sub,	 "-")
OPERATOR(Mul, 	 "*")
OPERATOR(Div, 	 "/")
OPERATOR(Mod, 	 "%")
OPERATOR(And, 	 "&")
OPERATOR(Or, 	 "|")
OPERATOR(Xor, 	 "^")
OPERATOR(LShift, "<<")
OPERATOR(RShift, ">>")

// unary
OPERATOR(Not,	"~")
OPERATOR(Plus,	"+")
OPERATOR(Minus,	"-")

OPERATOR(PreInc,  "++")
OPERATOR(PostInc, "++")
OPERATOR(PreDec,  "--")
OPERATOR(PostDec, "--")

// logical
OPERATOR(LAnd, 	"&&")
OPERATOR(LOr, 	"||")
OPERATOR(LNot, 	"!")
OPERATOR(Eq, 	"==")
OPERATOR(Ne,	"!=")
OPERATOR(Lt, 	"<")
OPERATOR(Le,	"<=")
OPERATOR(Gt, 	">")
OPERATOR(Ge,	">=")

// Logical Operations -------------------------------------------------------------------------------------------------

GROUP(LogicOp, BoolLAnd, BoolLOr, BoolEq, BoolNe, BoolLNot)

OPERATION(Bool, LAnd, "bool.and", "(bool,() -> bool) -> bool")
OPERATION(Bool, LOr,  "bool.or",  "(bool,() -> bool) -> bool")
OPERATION(Bool, Eq,   "bool.eq",  "(bool,bool) -> bool")
OPERATION(Bool, Ne,   "bool.ne",  "(bool,bool) -> bool")
OPERATION(Bool, LNot, "bool.not", "(bool) -> bool")

// Arithmetic operations ----------------------------------------------------------------------------------------------

GROUP(IntArithOp, SignedIntAdd, SignedIntSub, SignedIntMul, SignedIntDiv, SignedIntMod, SignedIntPreInc,
        SignedIntPreInc, SignedIntPostInc, SignedIntPreDec, SignedIntPostDec)

OPERATION(SignedInt, Add,  "int.add", "(int<#a>,int<#a>) -> int<#a>")
OPERATION(SignedInt, Sub,  "int.sub", "(int<#a>,int<#a>) -> int<#a>")
OPERATION(SignedInt, Mul,  "int.mul", "(int<#a>,int<#a>) -> int<#a>")
OPERATION(SignedInt, Div,  "int.div", "(int<#a>,int<#a>) -> int<#a>")
OPERATION(SignedInt, Mod,  "int.mod", "(int<#a>,int<#a>) -> int<#a>")

OPERATION(SignedInt, PreInc,  "int.preInc",  "(ref<int<#a>>) -> int<#a>")
OPERATION(SignedInt, PostInc, "int.postInc", "(ref<int<#a>>) -> int<#a>")
OPERATION(SignedInt, PreDec,  "int.preDec",  "(ref<int<#a>>) -> int<#a>")
OPERATION(SignedInt, PostDec, "int.postDec", "(ref<int<#a>>) -> int<#a>")

GROUP(UIntArithOp, UnsignedIntAdd, UnsignedIntSub, UnsignedIntMul, UnsignedIntDiv, UnsignedIntMod,
        UnsignedIntPreInc, UnsignedIntPostInc, UnsignedIntPreDec, UnsignedIntPostDec)

OPERATION(UnsignedInt, Add,  "uint.add", "(uint<#a>,uint<#a>) -> uint<#a>")
OPERATION(UnsignedInt, Sub,  "uint.sub", "(uint<#a>,uint<#a>) -> uint<#a>")
OPERATION(UnsignedInt, Mul,  "uint.mul", "(uint<#a>,uint<#a>) -> uint<#a>")
OPERATION(UnsignedInt, Div,  "uint.div", "(uint<#a>,uint<#a>) -> uint<#a>")
OPERATION(UnsignedInt, Mod,  "uint.mod", "(uint<#a>,uint<#a>) -> uint<#a>")

OPERATION(UnsignedInt, PreInc,  "uint.preInc",  "(ref<uint<#a>>) -> uint<#a>")
OPERATION(UnsignedInt, PostInc, "uint.postInc", "(ref<uint<#a>>) -> uint<#a>")
OPERATION(UnsignedInt, PreDec,  "uint.preDec",  "(ref<uint<#a>>) -> uint<#a>")
OPERATION(UnsignedInt, PostDec, "uint.postDec", "(ref<uint<#a>>) -> uint<#a>")


GROUP(RealArithOp, RealAdd, RealSub, RealMul, RealDiv)

OPERATION(Real, Add,  "real.add", "(real<#a>,real<#a>) -> real<#a>")
OPERATION(Real, Sub,  "real.sub", "(real<#a>,real<#a>) -> real<#a>")
OPERATION(Real, Mul,  "real.mul", "(real<#a>,real<#a>) -> real<#a>")
OPERATION(Real, Div,  "real.div", "(real<#a>,real<#a>) -> real<#a>")

GROUP(ArithOp, IntArithOp, UIntArithOp, RealArithOp)

// Comparison Operations ----------------------------------------------------------------------------------------------

GROUP(CharCompOp, CharEq, CharNe, CharLt, CharGt, CharLe, CharGe)

OPERATION(Char, Eq, "char.eq", "(char,char) -> bool")
OPERATION(Char, Ne, "char.ne", "(char,char) -> bool")
OPERATION(Char, Lt, "char.lt", "(char,char) -> bool")
OPERATION(Char, Gt, "char.gt", "(char,char) -> bool")
OPERATION(Char, Le, "char.le", "(char,char) -> bool")
OPERATION(Char, Ge, "char.ge", "(char,char) -> bool")

GROUP(IntCompOp, SignedIntEq, SignedIntNe, SignedIntLt, SignedIntGt, SignedIntLe, SignedIntGe)

OPERATION(SignedInt, Eq, "int.eq", "(int<#a>,int<#a>) -> bool")
OPERATION(SignedInt, Ne, "int.ne", "(int<#a>,int<#a>) -> bool")
OPERATION(SignedInt, Lt, "int.lt", "(int<#a>,int<#a>) -> bool")
OPERATION(SignedInt, Gt, "int.gt", "(int<#a>,int<#a>) -> bool")
OPERATION(SignedInt, Le, "int.le", "(int<#a>,int<#a>) -> bool")
OPERATION(SignedInt, Ge, "int.ge", "(int<#a>,int<#a>) -> bool")

GROUP(UIntCompOp, UnsignedIntEq, UnsignedIntNe, UnsignedIntLt, UnsignedIntGt, UnsignedIntLe, UnsignedIntGe)

OPERATION(UnsignedInt, Eq, "uint.eq", "(uint<#a>,uint<#a>) -> bool")
OPERATION(UnsignedInt, Ne, "uint.ne", "(uint<#a>,uint<#a>) -> bool")
OPERATION(UnsignedInt, Lt, "uint.lt", "(uint<#a>,uint<#a>) -> bool")
OPERATION(UnsignedInt, Gt, "uint.gt", "(uint<#a>,uint<#a>) -> bool")
OPERATION(UnsignedInt, Le, "uint.le", "(uint<#a>,uint<#a>) -> bool")
OPERATION(UnsignedInt, Ge, "uint.ge", "(uint<#a>,uint<#a>) -> bool")

GROUP(RealCompOp, RealEq, RealNe, RealLt, RealGt, RealLe, RealGe)

OPERATION(Real, Eq, "real.eq", "(real<#a>,real<#a>) -> bool")
OPERATION(Real, Ne, "real.ne", "(real<#a>,real<#a>) -> bool")
OPERATION(Real, Lt, "real.lt", "(real<#a>,real<#a>) -> bool")
OPERATION(Real, Gt, "real.gt", "(real<#a>,real<#a>) -> bool")
OPERATION(Real, Le, "real.le", "(real<#a>,real<#a>) -> bool")
OPERATION(Real, Ge, "real.ge", "(real<#a>,real<#a>) -> bool")

GROUP(CompOp, IntCompOp, UIntCompOp, RealCompOp)

// Bitwise Operations -------------------------------------------------------------------------------------------------

GROUP(BitwiseIntOp, SignedIntNot, SignedIntAnd, SignedIntOr, SignedIntXor, SignedIntLShift, SignedIntRShift)

OPERATION(SignedInt, Not,    "int.not",    "(int<#a>) -> int<#a>")
OPERATION(SignedInt, And,    "int.and",    "(int<#a>,int<#a>) -> int<#a>")
OPERATION(SignedInt, Or,     "int.or",     "(int<#a>,int<#a>) -> int<#a>")
OPERATION(SignedInt, Xor,    "int.xor",    "(int<#a>,int<#a>) -> int<#a>")
OPERATION(SignedInt, LShift, "int.lshift", "(int<#a>,int<#a>) -> int<#a>")
OPERATION(SignedInt, RShift, "int.rshift", "(int<#a>,int<#a>) -> int<#a>")

GROUP(BitwiseUIntOp, UnsignedIntNot, UnsignedIntAnd, UnsignedIntOr, UnsignedIntXor, UnsignedIntLShift, UnsignedIntRShift)

OPERATION(UnsignedInt, Not,    "uint.not",    "(uint<#a>) -> uint<#a>")
OPERATION(UnsignedInt, And,    "uint.and",    "(uint<#a>,uint<#a>) -> uint<#a>")
OPERATION(UnsignedInt, Or,     "uint.or",     "(uint<#a>,uint<#a>) -> uint<#a>")
OPERATION(UnsignedInt, Xor,    "uint.xor",    "(uint<#a>,uint<#a>) -> uint<#a>")
OPERATION(UnsignedInt, LShift, "uint.lshift", "(uint<#a>,int<#a>) -> uint<#a>")
OPERATION(UnsignedInt, RShift, "uint.rshift", "(uint<#a>,int<#a>) -> uint<#a>")

GROUP(BitwiseOp, BitwiseIntOp, BitwiseUIntOp)

// References ---------------------------------------------------------------------------------------------------------

GROUP(RefOp, RefVar, RefNew, RefDelete, RefAssign, RefDeref)

LITERAL(RefVar,    "ref.var",    			"('a) -> ref<'a>")
LITERAL(RefNew,    "ref.new",    			"('a) -> ref<'a>")
LITERAL(RefDelete, "ref.delete", 			"(ref<'a>) -> unit")
LITERAL(RefAssign, "ref.assign", 			"(ref<'a>,'a) -> unit")
LITERAL(RefDeref,  "ref.deref",  			"(ref<'a>) -> 'a")
LITERAL(ScalarToArray, "scalar.to.array", "(ref<'a>) -> ref<array<'a,1>>")

// General ------------------------------------------------------------------------------------------------------------

LITERAL(Undefined, "undefined", "(type<'a>) -> 'a")
LITERAL(InitZero, "initZero", "(type<'a>) -> 'a")
LITERAL(Sizeof, "sizeof", "(type<'a>) -> uint<8>")
LITERAL(IntTypeParamToInt, "int.type.param.to.int", "(intTypeParam<#n>)->int<8>")

// Arrays -------------------------------------------------------------------------------------------------------------

GROUP(ArrayOp, ArrayCreate1D, ArrayCreateND, ArrayLength1D, ArrayLengthND, ArraySubscript1D, ArraySubscriptND)

LITERAL(ArrayCreate1D, "array.create.1D", "('elem, uint<8>) -> array<'elem,1>")
LITERAL(ArrayCreateND, "array.create.ND", "('elem, vector<uint<8>,#n>) -> array<'elem,#n>")

LITERAL(ArrayLength1D, "array.length.1D", "(array<'elem,1>) -> uint<8>")
LITERAL(ArrayLengthND, "array.length.ND", "(array<'elem,#n>) -> vector<uint<8>,#n>")

LITERAL(ArraySubscript1D, "array.subscript.1D", "(array<'elem,1>, uint<8>) -> 'elem")
LITERAL(ArraySubscriptND, "array.subscript.ND", "(array<'elem,#n>, vector<uint<8>,#n>) -> 'elem")

LITERAL(ArrayRefElem1D, "array.ref.elem.1D", "(ref<array<'elem,1>>, uint<8>) -> ref<'elem>")
LITERAL(ArrayRefElemND, "array.ref.elem.ND", "(ref<array<'elem,#n>>, vector<uint<8>,#n>) -> ref<'elem>")

LITERAL(ArrayProjection1D, "array.projection.1D", "(array<'elem,1>,uint<8>,uint<8>) -> array<'elem,1>")
LITERAL(ArrayProjectionND, "array.projection.ND",
						   "(array<'elem,#n>,vector<uint<8>,#n>,vector<uint<8>,#n>) -> ref<array<'elem,#n>>")

LITERAL(ArrayRefProjection1D, "array.ref.projection.1D",
							  "(ref<array<'elem,1>>,uint<8>,uint<8>) -> ref<array<'elem,1>>")

LITERAL(ArrayRefProjectionND, "array.ref.projection.ND",
							  "(ref<array<'elem,#n>>,vector<uint<8>,#n>,vector<uint<8>,#n>) -> ref<array<'elem,#n>>")

// function to copy an array 1D of type t and size m to an 1D array of type ref<vector<t,n> and size m/n
LITERAL(ArrayElemToVec, "array.elem.to.vec",
						"(array<ref<'elem>,1>, intTypeParam<#n>) -> array<ref<vector<'elem,#n>>,1>")

// Vectors ------------------------------------------------------------------------------------------------------------

GROUP(VectorOp, VectorSubscript, VectorInitUniform, VectorInitUndefined, VectorPointwise, VectorReduction)

// deprecated
LITERAL(VectorSubscript,      "vector.subscript",       "(vector<'elem,#l>, uint<#a>) -> 'elem")
LITERAL(VectorInitUniform,    "vector.init.uniform",    "('elem, intTypeParam<#a>) -> vector<'elem,#a>")
LITERAL(VectorInitUndefined,  "vector.init.undefined",  "(intTypeParam<#a>) -> vector<'elem,#a>")
LITERAL(VectorPointwise,      "vector.pointwise",
							  "(('elem, 'elem) -> 'res) -> (vector<'elem,#l>, vector<'elem,#l>) -> vector<'res, #l>")
LITERAL(VectorPointwiseUnary, "vector.pointwise.unary", "(('elem) -> 'res) -> (vector<'elem,#l>) -> vector<'res, #l>")
LITERAL(VectorReduction,      "vector.reduction",       "(vector<'elem,#l>, 'res, ('elem, 'res) -> 'res) -> 'res")
LITERAL(VectorPermute,        "vector.permute",         "(vector<'elem,#l>, vector<uint<#a>,#m>) -> vector<'elem,#m>")

LITERAL(VectorProjection, "vector.projection",
						  "(vector<'elem,#n>,intTypeParam<#s>,intTypeParam<#m>) -> vector<'elem,#m>")
LITERAL(VectorRefProjection, "vector.ref.projection",
							 "(ref<vector<'elem,#n>>,intTypeParam<#s>,intTypeParam<#m>) -> ref<vector<'elem,#m>>")


LITERAL(Vector2Array, 		"vector.to.array",				"(vector<'elem,#l>) -> array<'elem,1>")
LITERAL(RefVector2RefArray, "ref.vector.to.ref.array",		"(ref<vector<'elem,#l>>) -> ref<array<'elem,1>>")
							 
// Arrays and Vectors -------------------------------------------------------------------------------------------------

GROUP(SubscriptOperator, ArraySubscript1D, ArraySubscriptND, VectorSubscript, ArrayRefElem1D, ArrayRefElemND)

// Struct and Unions --------------------------------------------------------------------------------------------------
// first argument has to be a struct or a union, 'b has to be the type of the requested member
LITERAL(CompositeRefElem,      "composite.ref.elem",      "(ref<'a>, identifier, type<'b>) -> ref<'b>")
LITERAL(CompositeMemberAccess, "composite.member.access", "('a, identifier, type<'b>) -> 'b")

// Tuple --------------------------------------------------------------------------------------------------------------
// first argument has to be a tuple or a union, 'b has to be the type of the requested member
LITERAL(TupleRefElem,      "tuple.ref.elem",      "(ref<'a>, uint<8>, type<'b>) -> ref<'b>")
LITERAL(TupleMemberAccess, "tuple.member.access", "('a, uint<8>, type<'b>) -> 'b")


// Strings ------------------------------------------------------------------------------------------------------------

LITERAL(StringToCharPointer, "string.as.char.pointer", "(string) -> ref<array<char,1>>")


// Accuracy defining functions

LITERAL(AccuracyHighBinary,       "accuracy.high", "(('a, 'a)->'b) -> ('a, 'a)->'b")
LITERAL(AccuracyBestEffortBinary, "accuracy.besteffort", "(('a, 'a)->'b) -> ('a, 'a)->'b")
LITERAL(AccuracyFastBinary,       "accuracy.fast", "(('a, 'a)->'b) -> ('a, 'a)->'b")
LITERAL(AccuracyHighUnary,       "accuracy.high.unary", "(('a)->'b) -> ('a)->'b")
LITERAL(AccuracyBestEffortUnary, "accuracy.besteffort.unary", "(('a)->'b) -> ('a)->'b")
LITERAL(AccuracyFastUnary,       "accuracy.fast.unary", "(('a)->'b) -> ('a)->'b")

// Misc. --------------------------------------------------------------------------------------------------------------

LITERAL(VarlistPack, "varlist.pack", "('alpha) -> var_list")
LITERAL(IfThenElse, "ite", "(bool, () -> 'b, () -> 'b) -> 'b")

// Parallel Constructs ------------------------------------------------------------------------------------------------

GROUP(ParallelOp, Parallel, ParallelDetached)

LITERAL(Parallel, "parallel", "(job) -> threadgroup")
LITERAL(ParallelDetached, "parallel&", "(job) -> unit")

GROUP(MergeOp, Merge, MergeAll)

LITERAL(Merge, "merge", "(threadgroup) -> unit")
LITERAL(MergeAll, "mergeAll", "() -> unit")


GROUP(ThreadOp, GetThreadGroup, GetThreadId)

LITERAL(GetThreadGroup, "getThreadGroup", "(uint<#a>) -> threadgroup")
LITERAL(GetThreadId, "getThreadID", "(uint<#a>) -> uint<4>")
LITERAL(GetGroupSize, "getGroupSize", "(uint<#a>) -> uint<4>")

LITERAL(Barrier, "barrier", "(threadgroup) -> unit")
LITERAL(PFor, "pfor", "(threadgroup, int<#a>, int<#a>, int<#a>, (int<#a>)->'a)->unit")

//TYPE(reduce, "reduce", "(threadgroup, ('a -> 'a), ) -> unit") // wtf?
// redistribute
// TODO herbert


// Range Handling -----------------------------------------------------------------------------------------------------

TYPE(JobRange, "JobRange")

LITERAL(CreateMinRange,     "MinRange",    "(uint<#8>)->JobRange")					// lower boundery only
LITERAL(CreateBoundRange,   "BoundRange",    "(uint<#8>, uint<#8>)->JobRange")		// lower and upper bound


// --------------------------------------------------------------------------------------------------------------------

#undef TYPE
#undef LITERAL
#undef GROUP
#undef OPERATOR
#undef OPERATION
#undef SUB_TYPE
