
#include "insieme/core/int_type_param.h"

#include "insieme/utils/hash_utils.h"
#include "insieme/utils/container_utils.h"

namespace insieme {
namespace core {


	// ----------------------- Variable Integer Type Parameter ------------------------

	namespace {
		inline std::size_t hashVariableParam(char symbol) {
			size_t seed = 0;
			boost::hash_combine(seed, HS_VariableIntTypeParam);
			boost::hash_combine(seed, symbol);
			return seed;
		}
	}

	VariableIntTypeParam::VariableIntTypeParam(char symbol)
		: IntTypeParam(NT_VariableIntTypeParam, hashVariableParam(symbol)), symbol(symbol) {}

	VariableIntTypeParamPtr VariableIntTypeParam::get(NodeManager& manager, char symbol) {
		return manager.get(VariableIntTypeParam(symbol));
	}

	bool VariableIntTypeParam::equals(const Node& other) const {
		if (this == &other) {
			return true;
		}

		if (other.getNodeType() != NT_VariableIntTypeParam) {
			return false;
		}

		return symbol == static_cast<const VariableIntTypeParam&>(other).symbol;
	}

	bool VariableIntTypeParam::operator<(const IntTypeParam& other) const {
		// variable int type parameters are smaller than all other parameters
		if (other.getNodeType() != NT_VariableIntTypeParam) {
			return false;
		}

		// compare the symbol
		return symbol < static_cast<const VariableIntTypeParam&>(other).symbol;
	}


	// ----------------------- Concrete Integer Type Parameter ------------------------

	namespace {
		inline std::size_t hashConcreteParam(std::size_t value) {
			size_t seed = 0;
			boost::hash_combine(seed, HS_ConcreteIntTypeParam);
			boost::hash_combine(seed, value);
			return seed;
		}
	}

	ConcreteIntTypeParam::ConcreteIntTypeParam(std::size_t value)
		: IntTypeParam(NT_ConcreteIntTypeParam, hashConcreteParam(value)), value(value) {}

	ConcreteIntTypeParamPtr ConcreteIntTypeParam::get(NodeManager& manager, std::size_t value) {
		return manager.get(ConcreteIntTypeParam(value));
	}

	bool ConcreteIntTypeParam::equals(const Node& other) const {
		if (this == &other) {
			return true;
		}

		if (other.getNodeType() != NT_ConcreteIntTypeParam) {
			return false;
		}

		return value == static_cast<const ConcreteIntTypeParam&>(other).value;
	}

	bool ConcreteIntTypeParam::operator<(const IntTypeParam& other) const {
		// variable int type parameters are smaller than all other parameters
		if (other.getNodeType() != NT_ConcreteIntTypeParam) {
			if (other.getNodeType() == NT_InfiniteIntTypeParam) {
				// it is smaller than an infinite int type param ...
				return true;
			}

			// compare based on parameters type
			return getNodeType() < other.getNodeType();
		}

		// compare the symbol
		return value < static_cast<const ConcreteIntTypeParam&>(other).value;
	}


	// ----------------------- Infinite Integer Type Parameter ------------------------

	namespace {
		inline std::size_t hashInfiniteParam() {
			size_t seed = 0;
			boost::hash_combine(seed, HS_InfiniteIntTypeParam);
			return seed;
		}
	}

	InfiniteIntTypeParam::InfiniteIntTypeParam()
		: IntTypeParam(NT_InfiniteIntTypeParam, hashInfiniteParam()) {}

	InfiniteIntTypeParamPtr InfiniteIntTypeParam::get(NodeManager& manager) {
		return manager.get(InfiniteIntTypeParam());
	}


	bool InfiniteIntTypeParam::equals(const Node& other) const {
		if (this == &other) {
			return true;
		}
		return other.getNodeType() == NT_InfiniteIntTypeParam;
	}

	bool InfiniteIntTypeParam::operator<(const IntTypeParam& other) const {
			// nothing is larger than infinite
			return false;
		}


} // end namespace core
} // end namespace insieme
